A lo largo de nuestro aprendizaje de Java nos hemos topado en alguna ocasión con errores, pero éstos suelen ser los que nos ha indicado el compilador. Un *punto y coma* por aquí, un *nombre de variable incorrecto* por allá, pueden hacer que nuestro compilador nos avise de estos descuidos.

Cuando los vemos, se corrigen y obtenemos nuestra clase compilada correctamente. 

Pero, ¿*Sólo existen este tipo de errores*? ¿*Podrían existir errores no sintácticos en nuestros programas*? Está claro que sí. Un programa perfectamente compilado en el que no existen errores de sintaxis, puede generar otros tipos de errores que **quizá aparezcan en tiempo de ejecución**. A estos errores se les conoce como **excepciones**.

Aprenderemos a gestionar de manera adecuada estas excepciones y tendremos la oportunidad de utilizar el potente sistema de manejo de errores que Java incorpora. La potencia de este sistema de manejo de errores radica en:

1. Que el código que se encarga de manejar los errores, es perfectamente identificable en los programas. Este código puede estar separado del código que maneja la aplicación.
2. Que Java tiene una gran cantidad de errores estándar asociados a multitud de fallos comunes, como por ejemplo *divisiones por cero*, *fallos de entrada de datos*, *etc*. Al tener tantas excepciones localizadas, podemos gestionar de manera específica cada uno de los errores que se produzcan.

En Java se pueden preparar los fragmentos de código que pueden provocar errores de ejecución para que si se produce una excepción, el flujo del programa es lanzado (`throw`) hacia ciertas zonas o rutinas que han sido creadas previamente por el programador y cuya finalidad será el tratamiento efectivo de dichas excepciones. Si no se captura la excepción, el programa se detendrá con toda probabilidad.

En Java, las excepciones están representadas por clases. El paquete `java.lang.Exception` y sus subpaquetes contienen todos los tipos de excepciones. Todas las excepciones derivarán de la clase `Throwable`, existiendo clases más específicas. Por debajo de la clase `Throwable` existen las clases `Error` y `Exception`. 

**Error** es una clase que se encargará de los errores que se produzcan en la máquina virtual, no en nuestros programas. 

La clase **Exception** será la que a nosotros nos interese conocer, pues gestiona los errores provocados en los programas.

Java lanzará una excepción en respuesta a una situación poco usual. Cuando se produce un error se genera un objeto asociado a esa excepción. Este objeto es de la clase `Exception` o de alguna de sus herederas. Este objeto se pasa al código que se ha definido para manejar la excepción. Dicho código puede manipular las propiedades del objeto `Exception`.

El programador también puede lanzar sus propias excepciones. Las excepciones en Java serán objetos de clases derivadas de la clase base `Exception`. Existe toda una jerarquía de clases derivada de la clase base `Exception`. Estas clases derivadas se ubican en dos grupos principales:

- Las excepciones en tiempo de ejecución, que ocurren cuando el programador no ha tenido cuidado al escribir su código.
- Las excepciones que indican que ha sucedido algo inesperado o fuera de control.

En la siguiente imagen te ofrecemos una aproximación a la jerarquía de las excepciones en Java.

<div style="text-align:center;">
    <img src="../../img/ud03/throwable.png" alt="throwable" style="max-width:100%;" />
</div>

Y aquí tenemos una lista de las más habituales con su explicación:

| **NOMBRE**                         | DESCRIPCIÓN                                                  |
| ---------------------------------- | ------------------------------------------------------------ |
| **FileNotFoundException**          | Lanza una excepción cuando el fichero no se encuentra.       |
| **ClassNotFoundException**         | Lanza una excepción cuando no existe la clase.               |
| **EOFException**                   | Lanza una excepción cuando llega al final del fichero.       |
| **ArrayIndexOutOfBoundsException** | Lanza una excepción cuando se accede a una posición de un array que no exista. |
| **NumberFormatException**          | Lanza una excepción cuando se procesa un numero pero este es un dato alfanumérico. |
| **NullPointerException**           | Lanza una excepción cuando intentando acceder a un miembro de un objeto para el que todavía no hemos reservado memoria. |
| **IOException**                    | Generaliza muchas excepciones anteriores. La ventaja es que no necesitamos controlar cada una de las excepciones. |
| **Excepcion**                      | Es la clase padre de IOException y de otras clases. Tiene la misma ventaja que IOException. |
| **ArithmeticException**            | Se lanza por ejemplo, cuando intentamos dividir un número entre cero. |

## Capturar una excepción

Para poder capturar excepciones, emplearemos la estructura de captura de excepciones `try‐catch‐finally`.

Básicamente, para capturar una excepción lo que haremos será declarar bloques de código donde es posible que ocurra una excepción. Esto lo haremos mediante un bloque *try* (intentar). Si ocurre una excepción dentro de estos bloques, se lanza una excepción. Estas excepciones lanzadas se pueden capturar por medio de bloques *catch*. Será dentro de este tipo de bloques donde se hará el manejo de las excepciones.

Su sintaxis es:

```java
try {
	código que puede generar excepciones;
} catch (Tipo_excepcion_1 objeto_excepcion) {
	Manejo de excepción de Tipo_excepcion_1;
} catch (Tipo_excepcion_2 objeto_excepcion) {
	Manejo de excepción de Tipo_excepcion_2;
}
...
finally {
	instrucciones que se ejecutan siempre
}
```

En esta estructura, la parte `catch` puede repetirse tantas veces como excepciones diferentes se deseen capturar. La parte `finally` es opcional y, si aparece, solo podrá hacerlo una sola vez.

!!!note " "
	Cada `catch` maneja un tipo de excepción. Cuando se produce una excepción, se busca el `catch` que posea el manejador de excepción adecuado, será el que utilice el mismo tipo de excepción que se ha producido. Esto puede causar problemas si no se tiene cuidado, ya que la clase `Exception` es la superclase de todas las demás. Por lo que si se produjo, por ejemplo, una excepción de tipo `Aritmethic Exception` y el primer `catch` captura el tipo genérico `Exception`, será ese `catch` el que se ejecute y no los demás.<br /><br />
	Por eso el último `catch` debe ser el que capture excepciones genéricas y los primeros deben ser los más específicos. Lógicamente si vamos a tratar a todas las excepciones (sean del tipo que sean) igual, entonces basta con un solo `catch` que capture objetos `Exception`.

## El manejo de excepciones

Como hemos comentado, siempre debemos controlar las excepciones que se puedan producir o de lo contrario nuestro software quedará expuesto a fallos. Las excepciones pueden tratarse de dos formas:

- **Interrupción**. En este caso se asume que el programa ha encontrado un error irrecuperable. La operación que dio lugar a la excepción se anula y se entiende que no hay manera de regresar al código que provocó la excepción. Es decir, la operación que dio originó el error, se anula.
- **Reanudación**. Se puede manejar el error y regresar de nuevo al código que provocó el error.

Java emplea la primera forma, pero puede simularse la segunda mediante la utilización de un bloque `try` en el interior de un `while`, que se repetirá hasta que el error deje de existir. En la sección de ejemplos al final de este documento puedes ver cómo poner el `try-catch` dentro de un `do while`.

## Delegación de excepciones con `throws`

¿*Puede haber problemas con las excepciones al usar llamadas a métodos en nuestros programas*? Efectivamente, si se produjese una excepción es necesario saber quién será el encargado de solucionarla. Puede ser que sea el propio método llamado o el código que hizo la llamada a dicho método.

Quizá pudiéramos pensar que debería ser el propio método el que se encargue de sus excepciones, aunque es posible hacer que la excepción sea resuelta por el código que hizo la llamada. Cuando un método utiliza una sentencia que puede generar una excepción, pero dicha excepción no es capturada y tratada por él, sino que se encarga su gestión a quién llamó al método, decimos que se ha producido **delegación de excepciones**.

Para establecer esta delegación, en la cabecera del método se declara el tipo de excepciones que puede generar y que deberán ser gestionadas por quien invoque a dicho método. Utilizaremos para ello la sentencia `throws` y tras esa palabra se indica qué excepciones puede provocar el código del método. Si ocurre una excepción en el método, el código abandona ese método y regresa al código desde el que se llamó al método. Allí se buscará el `catch` apropiado para esa excepción. Su sintaxis es la siguiente:

```java
public class Delegacion_Excepciones {
	...
	public int leeAnio(BufferedReader lector) throws IOException, NumberFormatException {
		String linea = teclado.readLine();
        return Integer.parseInt(linea);
	}
	...
}
```

Donde `IOException` y `NumberFormatException`, serían dos posibles excepciones que el método `leeAnio` podría generar, pero que no gestiona. Por tanto, un método puede incluir en su cabecera un listado de excepciones que puede lanzar, separadas por comas.

## Excepciones comprobadas y no comprobadas

Existen dos grupos de excepciones: **comprobadas** y **no comprobadas** (observa la figura del apartado “Jerarquía de excepciones”).

- Excepciones **comprobadas**, verificadas ( o `checked`):

   - Su tratamiento es obligatorio y el compilador comprueba que se haga. Es necesario capturarlas (con `try-catch`) o propagarlas (con `throws`), de lo contrario se produce error de compilación.

   - Son excepciones que un programa bien escrito debería prever, tratar y recuperarse de ellas.

      Ejemplo: Nuestro programa va a leer y mostrar por pantalla el contenido de un fichero cuyo nombre indica el usuario. En la mayoría de ocasiones el usuario indicará el nombre de un fichero existente y válido y el programa lo mostrará, pero es posible que en alguna ocasión el usuario se equivoque e indique el nombre de un fichero que no existe. En tal caso se producirá una excepción `FileNotFoundException`. El programa debería ser capaz de manejar la situación, informar al usuario y permitirle, si se estima oportuno, que introduzca un nombre de fichero válido.

   - Son comprobadas las derivadas de `java.lang.IOException` y las excepciones de usuario (que trataremos más adelante).

- Excepciones **no** **comprobadas**, no verificadas ( o `unchecked`):

   - Su tratamiento no es obligatorio y el compilador obliga a que se utilice un bloque `try-catch` o a que se anuncie su propagación usando `throws`. Aunque no es obligatorio, puede hacerse si se estima conveniente.

   - Son excepciones que suelen producirse porque nuestro programa contiene algún error. Es por eso que no se comprueban, pues el objetivo no es recuperarse de ellas, sino avisarnos de que estamos tratando de realizar alguna operación no posible. La solución no pasa por capturarlas, sino por modificar el programa.

      Siguiendo con el ejemplo anterior, supongamos que el usuario introduce un nombre de fichero correcto pero, por algún error en nuestro programa, al método encargado de leer el fichero en lugar de llegarle el nombre le llega el valor `null`. En ese caso se producirá un `NullPointerException`.

      No tiene demasiado sentido capturar la excepción, puesto que se produce porque el programa contiene algún error que hay que subsanar.

   - Son no comprobadas las clases derivadas de `java.lang.Error` y de `java.lang.RuntimeException`  	

## Crear y lanzar excepciones de usuario:

Las excepciones de usuario son subclases de la clase `Exception` que podemos crear y lanzar en nuestros programas para avisar sobre determinadas situaciones.

### Crear una nueva excepción

Para crear una nueva excepción tenemos que crear una clase derivada (subclase) de la clase `Exception`. 

La clase `Exception` tiene dos constructores, uno sin parámetros y otro que acepta un `String` con un texto descriptivo de la excepción. Todas las excepciones de usuario las crearemos de la siguiente forma:

```java
class NombreExcepcion extends Exception {
	public NombreExcepcion(){
        super();
    }
	public NombreExcepcion(String msg){
        super(msg);
    }
}
```

### Lanzar una excepción

Las excepciones se lanzan mediante la instrucción `throw`. La sintaxis es:

```java
throw new NombreExcepcion("Mensaje descriptivo de la situación inesperada");
```

Ya que se tratará de una excepción comprobada, en la cabecera del método que lanza la excepción habrá que propagarla. 



!!!note "En Visual Studio Code"
	El IDE nos ayudará a gestionar las excepciones. Por ejemplo, en la siguiente linea de código en la línea 8 aparece un mensaje (*Unhandled exception type FileNotFoundException*) en el que nos indica que no hemos tratado este tipo de excepción, del tipo FileNotFoundException que hereda de IOException:
	<div style="text-align:center;">
	<img src="../../img/ud03/image-20230403101322542.png" alt="excepciones" style="max-width:100%;" />
	</div>
	Si, en Visual Studio Code, pulsamos en el icono azul (en otros IDEs como Eclipse también aparecen este tipo de advertencias) nos ofrece dos tipos de opciones para manejar el error/excepción:
	
	- `Add throws declaration` , en la que se declara la excepción en la misma declaración del método y se importa la clase *java.io.FileNotFoundException*, o
	
	- `Surround with try/catch`, en la que introduce un bloque de código que va a contener la excepción.



???+example "Ejemplo de excepciones"
	Vamos a realizar un programa en Java en el que se solicite al usuario la introducción de un número por teclado comprendido entre el 0 y el 100. Utilizando manejo de excepciones, controlaremos la entrada de dicho número y volver a solicitarlo en caso de que ésta sea incorrecta.
	```java
    import java.io.*;

    public class Excepciones {

        public static void main(String[] args) {
            int numero = -1;
            int intentos = 0;
            String linea;
            BufferedReader teclado = new BufferedReader(new InputStreamReader(System.in));
            do {
                try {
                    System.out.print("Introduzca un número entre 0 y 100: ");
                    linea = teclado.readLine();
                    numero = Integer.parseInt(linea);
                } catch (IOException e) {
                    System.out.println("Error al leer del teclado.");
                } catch (NumberFormatException e) {
                    System.out.println("Debe introducir un número entre 0 y 100.");
                } finally {
                    intentos++;
                }
            } while (numero < 0 || numero > 100);
            System.out.println("El número introducido es: " + numero);
            System.out.println("Número de intentos: " + intentos);
        }
    }
	```
	En este programa se solicita repetidamente un número utilizando una estructura `do­ while`, mientras el número introducido sea menor que 0 y mayor que 100. Como al solicitar el número pueden producirse los errores siguientes:<br />
	
	- De entrada de información a través de la excepción `IOException` generada por el método `readLine()` de la clase `BufferedReader`.<br />
	- De conversión de tipos a través de la excepción `NumberFormatException` generada por el método `parseInt()`.<br />
	
	Entonces se hace necesaria la utilización de bloques `catch` que gestionen cada una de las excepciones que puedan producirse. Cuando se produce una excepción, se compara si coincide con la excepción del primer `catch`. Si no coincide, se compara con la del segundo `catch` y así sucesivamente. Si se encuentra un `catch` que coincide con la excepción a gestionar, se ejecutará el bloque de sentencias asociado a éste.<br />
	
	Si ningún bloque `catch` coincide con la excepción lanzada, dicha excepción se lanzará fuera de la estructura `try‐catch‐finally`.<br />
	
	El bloque `finally`, se ejecutará tanto si `try` terminó correctamente, como si se capturó una excepción en algún bloque `catch`. Por tanto, si existe bloque `finally` éste se ejecutará siempre.<br />