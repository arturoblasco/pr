Java puede conectarse con distintos SGBD y en diferentes sistemas operativos. Independientemente del método en que se almacenen los datos debe existir siempre un **mediador** entre la aplicación y el sistema de base de datos y en Java esa función la realiza **JDBC**. 

!!!note "A tener en cuenta"
    Para la conexión a las bases de datos utilizaremos la API estándar de JAVA denominada **JDBC** (*Java Data Base Connectivity*).

JDBC es un API incluido dentro del lenguaje Java para el acceso a bases de datos. Consiste en un conjunto de clases e interfaces escritas en Java que ofrecen un completo API para la programación con bases de datos, por lo tanto es la única solución 100% Java que permite el acceso a bases de datos.

JDBC es una especificación formada por una colección de interfaces y clases abstractas, que todos los fabricantes de drivers deben implementar si quieren realizar una implementación de su driver 100% Java y compatible con JDBC (JDBC-compliant driver). Debido a que JDBC está escrito completamente en Java también posee la ventaja de ser independiente de la plataforma. 

!!!note "A tener en cuenta"
    No será necesario escribir un programa para cada tipo de base de datos, una misma aplicación escrita utilizando JDBC podrá manejar bases de datos Oracle, Sybase, SQL Server, etc.

<img src="../../img/ud09/jdbc2.png" alt="jdbc_rdbms" style="zoom:40%;" />

Además podrá ejecutarse en cualquier sistema operativo que posea una Máquina Virtual de Java, es decir, serán aplicaciones completamente independientes de la plataforma. Otras APIS que se suelen utilizar bastante para el acceso a bases de datos son DAO (Data Access Objects) y RDO (Remote Data Objects), y ADO (ActiveX Data Objects), pero el problema que ofrecen estas soluciones es que sólo son para plataformas Windows.

JDBC tiene sus clases en el paquete *java.sql* y otras extensiones en el paquete *javax.sql*.

<img src="../../img/ud09/jdbc_clases2.png" alt="jdbc paquetes" style="zoom:40%;" />

## Funciones del JDBC

Básicamente el API JDBC hace posible la realización de las siguientes tareas:

- Establecer una conexión con una base de datos.
- Enviar sentencias SQL.
- Manipular datos.
- Procesar los resultados de la ejecución de las sentencias.

## Drivers JDBC

Los drivers nos permiten conectarnos con una base de datos determinada. Existen **cuatro tipos de drivers JDBC**, cada tipo presenta una filosofía de trabajo diferente. A continuación se pasa a comentar cada uno de los drivers:

- **JDBC-ODBC bridge plus ODBC driver** (tipo 1): permite al programador acceder a fuentes de  datos ODBC existentes mediante JDBC. El JDBC-ODBC Bridge (puente JDBC-ODBC) implementa operaciones JDBC traduciéndolas a operaciones ODBC, se encuentra dentro del paquete *sun.jdbc.odbc* y contiene librerías nativas para acceder a ODBC.

​	Al ser usuario de ODBC depende de las dll de ODBC y eso limita la cantidad de plataformas en donde se puede ejecutar la aplicación.

- **Native-API partly-Java driver** (tipo 2): son similares a los drivers de tipo1, en tanto en cuanto  también necesitan una configuración en la máquina cliente. Este tipo de driver convierte llamadas JDBC a llamadas de Oracle, Sybase, Informix, DB2 u otros SGBD. Tampoco se pueden utilizar dentro de applets al poseer código nativo.
- **JDBC-Net pure Java driver** (tipo 3): Estos controladores están escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicación servidora utilizan las funciones nativas del sistema de gestión de base de datos mediante el uso de una biblioteca JDBC en el servidor. La ventaja de esta opción es la portabilidad.
- **JDBC de Java cliente** (tipo 4): Estos controladores están escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicación servidora utilizan las funciones nativas del sistema de gestión de base de datos sin necesidad de bibliotecas. La ventaja de esta opción es la portabilidad. Son como los drivers de tipo 3 pero sin la figura del intermediario y tampoco requieren ninguna configuración en la máquina cliente. Los drivers de tipo 4 se pueden utilizar para servidores Web de tamaño pequeño y medio, así como para intranets.

## Instalación controlador MySql

1) El primer paso es descargar desde https://www.mysql.com/products/connector/ el conector apropiado.

<img src="../../img/ud09/jdbc_1_download.png" alt="jdbc download" style="zoom: 50%;"/>

2) Elegir Sistema Operativo y versión:

<img src="../../img/ud09/jdbc_2_version.png" alt="jdbc version" style="zoom: 40%;" />

3) Haz clic en **Donwload** y selecciona la opción: **No thanks, just start download**

<img src="../../img/ud09/jdbc_2_accept.png" alt="aceptar jdbc" style="zoom: 40%;" />

4) Ejecuta el fichero *deb* (en el caso de *Ubuntu*) descargado:

<img src="../../img/ud09/jdbc_3_deb.png" alt="fichero debian" style="zoom: 70%;" />

5) Ahora deberemos añadir la librería JDBC a nuestro proyecto. Para ello copia el archivo `mysql-connector-java-8.3.0.jar` (en Ubuntu se encuentra en la ruta  `/usr/share/java`) en a *Referenced Libraries* de *VS Code*:

<img src="../../img/ud09/jdbc_5_anyadirjdbaVSC.png" alt="agregar libreria jdbc" style="zoom: 60%;" />

## Carga del controlador JDBC y conexión con la BD

El primer paso para conectarnos a una base de datos mediante JDBC es cargar el controlador apropiado. Estos controladores se distribuyen en un archivo `.jar` que provee el fabricante del SGBD y deben estar accesibles por la aplicación.

Para cargar el controlador se usan las siguientes sentencias:

```java
import java.sql.*;
public class ConnectToMySql {
  public static void main(String[] args) {
    try {
      // Dependiendo de a qué tipo de SGBD queramos conectar cargaremos un controlador u otro
      // Intentar cargar el driver de MySQL
      Class<?> c = Class.forName("com.mysql.jdbc.Driver");
      System.out.println("Cargado " + c.getName());
        
      //Definir la url de conexión y los parámetros de usuario y contraseña
      String host = "jdbc:mysql://localhost:3306/prueba";
      String username = "prueba";
      String password = "1234";
      Connection con = DriverManager.getConnection(host, username, password);
        
      System.out.println("Conexión completada");
      con.close();
    } catch (ClassNotFoundException cnfe) {
      System.out.println(cnfe.getMessage());
	} catch (SQLException ex) {
      System.out.println("ERROR al conectar: " + ex.getMessage());
    }
  }
}
```

Observamos las siguientes cuestiones:

- Como ya hemos comentado alguna vez, la sentencia `Class.forName()` no sería necesaria en muchas aplicaciones. Pero nos asegura que hemos cargado el driver, y por tanto el `DriverManager` la sabrá manejar
- El `DriverManager` es capaz de encontrar el driver adecuado a través de la url proporcionada (sobre todo si el driver está cargado en memoria), y es quien nos proporciona el objeto `Connection` por medio del método `getConnection()`. Hay otra manera de obtener el `Connection` por medio del objeto `Driver`, como veremos más adelante, pero también será pasando indirectamente por `DriverManager`.
- Si no se encuentra la clase del driver (por no tenerlo en las librerías del proyecto, o haber escrito mal su nombre) se producirá la excepción `ClassNotFoundException`. Es conveniente tratarla con `try ... catch`.
- Si no se puede establecer la conexión por alguna razón se producirá la excepción `SQLException`. Al igual que en el caso anterior, es conveniente tratarla con `try ... catch`.
- El objeto `Connection` mantendrá una conexión con la Base de Datos desde el momento de la creación hasta el momento de cerrarla con `close()`. Es muy importante cerrar la conexión, no sólo para liberar la memoria de nuestro ordenador (que al cerrar la aplicación liberaría), sino sobre todo para cerrar la sesión abierta en el Servidor de Bases de Datos.

Una manera de conectar alternativa a las anteriores es utilizando el objeto `Driver`. La clase `java.sql.Driver` pertenece a la **API JDBC**, pero no es instanciable, y tan sólo es una interfaz, para que las clases `Driver` de los contenedores hereden de ella e implementen la manera exacta de acceder al SGBD correspondiente. Como no es instanciable (no podemos hacer new Driver()) la manera de crearlo es a través del método `getDriver()` del `DriverManager`, que seleccionará el driver adecuado a partir de la url. Ya sólo quedarán definir algunas propiedades, como el usuario y la contraseña, y obtener el `Connection` por medio del método `connect()`

La manera de conectar a través de un objeto `Driver` es más larga, pero más completa ya que se podrían especificar más cosas. Y quizás ayude a entender el montaje de los controladores de los diferentes SGBD en Java.

```java
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class ConnectToMySqlDriver {

  public static void main(String[] args)  {
    String url="jdbc:mysql://localhost:3306/prueba";
    String username = "prueba";
    String password = "1234";
		
    try{
       Driver driver = DriverManager.getDriver(url);

	   Properties properties = new Properties();
	   properties.setProperty("user", username);
	   properties.setProperty("password", password);

	   Connection con = driver.connect(url, properties);
	   System.out.println("Conexión completada a través de Driver");
	   con.close();
	 } catch (SQLException ex) {
       System.out.println("ERROR al conectar: " + ex.getMessage());
     }
  }
}
```

## Carga del controlador y de la conexión mediante el patrón Singleton

Este patrón de diseño está diseñado para restringir la creación de objetos pertenecientes a una clase. Su intención consiste en garantizar que una clase sólo tenga una instancia y proporcionar un punto de acceso global a ella. El patrón `Singleton` se implementa creando en nuestra clase un método que crea una instancia del objeto sólo si todavía no existe alguna. Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haciéndolo privado. Las situaciones más habituales de aplicación de este patrón son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes para todas las capas (como puede ser el sistema de *log*, conexión a la base de datos, …) o cuando cierto tipo de datos debe estar disponible para todos los demás objetos de la aplicación (en java no hay variables globales) El patrón Singleton provee una única instancia global gracias a que:

- La propia clase es responsable de crear la única instancia.
- Permite el acceso global a dicha instancia mediante un método de clase.
- Declara el constructor de clase como privado para que no sea instanciable directamente.

```java
/**
 @see https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con
 Patron Singleton
 ================
 Este patrón de diseño está diseñado para restringir la creación de objetos pertenecientes a una clase.
 Su intención consiste en garantizar que una clase sólo tenga una instancia y proporcionar un punto de acceso global a ella.
 El patrón Singleton se implementa creando en nuestra clase un método que crea una instancia del objeto sólo si todavía no existe alguna.
 Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haciéndolo privado.
 Las situaciones más habituales de aplicación de este patrón son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes para todas las capas (como puede ser el sistema de log, conexión a la base de datos, ...) o cuando cierto tipo de datos debe estar disponible para todos los demás objetos de la aplicación.
 El patrón Singleton provee una única instancia global gracias a que:
  - La propia clase es responsable de crear la única instancia.
  - Permite el acceso global a dicha instancia mediante un método de clase.
  - Declara el constructor de clase como privado (no es instanciable directamente).
 */
public class DatabaseConnection {
  private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase
  private static java.sql.Connection con;

  private DatabaseConnection() {
    // El Constructor es privado!!
  }

  public static DatabaseConnection getInstance(){
    //Si no hay ninguna instancia...
    if(dbInstance==null){
      dbInstance= new DatabaseConnection();
    }
      return dbInstance;
  }

  public static java.sql.Connection getConnection(){
    if(con==null){
      try {
        String host = "jdbc:mysql://localhost:3306/prueba";
        String username = "prueba";
        String password = "1234";
        con = java.sql.DriverManager.getConnection( host, username, password );
        System.out.println("Conexión realizada");
      } catch (java.sql.SQLException ex) {
        System.out.println("ERROR al conectar: " + ex.getMessage());
      }
    }
    return con;
  }
}
```

En el caso de **BlueJ**, se añaden las librerías desde *Herramientas -> Preferencias -> Librerías*

<img src="../../img/ud09/bluej00.png" alt="bluej 0" style="zoom:50%;" />

Creamos una nueva clase `DatabaseConnection` en *BlueJ*:

<img src="../../img/ud09/bluej01.png" alt="bluej 1" style="zoom:55%;" />

Vamos a crear una nueva clase `Test` para probar la conexión:

```java
import java.sql.*;
public class Test {
    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection();
    public Test(){
        //De momento no hace nada
    }
}
```

<img src="../../img/ud09/bluej02.png" alt="bluej 2" style="zoom:50%;" />

<img src="../../img/ud09/bluej03.png" alt="bluej 3" style="zoom:50%;" />

<img src="../../img/ud09/bluej04.png" alt="bluej 4" style="zoom:50%;" />

