¿*Qué son los iteradores realmente*? Son un **mecanismo que nos permite recorrer todos los elementos de una colección de forma sencilla**, de forma secuencial, y de forma segura. 

!!!note "Mapas"
	Los mapas, como no derivan de la interfaz `Collection` realmente, no tienen iteradores, pero como veremos, existe un truco interesante.

Los iteradores permiten recorrer las colecciones de dos formas: *bucles* `for‐each` (existentes en Java a partir de la versión 1.5) y a través de un bucle normal creando un *iterador*. Como los bucles `for-each` ya los hemos visto antes (y ha quedado patente su simplicidad), nos vamos a centrar en el otro método, especialmente útil en versiones antiguas de Java. Ahora la pregunta es, ¿*cómo se crea un iterador*? Pues invocando el método "`iterator()`" de cualquier colección.

Veamos un ejemplo (en el ejemplo `c` es una colección cualquiera):

```java
Iterator<Integer> it = c.iterator();
```

Fíjate que se ha especificado un parámetro para el tipo de dato genérico en el iterador (poniendo `<Integer>` después de `Iterator`). Esto es porque los iteradores son también clases genéricas, y es necesario especificar el tipo base que contendrá el iterador. Si no se especifica el tipo base del iterador, igualmente nos permitiría recorrer la colección, pero retornará objetos tipo Object (clase de la que derivan todas las clases), con lo que nos veremos obligados a forzar la conversión de tipo.

Para recorrer y gestionar la colección, el iterador ofrece tres métodos básicos:

- `boolean hasNext()` : retornará *true* si le quedan más elementos a la colección por visitar, *false* en caso contrario.
- `E next()` : retornará el siguiente elemento de la colección, si no existe siguiente elemento, lanzará una excepción ( `NoSuchElementException` para ser exactos), con lo que conviene chequear primero si el siguiente elemento existe.
- `remove()` : elimina de la colección el último elemento retornado en la última invocación de `next` (no es necesario pasárselo por parámetro). Cuidado, si `next` no ha sido invocado todavía, saltará una incómoda excepción.

¿*Cómo recorreríamos una colección con estos métodos*? Pues de una forma muy sencilla, un simple bucle mientras (`while`) con la condición `hasNext()` nos permite hacerlo:

```java
while (it.hasNext()) { // mientras haya siguiente elemento, seguiremos en el bucle
   Integer n = it.next(); // escogemos el siguiente elemento
    
   if (n%2 == 0)
      it.remove(); // si es par, eliminamos el elemento de la lista
}
```



¿*Qué elementos contendría la lista después de ejecutar el bucle*? Efectivamente, solo números impares.

!!!note "Acceso posicional en las listas con métodos `get` y `set`"
	Las listas permiten acceso posicional a través de los métodos `get` y `set`, y acceso secuencial a través de iteradores, ¿*cuál es para tí la forma más cómoda de recorrer todos los elementos, un acceso posicional a través un bucle `for (i=0; i<lista.size(); i++)` o un acceso secuencial usando un bucle `while (iterador.hasNext())`*?



¿*Qué inconvenientes tiene usar los iteradores sin especificar el tipo de objeto*? En el siguiente ejemplo, se genera una lista con los números del 0 al 10. De la lista, se eliminan aquellos que son pares y solo se dejan los impares. En el primer ejemplo se especifica el tipo de objeto del iterador, en el segundo ejemplo no; observa el uso de la conversión de tipos en la línea 7.

???+example "Ejemplo indicando el tipo de objeto del iterador"
	```java
    ArrayList<Integer> lista = new ArrayList<Integer>();
    for (int i=0; i<10; i++){
        lista.add(i); 
    }
    //lista: [0,1,2,3,4,5,6,7,8,9]
    Iterator<Integer> it = lista.iterator();
    while (it.hasNext()) {
        Integer n = it.next();
        if (n%2 == 0){
            it.remove();
        }
    }
    //lista: [1,3,5,7,9]
    ```

???+example "Ejemplo **no** indicando el tipo de objeto del iterador"
    ```java
    ArrayList <Integer> lista = new ArrayList<Integer>();
    for (int i=0; i<10; i++){
        lista.add(i); 
    }
    Iterator it = lista.iterator();
    while (it.hasNext()) {
        Integer n = (Integer)it.next();
        if (n%2 == 0){
            it.remove();
        }
    }
    ```

Un iterador es seguro porque esta pensado para no sobrepasar los límites de la colección, ocultando operaciones más complicadas que pueden repercutir en errores de software. Pero realmente se convierte en inseguro cuando es necesario hacer la operación de conversión de tipos. Si la colección no contiene los objetos esperados, al intentar hacer la conversión, saltará una incómoda excepción.

Usar genéricos aporta grandes ventajas, pero usándolos adecuadamente. 

Para recorrer los mapas con iteradores, hay que hacer un pequeño truco. Usamos el método `entrySet` que ofrecen los mapas para generar un conjunto con las entradas (pares de llave‐valor), o bien, el método `keySet` para generar un conjunto con las llaves existentes en el mapa. 

???+example "Veamos como sería para el segundo caso, el más sencillo":"
        ```java
    HashMap<Integer,Integer> mapa = new HashMap<>();
    for (int i=0; i<10; i++){
        mapa.put(i, i); // Insertamos datos de prueba en el mapa.
    }
    for (Integer elemento : mapa.keySet()){
        // Recorremos el conjunto generado por keySet, contendrá las llaves.
        Integer valor = mapa.get(elemento); //Para cada llave, accedemos a su valor si es necesario.
        System.out.println(valor);
    }
    ```

Lo único que tienes que tener en cuenta es que el conjunto generado por `keySet` no tendrá obviamente el método `add` para añadir elementos al mismo, dado que eso tendrás que hacerlo a través del mapa.

!!!warning "Eliminar elementos de una colección con iteradores"
	Si usas iteradores, y piensas eliminar elementos de la colección (e incluso de un mapa), debes usar el método `remove` del iterador y no el de la colección. Si eliminas los elementos utilizando el método `remove` de la colección, mientras estás dentro de un bucle de iteración, o dentro de un bucle `for‐each`, los fallos que pueden producirse en tu programa son impredecibles. ¿*Logras adivinar porqué se pueden producir dichos problemas*?<br/><br/>
	*Los problemas son debidos a que el método `remove` del iterador elimina el elemento de dos sitios: de la colección y del iterador en sí (que mantiene interiormente información del orden de los elementos). Si usas el método `remove` de la colección, la información solo se elimina de un lugar, de la colección.*

???+example "Revisa este ejemplo 9"
	Ejemplo que crea, rellena y recorre un `ArrayList` de dos formas diferentes. Cabe destacar que, por defecto, el método `System.out.println()` invoca al método `toString()` de los elementos que se le pasen como argumento, por lo que realmente no es necesario utilizar `toString()` dentro de `println()`.
    ```java
    package UD07.P3.Iterators;

    import java.util.ArrayList;
    import java.util.Iterator;
    
    public class Ejemplo09 {
    
      public static void main(String[] args) {
        //creamos la lista
        ArrayList l = new ArrayList();
    
        //Añadimos elementos al final de la lista
        l.add("uno");
        l.add("dos");
        l.add("tres");
        l.add("cuatro");
    
        //Añadimos el elemento en la posición 2
        l.add(2, "dos2");
    
        System.out.println(l.size()); //devuelve 5
        System.out.println(l.get(0)); //devuelve uno
        System.out.println(l.get(1)); //devuelve dos
        System.out.println(l.get(2)); //devuelve dos2
        System.out.println(l.get(3)); //devuelve tres
        System.out.println(l.get(4)); //devuelve cuatro
    
        //Recorremos la lista con un for y mostramos su contenido
        for (int i = 0; i < l.size(); i++) {
           System.out.print(l.get(i));
        }//imprime: unodosdos2trescuatro
    
        System.out.println();
    
        //Recorremos la lista con un Iterador
        //creamos el iterador
        Iterator it = l.iterator();
    
        //mientras haya elementos
        while (it.hasNext()) {
           System.out.print(it.next()); //obtengo el siguiente elemento
        }//imprime; unodosdos2trescuatro
    
        System.out.println();
    
        for (Object elemento : l) {
           System.out.print(elemento);
        }//imprime; unodosdos2trescuatro
      }
    }
    ```

???+example "Revisa este ejemplo 10"
	Este ejemplo es la versión del ejemplo 07 con iteradores.
    ```java
    package UD07.P3.Iterators;

    import UD07.P2_3_Listas.Producto;
    import java.util.ArrayList;
    import java.util.Iterator;
    
    public class Ejemplo10 {
    
      public static void main(String[] args) {
    
        //Definimos 5 instancias de la clase Producto
        Producto p1 = new Producto("Pan", 6);
        Producto p2 = new Producto("Leche", 2);
        Producto p3 = new Producto("Manzanas", 5);
        Producto p4 = new Producto("Brocoli", 2);
        Producto p5 = new Producto("Carne", 2);
    
        //Definir un ArrayList
        ArrayList<Producto> lista = new ArrayList<>();
    
        //Colocar instancias de producto en ArrayList
        lista.add(p1);
        lista.add(p2);
        lista.add(p3);
        lista.add(p4);
    
        //Añadimos "Carne" en la posición 1 de la lista
        lista.add(1, p5);
    
        //Añadimos "Carne" en la última posición
        lista.add(p5);
    
        //Imprimir el contenido del ArrayList
        System.out.println(" - Lista con " + lista.size() + " elementos");
    
        //Definir Iterator  para extraer/imprimir valores
        //si queremos utilizar un for con el iterador no hace falta poner el incremento
        for (Iterator<Producto> it = lista.iterator(); it.hasNext();) {
           Producto p = it.next();
           System.out.println(p.getNombre() + " : " + p.getCantidad());
        }
    
        p5.setCantidad(99); //cambiamos la cantidad al producto, cambiará la lista?
    
        ((Producto)lista.get(1)).setCantidad(66); //
    
        System.out.println(p5.getCantidad());
    
        //Imprimir el contenido del ArrayList
        System.out.println(" - Lista con " + lista.size() + " elementos");
    
        //Definir Iterator  para extraer/imprimir valores
        //si queremos utilizar un for con el iterador no hace falta poner el incremento
        for (Iterator<Producto> it = lista.iterator(); it.hasNext();) {
           Producto p = it.next();
           System.out.println(p.getNombre() + " : " + p.getCantidad());
        }
    
        //Eliminar todos los valores del ArrayList
        lista.clear();
        System.out.println(" - Lista final con " + lista.size() + " elementos");
      }
    }
    ```