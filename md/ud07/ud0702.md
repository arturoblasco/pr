Para indicar a un `TreeSet` cómo tiene que ordenar los elementos, debemos decirle cuándo un elemento va antes o después que otro, y cuándo son iguales. Para ello, utilizamos la interfaz genérica `java.util.Comparator`, usada en general en algoritmos de ordenación, como veremos más adelante.

Se trata de crear una clase que implemente dicha interfaz, así de fácil. Dicha interfaz requiere de un único método que debe calcular si un objeto pasado por parámetro es mayor, menor o igual que otro del mismo tipo. Veamos un ejemplo general de cómo implementar un comparador para una hipotética clase `Objeto`:

```java
class ComparadorDeObjetos implements Comparator<Objeto> {
	public int compare(Objeto o1, Objeto o2) { ... }
}
```

La interfaz `Comparator` obliga a implementar un único método, es el método `compare` , el cual tiene dos parámetros: los dos elementos a comparar. Las reglas son sencillas, a la hora de personalizar dicho método:

- Si el primer objeto (o1) es menor que el segundo (o2), debe retornar un número entero negativo.
- Si el primer objeto (o1) es mayor que el segundo (o2), debe retornar un número entero positivo.
- Si ambos son iguales, debe retornar 0.

A veces, cuando el orden que deben tener los elementos es diferente al orden real (por ejemplo cuando ordenamos los números en orden inverso), la definición de antes puede ser un poco liosa, así que es recomendable en tales casos pensar de la siguiente forma:

- Si el primer objeto (o1) debe ir antes que el segundo objeto (o2), retornar entero negativo.
- Si el primer objeto (o1) debe ir después que el segundo objeto (o2), retornar entero positivo.
- Si ambos son iguales, debe retornar 0.

Una vez creado el comparador simplemente tenemos que pasarlo como parámetro en el momento de la creación al `TreeSet` , y los datos internamente mantendrán dicha ordenación:

```java
TreeSet<Objeto> ts = new TreeSet<Objeto>(new ComparadorDeObjetos());
```

Hay otra manera de definir esta ordenación, pero lo estudiaremos más a fondo en el punto [Comparadores](#Comparadores).

???+example "Revisa este ejemplo 4"
	Realiza un pequeño programa que pregunte al usuario 5 números diferentes (almacenándolos en un `HashSet`), y que después calcule la suma de los mismos (usando un bucle `for‐each`).<br/><br/>
	**SOLUCIÓN**<br/><br/>
	Una solución posible podría ser la siguiente. Fíjate en la solución y verás que el uso de conjuntos ha simplificado enormemente el ejercicio, permitiendo al programador o la programadora centrarse en otros aspectos:
	```java
	package UD07.P2_HashSet;
	

	import java.util.HashSet;
	import java.util.Scanner;
	
	public class EjemploHashSet {
	
	    public static void main(String[] args) {
	        HashSet<Integer> conjunto = new HashSet<Integer>();
	        Scanner teclado = new Scanner(System.in);
	        int numero;
	        do {
	            try {
	                System.out.print("Introduce un número " + (conjunto.size() + 1) + ": ");
	                numero = teclado.nextInt();
	                if (!conjunto.add(numero)) {
	                    System.out.println("Número ya en la lista. Introducir otro.");
	                }
	            } catch (NumberFormatException e) {
	                System.out.println("Número erróneo.");
	            }
	        } while (conjunto.size() < 5);
	        // Calcular la suma
	        Integer suma = 0;
	        for (Integer i : conjunto) {
	            suma = suma + i;
	        }
	        System.out.println("La suma es: " + suma);
		}
	}
	```
???+example "Revisa este ejemplo 5"
	```java
    package UD07.P2_Comparator;

    import java.io.*;
    import java.util.*;
    
    class Estudiante {
      private int id;
      private String nombre;
    
      public Estudiante(int valor, String nombre) {
        this.id = valor;
        this.nombre = nombre;
      }
    
      public String getNombre() {
        return this.nombre;
      }
    
      public int getId() {
        return this.id;
      }
    }
    
    // Comparador mediante atributo entero
    static class IdComparator implements Comparator<Estudiante> {
      public int compare(Estudiante e1, Estudiante e2) {
        return e1.getId()-e2.getId();
      }
    }
    // Comparador mediante atributo String 
    static class NombreComparator implements Comparator<Estudiante> {
      public int compare(Estudiante e1, Estudiante e2) {
        return e1.getNombre().compareTo(e2.getNombre());
      }
    }
    
    class EjemploComparador {
    
      public static void main (String[] args){
        // Crear TreeSet con Comparador con objeto Estudiante
        TreeSet<Estudiante> setId = new TreeSet<Estudiante>(new IdComparator());
    
        setId.add(new Estudiante(450,"Laura"));
        setId.add(new Estudiante(341,"Esther"));
        setId.add(new Estudiante(134,"Daniel"));
        setId.add(new Estudiante(590,"Jorge"));
    
        System.out.println("Ordenación por marca:");
        for(Estudiante elemento : setId) {
           System.out.print(elemento.getNombre()+"\t"+elemento.getId());
           System.out.println();
        }  
    
        TreeSet<Estudiante> setNombre= new TreeSet<Estudiante>(new NombreComparator());
    
        setNombre.add(new Estudiante(450,"Laura"));
        setNombre.add(new Estudiante(341,"Esther"));
        setNombre.add(new Estudiante(134,"Daniel"));
        setNombre.add(new Estudiante(590,"Jorge"));
    
        System.out.println("Ordenación por nombre:");
        for(students elemento : setNombre) {
           System.out.print(elemento.getNombre() +"\t"+ elemento.getId());
           System.out.println();
        }
      }
    }
    ```
    
    ```bash
    Ordenación por marca:
    Daniel	134
    Esther	341
    Laura	450
    Jorge	590
    Ordenación por nombre:
    Daniel	134
    Esther	341
    Jorge	590
    Laura	450
    ```

## Listas

¿*En qué se diferencia una lista de un conjunto*? Las listas son elementos de programación un poco más avanzados que los conjuntos. Su ventaja es que amplían el conjunto de operaciones de las colecciones añadiendo operaciones extra. Veamos algunas de ellas:

- Sí **pueden almacenar duplicados**. Si no queremos duplicados, hay que verificar manualmente que el elemento no esté en la lista antes de su inserción.
- **Acceso posicional**. Podemos acceder a un elemento indicando su posición en la lista.
- **Búsqueda**. Es posible buscar elementos en la lista y obtener su posición. En los conjuntos, al ser colecciones sin aportar nada nuevo, solo se podía comprobar si un conjunto contenía o no un elemento, retornando verdadero o falso. Las listas mejoran este aspecto.
- **Extracción de sublistas**. Es posible obtener una lista que contenga solo una parte de los elementos de forma muy sencilla.

En Java, para las listas se dispone de una interfaz llamada **`java.util.List`**, y dos implementaciones (**`java.util.LinkedList`** y **`java.util.ArrayList`**), con diferencias significativas entre ellas. Los métodos de la interfaz **`List`**, que obviamente estarán en todas las implementaciones, y que permiten las operaciones anteriores son:

- **`E get(int index)`** : el método `get` permite obtener un elemento partiendo de su posición (index).
- **`E set(int index, E element)`** : el método `set` permite cambiar el elemento almacenado en una posición de la lista (index), por otro (element).
- **`void add(int index, E element)`** : se añade otra versión del método `add`, en la cual se puede insertar un elemento (element) en la lista en una posición concreta (index), desplazando los existentes.
- **`E remove(int index)`** : se añade otra versión del método `remove`, esta versión permite eliminar un elemento indicando su posición en la lista.
- **`boolean addAll(int index, Collection<? extends E> c)`** : se añade otra versión del método `addAll` , que permite insertar una colección pasada por parámetro en una posición de la lista, desplazando el resto de elementos.
- **`int indexOf(Object o)`** : el método `indexOf` permite conocer la posición (índice) de un elemento, si dicho elemento no está en la lista retornará `‐1`.
- **`int lastIndexOf(Object o)`** : el método `lastIndexOf` nos permite obtener la última ocurrencia del objeto en la lista (dado que la lista sí puede almacenar duplicados).
- **`List<E> subList(int from, int to)`** : el método `subList` genera una sublista (una vista parcial de la lista) con los elementos comprendidos entre la posición inicial (incluida) y la posición final (no incluida).

!!! warning "Comienzo de lista por 0"
	Ten en cuenta que los elementos de una lista empiezan a numerarse por 0. Es decir, que el primer elemento de la lista es el 0.<br/><br/>
	Ten en cuenta también que `List` es una interfaz genérica, por lo que `<E>` corresponde con el tipo base usado como parámetro genérico al crear la lista.

### Uso

Y, ¿*cómo se usan las listas*? Pues para usar una lista haremos uso de sus implementaciones **`LinkedList`** y **`ArrayList`**. Veamos un ejemplo de su uso y después obtendrás respuesta a esta pregunta.

<div style="text-align:center;">
    <img src="../../img/ud07/listas.png" alt="listas" style="max-width:100%;" />
</div>

Supongo que intuirás cómo se usan, pero nunca viene mal un ejemplo sencillo, que nos aclare las ideas. El siguiente ejemplo muestra cómo usar un `LinkedList` pero valdría también para `ArrayList` (no olvides importar las clases `java.util.LinkedList` y `java.util.ArrayList` según sea necesario). En este ejemplo se usan los métodos de acceso posicional a la lista:

```java
LinkedList<Integer> ll = new LinkedList<>(); // declaración y creación del LinkedList de enteros.
ll.add(1); // añade un elemento al final de la lista.
ll.add(3); // añade otro elemento al final de la lista.
ll.add(1,2); // añade en la posición 1 el elemento 2.
ll.add(ll.get(1) + ll.get(2)); // suma los valores contenidos en la posición 1 y 2, y lo agrega al final.
ll.remove(0); // elimina el primer elementos de la lista.
```

En el ejemplo anterior, se realizan muchas operaciones, ¿cuál será el contenido de la lista al final?

```java
// recorrer la colección:
for (Integer elemento: ll){
    System.out.print(elemento + " ");
}
// devuelve: 2 3 5
```

Veamos otro ejemplo, esta vez con `ArrayList`, de cómo obtener la posición de un elemento en la lista:

```java
ArrayList<Integer> al = new ArrayList<>(); // declaración y creación del ArrayList de enteros.
al.add(10); 
al.add(11); // añadimos dos elementos a la lista.
al.set(al.indexOf(11), 12); // sustituimos el 11 por el 12, primero lo buscamos y luego lo reemplazamos.
```

En el ejemplo anterior, se emplea tanto el método `indexOf` para obtener la posición de un elemento, como el método `set` para reemplazar el valor en una posición, una combinación muy habitual. El ejemplo anterior generará un `ArrayList` que contendrá dos números, el 10 y el 12. 

Veamos ahora un ejemplo algo más difícil:

```
al.addAll(0, ll.subList(1, ll.size()));
```

!!!danger "Cuidado"
	`subList` ==> Returns a view of the portion of this list between the specified `fromIndex`, inclusive, and `toIndex`, exclusive ([API de Java](https://docs.oracle.com/javase/8/docs/api/java/util/List.html#subList-int-int-)).

Este ejemplo es especial porque usa sublistas. Se usa el método `size` para obtener el tamaño de la lista. Después el método `subList` para extraer una sublista de la lista (que incluía en origen los números 2, 3 y 5), desde la posición 1 hasta el final de la lista (lo cual dejaría fuera al primer elemento). Y por último, se usa el método `addAll` para añadir todos los elementos de la sublista al `ArrayList` anterior desde su posición 0. Y quedaría:

```java
3, 5, 10 y 12.
```

Debes saber que las operaciones aplicadas a una sublista repercuten sobre la lista original. Por ejemplo, si ejecutamos el método `clear` sobre una sublista, se borrarán todos los elementos de la sublista, pero también se borrarán dichos elementos de la lista original:

```java
al.subList(0, 2).clear();
```

Lo mismo ocurre al añadir un elemento, se añade en la sublista y en la lista original.

???+example "Revisa este ejemplo 6"
	```java
	package UD07.P2_3_Listas;

    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.LinkedList;

    public class Ejemplo06 {

      private static void imprimirColeccion(Collection<?> c) {
        for (Object i : c) {
           System.out.print(i.toString() + " ");
        }
        System.out.println("");
      }
      public static void main(String[] args) {
        LinkedList<Integer> t = new LinkedList<>(); //declaración+creación LinkedList
        t.add(1); //añade un elemento al final de la lista
        t.add(3); //añade otro elemento al final de la lista
        t.add(1, 2); //añade en la posición 1 el elemento 2
        t.add(t.get(1) + t.get(2)); //suma contendio de posición 1 y 2, y agrega al final
        t.remove(0); //elimina el primer elementos de la lista
        imprimirColeccion(t); //2 3 5 

        ArrayList<Integer> al = new ArrayList<>(); //declaración+creación ArrayList
        al.add(10);
        al.add(11); //añadimos dos elementos a la lista.
        al.set(al.indexOf(11), 12); //sustituimos el 11 por el 12, primero lo buscamos y luego lo reemplazamos.

        al.addAll(0, t.subList(1, t.size()));
        imprimirColeccion(al); //3 5 10 12 

        al.subList(0, 2).clear();
        imprimirColeccion(al); //10 12 
      }
    }
	```



### `LinkedList` y `ArrayList`

¿*Y en qué se diferencia un* `LinkedList` *de un* `ArrayList` ?

Los **`LinkedList`** utilizan listas doblemente enlazadas, que son listas enlazadas (como se vio en un apartado anterior), pero que permiten ir hacia atrás en la lista de elementos. Los elementos de la lista se encapsulan en los llamados nodos.

Los nodos van enlazados unos a otros para no perder el orden y no limitar el tamaño de almacenamiento. Tener un doble enlace significa que en cada nodo se almacena la información de cuál es el siguiente nodo y además, de cuál es el nodo anterior. Si un nodo no tiene nodo siguiente o nodo anterior, se almacena null (o nulo) para ambos casos.

No es el caso de los **`ArrayList`**. Estos se implementan utilizando arrays que se van redimensionando conforme se necesita más espacio o menos. La redimensión es transparente a nosotros, no nos enteramos cuándo se produce, pero eso redunda en una diferencia de rendimiento notable dependiendo del uso. Los **ArrayList** son más rápidos en cuanto a acceso a los elementos, acceder a un elemento según su posición es más rápido en un array que en una lista doblemente enlazada (hay que recorrer la lista). En cambio, eliminar un elemento implica muchas más operaciones en un array que en una lista enlazada de cualquier tipo.

¿*Y esto qué quiere decir*? Que si se van a realizar muchas operaciones de eliminación de elementos sobre la lista, conviene usar una lista enlazada (`LinkedList`), pero si no se van a realizar muchas eliminaciones, sino que solamente se van a insertar y consultar elementos por posición, conviene usar una lista basada en arrays redimensionados (`ArrayList` ).

`LinkedList` tiene otras ventajas que nos puede llevar a su uso. Implementa las interfaces `java.util.Queue` y `java.util.Deque`. Dichas interfaces permiten hacer uso de las listas como si fueran una cola de prioridad o una pila, respectivamente.

Las **colas**, también conocidas como colas de prioridad, son una lista pero que aportan métodos para trabajar de forma diferente. ¿*Tú sabes lo que es hacer cola para que te atiendan en una ventanilla*? Pues igual. Se trata de que el primero que llega es el primero en ser atendido (`FIFO`, *First In First Out* en inglés). Simplemente se aportan tres métodos nuevos: meter en el final de la lista (`add` y `offer`), sacar y eliminar el elemento más antiguo (`poll`), y examinar el elemento al principio de la lista sin eliminarlo (`peek`). Dichos métodos están disponibles en las listas enlazadas `LinkedList` :

- **`boolean add(E e)`** y **`boolean offer(E e)`** : retornarán true si se ha podido insertar el elemento al final de la `LinkedList`.
- **`E poll()`** : retornará el primer elemento de la `LinkedList` y lo eliminará de la misma. Al insertar al final, los elementos más antiguos siempre están al principio. Retornará null si la lista está vacía.
- **`E peek()`** : retornará el primer elemento de la `LinkedList` pero no lo eliminará, permite examinarlo. Retornará null si la lista está vacía.

Las **pilas**, mucho menos usadas, son todo lo contrario a las listas. Una pila es igual que una montaña de hojas en blanco, para añadir hojas nuevas se ponen encima del resto, y para retirar una se coge la primera que hay encima de todas. En las pilas el último en llegar es el primero en ser atendido (`LIFO`, *Last In First Out* en inglés). Para ello se proveen de tres métodos: meter al principio de la pila (`push`), sacar y eliminar del principio de la pila (`pop`), y examinar el primer elemento de la pila (`peek`, igual que si usara la lista como una cola). Las pilas se usan menos y haremos menos hincapié en ellas. Simplemente ten en mente que, tanto las colas como las pilas, son una lista enlazada sobre la que se hacen operaciones especiales.

### A tener en cuenta

A la hora de usar las listas, hay que tener en cuenta un par de detalles, ¿*sabes cuáles*? Es sencillo, pero importante.

No es lo mismo usar las colecciones (listas y conjuntos) con objetos inmutables (`Strings`, `Integer`, etc.) que con objetos mutables. Los objetos inmutables no pueden ser modificados después de su creación, por lo que cuando se incorporan a la lista, a través de los métodos `add` , se pasan por copia (es decir, se realiza una copia de los mismos). En cambio los objetos mutables (como las clases que tú puedes crear), no se copian, y eso puede producir efectos no deseados.

Imagínate la siguiente clase, que contiene un número:

```java
class Test {
	public Integer num;
	Test (int num) {
        this.num = new Integer(num); 
    }
}
```

La clase de antes es mutable, por lo que no se pasa por copia a la lista. Ahora imagina el siguiente código en el que se crea una lista que usa este tipo de objeto, y en el que se insertan dos objetos:

```java
Test p1 = new Test(11); // se crea un objeto Test donde el entero que contiene vale 11.
Test p2 = new Test(12); // se crea otro objeto Test donde el entero que contiene vale 12.
LinkedList<Test> lista = new LinkedList<Test>(); // creamos una lista enlazada para objetos tipo Test.
lista.add(p1); // añadimos el primero objeto test.
lista.add(p2); // añadimos el segundo objeto test.
for (Test p:lista){
	System.out.println(p.num); // mostramos la lista de objetos.
}
```

¿*Qué mostraría por pantalla el código anterior*? Simplemente mostraría los números 11 y 12. Ahora bien, ¿*qué pasa si modificamos el valor de uno de los números de los objetos test*? ¿*Qué se mostrará al ejecutar el siguiente código*?

```java
p1.num = 44;
for (Test p:lista){
    System.out.println(p.num);
}
```

El resultado de ejecutar el código anterior es que se muestran los números 44 y 12. El número ha sido modificado y no hemos tenido que volver a insertar el elemento en la lista para que en la lista se cambie también. Esto es porque en la lista no se almacena una copia del objeto Test, sino un apuntador a dicho objeto (solo hay una copia del objeto a la que se hace referencia desde distintos lugares).

!!!note "Cita"
	Controlar la complejidad es la esencia de la programación." [Brian Kernighan](https://es.wikipedia.org/wiki/Brian_Kernighan){:target="_blank"}

???+example "Revisa este ejemplo 7"
	Tenemos la clase `Producto` con:

    - Dos atributos: nombre (`String`) y cantidad (`int`).
    - Un constructor con parámetros.
    - Un constructor sin parámetros.
    - Métodos `get` y `set` asociados a los atributos.
    
    `Producto.java`
    ```java
    package UD07.P2_3_Listas;

    public class Producto {

      //Atributos
      private String nombre;
      private int cantidad;

      //Métodos
      //Constructor con parámetros donde asignamos el valor dado a los atributos
      public Producto(String nombre, int cantidad) {
        this.nombre = nombre;
        this.cantidad = cantidad;
      }

      //Constructor sin parámetros donde inicializamos los atributos
      public Producto() {
        //La palabra reservada null se utiliza para inicializar los objetos,
        //indicando que el puntero del objeto no apunta a ninguna dirección
        //de memoria. No hay que olvidar que String es una clase.
        this.nombre = null;
        this.cantidad = 0;
      }

      //Metodo get y set
      public String getNombre() {
        return nombre;
      }

      public void setNombre(String nombre) {
        this.nombre = nombre;
      }

      public int getCantidad() {
        return cantidad;
      }

      public void setCantidad(int cantidad) {
        this.cantidad = cantidad;
      }
    }
    ```
    En el programa principal creamos una lista de productos y realizamos operaciones sobre ella:
    
    `Ejemplo06.java`
    ```java
    package UD07.P2_3_Listas;

    import java.util.ArrayList;

    public class Ejemplo07 {

      public static void main(String[] args) {

        //Definimos 5 instancias de la clase Producto
        Producto p1 = new Producto("Pan", 6);
        Producto p2 = new Producto("Leche", 2);
        Producto p3 = new Producto("Manzanas", 5);
        Producto p4 = new Producto("Brocoli", 2);
        Producto p5 = new Producto("Carne", 2);

        //Definir un ArrayList
        ArrayList<Producto> lista = new ArrayList<>();

        //Colocar instancias de producto en ArrayList
        lista.add(p1);
        lista.add(p2);
        lista.add(p3);
        lista.add(p4);

        //Añadimos "Carne" en la posición 1 de la lista
        lista.add(1, p5);

        //Añadimos "Carne" en la última posición
        lista.add(p5);

        //Imprimir el contenido del ArrayList
        System.out.println(" - Lista con " + lista.size() + " elementos");

        for (Producto p : lista) {
          System.out.println(p.getNombre() + " : " + p.getCantidad());
        }

        p5.setCantidad(99); //cambiamos la cantidad al producto, cambiará la lista?

        ((Producto)lista.get(1)).setCantidad(66); //

        System.out.println(p5.getCantidad());

        //Imprimir el contenido del ArrayList
        System.out.println(" - Lista con " + lista.size() + " elementos");

        for (Producto p : lista) {
           System.out.println(p.getNombre() + " : " + p.getCantidad());
        }

        //Eliminar todos los valores del ArrayList
        lista.clear();
        System.out.println(" - Lista final con " + lista.size() + " elementos");
      }
    }
    ```

## Mapas - conjuntos de pares [clave/valor]

¿*Cómo almacenarías los datos de un diccionario*? Tenemos por un lado cada palabra y por otro su significado. Para resolver este problema existen precisamente los arrays asociativos. Un tipo de array asociativo son los **mapas** o diccionarios, que permiten almacenar pares de valores conocidos como clave y valor. La clave se utiliza para acceder al valor, como una entrada de un diccionario permite acceder a su definición.

En Java existe la interfaz `java.util.Map` que define los métodos que deben tener los mapas, y existen tres implementaciones principales de dicha interfaz: `java.util.HashMap`, `java.util.TreeMap` y `java.util.LinkedHashMap`. ¿*Te suenan*? Claro que sí. Cada una de ellas, respectivamente, tiene características similares a `HashSet` , `TreeSet` y `LinkedHashSet` , tanto en funcionamiento interno como en rendimiento.

Los mapas utilizan clases genéricas para dar extensibilidad y flexibilidad, y permiten definir un tipo base para la clave, y otro tipo diferente para el valor. Veamos un ejemplo de cómo crear un mapa, que es extensible a los otros dos tipos de mapas:

```java
HashMap<String,Integer> t = new HashMap<>();
```

El mapa anterior permite usar cadenas como llaves y almacenar de forma asociada a cada llave, un número entero. Veamos los métodos principales de la interfaz `Map`, disponibles en todas las implementaciones. En los ejemplos, `V` es el tipo base usado para el valor (`Value`) y `K` el tipo base usado para la llave (`Key`):

| Método.                                | Descripción.                                                 |
| -------------------------------------- | ------------------------------------------------------------ |
| `V put(K key, V value);`               | Inserta un par de objetos llave (key) y valor (value) en el mapa. Si la llave ya existe en el mapa, entonces retornará el valor asociado que tenía antes, si la llave no existía, entonces retornará null. |
| `V get(Object key);`                   | Obtiene el valor asociado a una llave ya almacenada en el mapa. Si no existe la llave, retornará null. |
| `V remove(Object key);`                | Elimina la llave y el valor asociado. Retorna el valor asociado a la llave, por si lo queremos utilizar para algo, o null, si la llave no existe. |
| `boolean containsKey(Object key);`     | Retornará true si el mapa tiene almacenada la llave pasada por parámetro, false en cualquier otro caso. |
| `boolean containsValue(Object value);` | Retornará true si el mapa tiene almacenado el valor pasado por parámetro, false en cualquier otro caso. |
| `int size();`                          | Retornará el número de pares llave y valor almacenado en el mapa. |
| `boolean isEmpty();`                   | Retornará true si el mapa está vacío, false en cualquier otro caso. |
| `void clear();`                        | Vacía el mapa.                                               |

???+example "Revisa este ejemplo 8"
    ```java
    package UD07.P2_4_Maps;

    import java.util.HashMap;

    public class Ejemplo08 {

      public static void main(String[] args) {
         HashMap<String, Integer> hashMap = new HashMap<>();
         //Insertamos un solo elemento A con valor 1
         hashMap.put("A", 1);

         //Busqueda por clave
         if (hashMap.containsKey("A")) {
           System.out.printf("Contiene la clave A. Su valor es: %d\n", hashMap.get("A"));
         }

         //Busqueda por valor
         if (hashMap.containsValue(0)) {
           System.out.println("Contiene el valor 0");
         }

         //Eliminar el elemento con clave A
         hashMap.remove("A");

         //Ahora añadimos varios elementos para imprimirlos
         hashMap.put("A", 1);
         hashMap.put("E", 12);
         hashMap.put("I", 15);
         hashMap.put("O", 0);
         hashMap.put("U", 0);
         //Recorremos el mapa y lo imprimimos
         for (HashMap.Entry<String, Integer> elemento : hashMap.entrySet()) {
           System.out.printf("Clave: %s. Valor: %d\n", elemento.getKey(), elemento.getValue());
         }
      }
    }
    ```