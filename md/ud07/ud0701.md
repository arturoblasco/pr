<div style="text-align:center;">
    <img src="../../img/ud07/cover07.png" alt="portada" style="max-width:50%;" />
</div>



Cuando el volumen de datos a manejar por una aplicación es elevado, no basta con utilizar variables.

Manejar los datos de un único pedido en una aplicación puede ser relativamente sencillo, pues un pedido está compuesto por una serie de datos y eso simplemente se traduce en varias variables. Pero, ¿qué ocurre cuando en una aplicación tenemos que gestionar varios pedidos a la vez? Lo mismo ocurre en otros casos. 

Para poder realizar ciertas aplicaciones se necesita poder manejar datos que van más allá de meros datos simples (números y letras). A veces, los datos que tiene que manejar la aplicación son datos compuestos, es decir, datos que están compuestos a su vez de varios datos más simples. Por ejemplo, un pedido está compuesto por varios datos, los datos podrían ser el cliente que hace el pedido, la dirección de entrega, la fecha requerida de entrega y los artículos del pedido.

Los datos compuestos son un tipo de estructura de datos, y en realidad ya los has manejado. Las clases son un ejemplo de estructuras de datos que permiten almacenar datos compuestos, y el objeto en sí, la instancia de una clase, sería el dato compuesto. Pero, a veces, los datos tienen estructuras aún más complejas, y son necesarias soluciones adicionales.

Esas soluciones consisten básicamente en la capacidad de poder manejar varios datos del mismo o diferente tipo de forma dinámica y flexible.

## Estructuras de almacenamiento

¿Cómo almacenarías en memoria un listado de números del que tienes que extraer el valor máximo?

Seguro que te resultaría fácil. Pero, ¿y si el listado de números no tiene un tamaño fijo, sino que puede variar en tamaño de forma dinámica? Entonces la cosa se complica.

Un listado de números que aumenta o decrece en tamaño es una de las cosas que aprenderás a utilizar aquí, utilizando estructuras de datos.

Pasaremos por alto las clases y los objetos, pues ya los has visto con anterioridad, pero debes saber que las clases en sí mismas son la evolución de un tipo de estructuras de datos conocidas como datos compuestos (también llamadas registros). Las clases, además de aportar la ventaja de agrupar datos relacionados entre sí en una misma estructura (característica aportada por los datos compuestos), permiten agregar métodos que manejen dichos datos, ofreciendo una herramienta de programación sin igual. Pero todo esto ya lo sabías.

Las **estructuras** de almacenamiento, en general, se pueden clasificar de varias formas, atendiendo a: 

| si pueden almacenar datos de diferente tipo o no             |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| con capacidad de almacenar varios datos **del mismo tipo**: varios números, varios caracteres, etc. | los **arrays**, las **listas**, los **conjuntos**, las **cadenas de caracteres** |
| con capacidad de almacenar varios datos **de distinto tipo:** números, fechas, cadenas de caracteres, etc. | las **clases**                                               |

| **en función de si pueden o no cambiar de tamaño** de forma dinámica |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| cuyo **tamaño** se establece en **el momento de la creación** o definición y su tamaño no puede variar después. | los **arrays**, las **matrices** (arrays multidimensionales) |
| cuyo **tamaño es variable** (conocidas como estructuras dinámicas). Su tamaño crece o decrece según las necesidades de forma dinámica. | las **listas**, **árboles**, **conjuntos** y el caso de algunos tipos de cadenas de caracteres. |

| atendiendo a **la forma en la que los datos se ordenan** dentro de la estructura |                            |
| ------------------------------------------------------------ | -------------------------- |
| que **no se ordenan de por sí**, y debe ser el programador el encargado de ordenar los datos si fuera necesario | los **arrays**             |
| **ordenadas**: al incorporar un dato nuevo a todos los datos existentes, este se almacena en una posición concreta que irá en función del orden. El orden establecido en la estructura puede variar dependiendo de las necesidades del programa: alfabético, orden numérico de mayor a menor, momento de inserción, etc. | **ArrayList**, **TreeSet** |

Todavía no conoces mucho de las estructuras, y probablemente todo te suena raro y extraño. No te preocupes, poco a poco irás descubriéndolas. Verás que son sencillas de utilizar y muy cómodas.

## Clases y métodos genéricos

¿*Crees que el código es más legible al utilizar genéricos o que se complica*? La verdad es que al principio cuesta, pero después, el código se entiende mejor que si se empieza a insertar conversiones de tipo.

Las clases genéricas son equivalentes a los métodos genéricos pero a nivel de clase, permiten definir un parámetro de tipo genérico que se podrá usar a lo largo de toda la clase, facilitando así crear clases genéricas que son capaces de trabajar con diferentes tipos de datos base. Para crear una clase genérica se especifican los parámetros de tipo al lado del nombre de la clase:

```java
 public class Util<T> {
	T temp;
     
	public void invertir (T[] array) {
	   for (int i = 0; i < array.length / 2; i++) {
	  	  temp = array[i];
		  array[i] = array[array.length - i - 1];
          array[array.length - i - 1] = temp;
       }
	}
}
```

En el ejemplo anterior, la clase `Util` contiene el método `invertir` cuya función es invertir el orden de los elementos de cualquier `array`, sea del tipo que sea. Para usar esa clase genérica hay que crear un objeto o instancia de dicha clase especificando el tipo base entre los símbolos menor que ("`<`") y mayor que ("`>`"), justo detrás del nombre de la clase. Veamos un ejemplo:

```java
Integer[] numeros = {0,1,2,3,4,5,6,7,8,9}; //el array clase wrapper

Util<Integer> u = new Util<Integer>();

u.invertir(numeros);
for (int i=0; i<numeros.length; i++){
   System.out.println(numeros[i]);
}
```

Como puedes observar, el uso de genéricos es sencillo, tanto a nivel de clase como a nivel de método.

Simplemente, a la hora de crear una instancia de una clase genérica, hay que especificar el tipo, tanto en la definición (`Util<Integer> u`) como en la creación (`new Util<Integer>()`).

Los genéricos los vamos a usar ampliamente a partir de ahora, aplicados a un montón de clases genéricas que tiene Java y que son de gran utilidad, por lo que es conveniente que aprendas bien a usar una clase genérica.

!!! warning "Parámetros de las clases genéricas"
	Los parámetros de tipo de las clases genéricas solo pueden ser clases:<br />
	:no_entry: no pueden ser jamás tipos de datos primitivos como `int`, `short`, `double`, etc.<br />
	:white_check_mark: debemos usar sus clases envoltorio (*wrappers*) `Integer`, `Short`, `Double`, etc.

Todavía hay un montón de cosas más sobre los métodos y las clases genéricas que deberías saber. A continuación se muestran algunos usos interesantes de los genéricos:

- Dos o más parámetros de tipo (I):

   Si el método genérico necesita tener dos o más parámetros genéricos, podemos indicarlo separándolos por comas. 

   ```java
   public class Util<T,M>{
       public static <T,M> int sumaDeLongitudes (T[] a, M[] b){
          return a.length + b.length;
       }
   }
   ```

​	En el ejemplo anterior se suman las longitudes de dos arrays que no tienen que ser del mismo tipo.

- Dos o más parámetros de tipo (II):

   Usar un método o una clase con dos o más parámetros genéricos es sencillo, a la hora de invocar al método o crear la clase, se indican los tipos base separados por coma.

   ```java
   Integer[] a1 = {0,1,2,3,4};
   Double[]  a2 = {0d,1d,2d,3d,4d};
   int resultado = Util.<Integer,Double>sumaDeLongitudes(a1,a2);
   System.out.println(resultado);
   ```

- Dos o más parámetros de tipo (III):

   Si una clase genérica necesita tener dos o más parámetros genéricos, podemos indicarlo separándolos por comas.
   En el ejemplo anterior se muestra una clase que almacena una terna de elementos de diferente tipo base que están relacionados entre sí.

   ```java
   public class Terna<A,B,C>{
     A a;
     B b;
     C c;
     public Terna(A a, B b, C c){
       this.a = a;
       this.b = b;
       this.c = c;
     }
     public A getA(){return a;}
     public B getB(){return b;}
     public C getC(){return c;}
   }
   ```

- Métodos con tipos adicionales:

   Una clase genérica puede tener unos parámetros genéricos, pero si en uno de sus métodos necesitamos otros parámetros genéricos distintos, no hay problema, podemos combinarlos.

   ```java
   class Util<A,B>{
     A a;
     Util (A a){
       this.a = a;
     }
     public <B> void salida(B b){
       System.out.println ( a.toString() + b.toString() );
     }
   }
   ```

- Inferencia (*deducción*) de tipos (I):

   No siempre es necesario indicar los tipos a la hora de instanciar un método genérico. A partir de Java 7, es capaz de determinar los tipos a partir de los parámetros.

   ```java
   Integer[] a1 = {0,1,2,3,4};
   Double[]  a2 = {0d,1d,2d,3d,4d};
   util.<Integer,Double>sumaDeLongitudes(a1,a2);
   util.sumaDeLongitudes(a1,a2);  //no es necesario indicar el tipo para instanciar
   ```

   Las dos expresiones de arriba serian válidas y funcionarían. Si no es capaz de inferirlos, nos dará un error a la hora de compilar.

- Inferencia de tipos (II):

   A partir de Java 7 es posible usar el operador diamante `< >` para simplificar la instanciación o creación de nuevos objetos a partir de clases genéricas. **Cuidado, esto solo es posible a partir de Java 7**.

   ```java
   Integer a1 = 0;
   Double  d1 = 1.3d;
   Float   f1 = 1.4f;
   Terna <Integer,Double,Float> t = new Terna<>(a1,d1,f1);
   ```

- Limitación de tipos:

   Se pueden limitar el conjunto de tipos que se pueden usar con una clase o método genérico usando el operador `extends`. El operador `extends` permite indicar que la clase que se pasa como parámetro genérico tiene que derivar de una clase específica.

   ```java
   public class Util {
       public static <T extends Number> Double sumar (T t1, T t2){
           return t1.doubleValue() + t2.doubleValue();
       }
   }
   ```

   En el ejemplo, no se admitirá ninguna clase que no derive de `Number`, pudiendo así realizar operaciones matemáticas.

- Paso de clases genéricas por parámetro:

   Cuando un método tiene como parámetro una clase genérica (como en el caso del método test del ejemplo), se puede especificar cuál debe ser el tipo base usado en la instancia de la clase genérica que se le pasa como argumento. Esto permite, entre otras cosas, crear diferentes versiones de un mismo método (sobrecarga), dependiendo del tipo base usado en la instancia de la clase genérica se ejecutará una versión u otra.

   ```java
   public class Ejemplo <A> {
     public A a;
   }
   ...
   void test (Ejemplo<Integer> e) {
     ...
   }
   ```

- Paso de clases genéricas por parámetro. Wildcards (I):

   Cuando un método admite como parámetro una clase genérica en la que no importa el tipo de objeto sobre la que se ha creado, podemos usar el interrogante para indicar "*cualquier tipo*".

   ```java
   public class Ejemplo <A> {
      public A a;
   }
   ...
   void test (Ejemplo<?> e) {
      ...
   }
   ```

   

- Paso de clases genéricas por parámetro. Wildcards (II):

   También es posible limitar el conjunto de tipos que una clase genérica puede usar, a través del operador `extends`. El ejemplo anterior es como decir "*cualquier tipo que derive de Number*".

   ```java
   public class Ejemplo <A> {
      public A a;
   }
   ...
   void test (Ejemplo<? extends Number> e) {
      ...
   }
   ```

   
