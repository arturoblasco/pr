## ChoiceBox

El `ChoiceBox`control es una lista de valores a partir de los cuales el usuario realiza una selección. En esta implementación particular, hay un valor vacío que hace que la selección sea opcional.

La siguiente captura de pantalla muestra la `ChoiceBox` aplicación. Se hace una selección de "Muebles" y `Button` se presiona Guardar. Si presionamos el `Button` `Guardar` invoca un `println()` que imprime el objeto.

<div style="text-align:center;">
    <img src="../../img/ud10/choicebox.png" alt="choicebox" style="max-width: 100%;" />
</div>


El uso más simple del `ChoiceBox` es llenarlo con Strings. Este `ChoiceBox` se basa en una clase JavaFX llamada `Pair`. `Pair` es un contenedor general para cualquier par clave/valor y se puede usar en lugar de un dominio u otro objeto de propósito especial. Las cadenas solo deben usarse si pueden usarse sin manipulación o decodificarse de manera consistente.

### Convertidor de cadenas

Cuando se usa un objeto complejo para respaldar un `ChoiceBox`, `StringConverter` se necesita a. Este objeto serializa un String hacia y desde el `ChoiceBox`. Para este programa, solo se necesita codificar toString(), que reemplaza el toString() predeterminado del `Pair` objeto. (Tanto toString como fromString necesitarán una implementación para compilar).

Se utiliza un objeto vacío EMPTY_PAIR para evitar *NullPointerExceptions*. Se puede acceder al valor devuelto de assetClass().getValue() y compararlo de manera consistente sin agregar una lógica especial de manejo de valores nulos.

El ChoiceBox se utiliza para seleccionar de una lista de valores. Cuando la lista de valores es de tipo complejo, proporcione un StringFormatter para serializar un objeto de lista en algo presentable. Si es posible, use un objeto vacío (en lugar de un nulo) para admitir valores opcionales.

### Código completo

El código se puede probar en un solo archivo .java.

**`ChoicesApp.java`**

```java
public class ChoicesApp extends Application {

	private final ChoiceBox<Pair<String,String>> assetClass = new ChoiceBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label label = new Label("Asset Class:");
        assetClass.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                            label,
                            assetClass,
                            saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initChoice();

        saveButton.setOnAction(
        	(evt) -> System.out.println("saving " + assetClass.getValue())
        );

        primaryStage.setTitle("ChoicesApp");
        primaryStage.setScene( scene );
        primaryStage.show();

    }

    private void initChoice() {

        List<Pair<String,String>> assetClasses = new ArrayList<>();
        assetClasses.add( new Pair("Equipment", "20000"));
        assetClasses.add( new Pair("Furniture", "21000"));
        assetClasses.add( new Pair("Investment", "22000"));

        assetClass.setConverter( new StringConverter<Pair<String,String>>() {
        	@Override
            public String toString(Pair<String, String> pair) {
                return pair.getKey();
            }

            @Override
            public Pair<String, String> fromString(String string) {
                return null;
            }
        });

        assetClass.getItems().add( EMPTY_PAIR );
        assetClass.getItems().addAll( assetClasses );
        assetClass.setValue( EMPTY_PAIR );

    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

## ComboBox

Un `ComboBox` es un control híbrido que presenta una lista de valores más un control de edición. Este artículo muestra una forma básica de la `ComboBox` cual es una lista no editable de elementos creados en una estructura de datos compleja.

Esta captura de pantalla muestra una ComboBoxApp que contiene una lista de cuentas de gastos. Las cuentas se almacenan en una clase JavaFX de clave/valor `Pair`. La consola muestra el resultado de una operación de guardado después de que el usuario seleccione "Gastos automáticos".

<div style="text-align:center;">
    <img src="../../img/ud10/combobox.png" alt="combobox" style="max-width:95%;" />
</div>

Este código agrega una etiqueta, un cuadro combinado y un botón a un HBox. El ComboBox se instancia como un campo y se inicializa en un método presentado más adelante initCombo(). Se coloca un controlador en el botón Guardar que genera un valor si se selecciona un elemento o un mensaje especial si no se selecciona ningún elemento.

###  CellFactory

El método initCombo() agrega varias cuentas de gastos a un archivo `List`. Esto `List`se agrega a los `ComboBox`elementos después de `Pair`agregar un objeto vacío. El valor inicial se establece en EMPTY_PAIR, que es una constante.

Si no se especifica, `ComboBox`utilizará el método toString() del objeto (en este artículo, a `Pair`) para representar un objeto de respaldo. Para cadenas, como una selección de "Sí" o "No", no se necesita código adicional. Sin embargo, toString() de a `Pair`generará tanto la clave legible por humanos como el valor preferido por la máquina. Los requisitos para esto `ComboBox`son usar solo las teclas legibles por humanos en la pantalla.

Para ello, se proporciona un cellFactory que configurará un `ListCell`objeto con la `Pair`clave como contenido. El `Callback`tipo es detallado, pero la esencia de la fábrica es establecer el texto de a `ListCell`en el método updateItem() de una clase interna anónima. Tenga en cuenta que se debe llamar al método de superclase.

se usa en el `Callback`método setButtonCell() para proporcionar una celda para el control de edición. Tenga en cuenta que este programa no es editable, que es el predeterminado. Sin embargo, se necesita factory.call(null), de lo contrario, solo se formateará correctamente el contenido del menú emergente y la vista del control en reposo recurrirá a toString().

Este artículo presentó un uso simple de `ComboBox`. Dado que este control no era editable, `ChoiceBox`se puede sustituir. Para representaciones gráficas no editables (por ejemplo, una forma codificada por colores para un valor de estado), `ComboBox`aún sería necesario definir el `Node`uso específico en el control.

### Código completo

El código se puede probar en un solo archivo .java.

**`CombosApp.java`**

```java
public class CombosApp extends Application {

    private final ComboBox<Pair<String, String>> account = new ComboBox<>();

    private final static Pair<String, String> EMPTY_PAIR = new Pair<>("", "");

    @Override
    public void start(Stage primaryStage) throws Exception {

        Label accountsLabel = new Label("Account:");
        account.setPrefWidth(200);
        Button saveButton = new Button("Save");

        HBox hbox = new HBox(
                accountsLabel,
                account,
                saveButton);
        hbox.setSpacing( 10.0d );
        hbox.setAlignment(Pos.CENTER );
        hbox.setPadding( new Insets(40) );

        Scene scene = new Scene(hbox);

        initCombo();

        saveButton.setOnAction( (evt) -> {
            if( account.getValue().equals(EMPTY_PAIR ) ) {
                System.out.println("no save needed; no item selected");
            } else {
                System.out.println("saving " + account.getValue());
            }
        });

        primaryStage.setTitle("CombosApp");
        primaryStage.setScene( scene );
        primaryStage.show();
    }

    private void initCombo() {

        List<Pair<String,String>> accounts = new ArrayList<>();

        accounts.add( new Pair<>("Auto Expense", "60000") );
        accounts.add( new Pair<>("Interest Expense", "61000") );
        accounts.add( new Pair<>("Office Expense", "62000") );
        accounts.add( new Pair<>("Salaries Expense", "63000") );

        account.getItems().add( EMPTY_PAIR );
        account.getItems().addAll( accounts );
        account.setValue( EMPTY_PAIR );

        Callback<ListView<Pair<String,String>>, ListCell<Pair<String,String>>> factory =
            (lv) ->
                    new ListCell<Pair<String,String>>() {
                        @Override
                        protected void updateItem(Pair<String, String> item, boolean empty) {
                            super.updateItem(item, empty);
                            if( empty ) {
                                setText("");
                            } else {
                                setText( item.getKey() );
                            }
                        }
                    };

        account.setCellFactory( factory );
        account.setButtonCell( factory.call( null ) );
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

## ListView

### Filtrado ListView en JavaFX

Este artículo demuestra cómo filtrar un ListView en una aplicación JavaFX. La aplicación gestiona dos listas. Una lista contiene todos los elementos del modelo de datos. La segunda lista contiene los elementos que se están visualizando actualmente. Un trozo de lógica de comparación almacenada como filtro media entre los dos.

El enlace se usa mucho para mantener las estructuras de datos sincronizadas con lo que el usuario ha seleccionado.

Esta captura de pantalla muestra la aplicación que contiene una fila superior de ToggleButtons que configuran el filtro y un ListView que contiene los objetos.

<div style="text-align:center;">
    <img src="../../img/ud10/listview_filtering_screenshot.png" alt="listview_filtering_screenshot" style="max-width:35%;" />
</div>


### Estructuras de datos

El programa comienza con un modelo de dominio Player y una matriz de objetos Player.

La clase Player contiene un par de campos, team y playerName. Se proporciona un toString() para que cuando el objeto se agregue a ListView (que se presenta más adelante), no se necesite una clase ListCell personalizada.

Los datos de prueba para este ejemplo son una lista de jugadores de béisbol estadounidenses.

```java
Player[] players = {new Player("BOS", "David Ortiz"),
                    new Player("BOS", "Jackie Bradley Jr."),
                    new Player("BOS", "Xander Bogarts"),
                    new Player("BOS", "Mookie Betts"),
                    new Player("HOU", "Jose Altuve"),
                    new Player("HOU", "Will Harris"),
                    new Player("WSH", "Max Scherzer"),
                    new Player("WSH", "Bryce Harper"),
                    new Player("WSH", "Daniel Murphy"),
                    new Player("WSH", "Wilson Ramos") };
```

### Modelo

Como se mencionó al comienzo del artículo, el filtrado de ListView se centra en la gestión de dos listas. Todos los objetos se almacenan en una PlayerProperty de ObservableList envuelta y los objetos que se pueden ver actualmente se almacenan en una FilteredList envuelta, viewablePlayersProperty. viewablePlayersProperty se basa en playersProperty, por lo que las actualizaciones realizadas en los jugadores que cumplan con los criterios de FilteredList también se realizarán en viewablePlayers.

filterProperty() es una conveniencia para permitir que las personas que llaman se vinculen al Predicado subyacente.

La raíz de la interfaz de usuario es un VBox que contiene un HBox de ToggleButtons y un ListView.

### Acción de filtrado

Se adjunta un controlador a los ToggleButtons que modificarán filterProperty. A cada ToggleButton se le proporciona un Predicado en el campo userData. toggleHandler utiliza este Predicado proporcionado al establecer la propiedad de filtro. Este código establece el caso especial "Mostrar todo" ToggleButton.

Los ToggleButtons que filtran un equipo específico se crean en tiempo de ejecución en función de la matriz Players. Este Stream hace lo siguiente.

1. Reduzca la lista de jugadores a una lista distinta de cadenas de equipo
2. Cree un ToggleButton para cada cadena de equipo
3. Establezca un Predicado para que cada ToggleButton se use como filtro
4. Recopile los ToggleButtons para agregarlos al contenedor HBox

### Vista de la lista

El siguiente paso crea ListView y vincula ListView a viewablePlayersProperty. Esto permite que ListView reciba actualizaciones basadas en el cambio de filtro.

El resto del programa crea una Escena y muestra el Escenario. onShown carga el conjunto de datos en las listas playersProperty y viewablePlayersProperty. Aunque ambas listas están sincronizadas en esta versión particular del programa, si el filtro de stock es diferente a "sin filtro", no sería necesario modificar este código.

Este artículo usó el enlace para vincular una lista de objetos Player visibles a un ListView. Los jugadores visibles se actualizaron cuando se seleccionó un ToggleButton. La selección aplicó un filtro a un conjunto completo de jugadores que se mantuvo por separado como FilteredList (gracias @kleopatra_jx). El enlace se usó para mantener la interfaz de usuario sincronizada y para permitir una separación de preocupaciones en el diseño.

### Código completo

```java
public class FilterListApp extends Application {

	@Override
	public void start(Stage primaryStage) throws Exception {

		//
		// Test data
		//
		Player[] players = {new Player("BOS", "David Ortiz"),
		                    new Player("BOS", "Jackie Bradley Jr."),
		                    new Player("BOS", "Xander Bogarts"),
		                    new Player("BOS", "Mookie Betts"),
		                    new Player("HOU", "Jose Altuve"),
		                    new Player("HOU", "Will Harris"),
		                    new Player("WSH", "Max Scherzer"),
		                    new Player("WSH", "Bryce Harper"),
		                    new Player("WSH", "Daniel Murphy"),
		                    new Player("WSH", "Wilson Ramos") };

		//
		// Set up the model which is two lists of Players and a filter criteria
		//
		ReadOnlyObjectProperty<ObservableList<Player>> playersProperty =
				new SimpleObjectProperty<>(FXCollections.observableArrayList());

		ReadOnlyObjectProperty<FilteredList<Player>> viewablePlayersProperty =
				new SimpleObjectProperty<FilteredList<Player>>(
						new FilteredList<>(playersProperty.get()
								));

		ObjectProperty<Predicate<? super Player>> filterProperty =
			viewablePlayersProperty.get().predicateProperty();


		//
		// Build the UI
		//
		VBox vbox = new VBox();
		vbox.setPadding( new Insets(10));
		vbox.setSpacing(4);

		HBox hbox = new HBox();
		hbox.setSpacing( 2 );

		ToggleGroup filterTG = new ToggleGroup();

		//
		// The toggleHandler action wills set the filter based on the TB selected
		//
		@SuppressWarnings("unchecked")
		EventHandler<ActionEvent> toggleHandler = (event) -> {
				ToggleButton tb = (ToggleButton)event.getSource();
			    Predicate<Player> filter = (Predicate<Player>)tb.getUserData();
			    filterProperty.set( filter );
			};

		ToggleButton tbShowAll = new ToggleButton("Show All");
		tbShowAll.setSelected(true);
		tbShowAll.setToggleGroup( filterTG );
		tbShowAll.setOnAction(toggleHandler);
		tbShowAll.setUserData( (Predicate<Player>) (Player p) -> true);

		//
		// Create a distinct list of teams from the Player objects, then create
		// ToggleButtons
		//
		List<ToggleButton> tbs = Arrays.asList( players)
				.stream()
				.map( (p) -> p.getTeam() )
				.distinct()
				.map( (team) -> {
					ToggleButton tb = new ToggleButton( team );
					tb.setToggleGroup( filterTG );
					tb.setOnAction( toggleHandler );
					tb.setUserData( (Predicate<Player>) (Player p) -> team.equals(p.getTeam()) );
					return tb;
				})
				.collect(Collectors.toList());

		hbox.getChildren().add( tbShowAll );
		hbox.getChildren().addAll( tbs );

		//
		// Create a ListView bound to the viewablePlayers property
		//
		ListView<Player> lv = new ListView<>();
		lv.itemsProperty().bind( viewablePlayersProperty );

		vbox.getChildren().addAll( hbox, lv );

		Scene scene = new Scene(vbox);

		primaryStage.setScene( scene );
		primaryStage.setOnShown((evt) -> {
			playersProperty.get().addAll( players );
		});

		primaryStage.show();

	}

	public static void main(String args[]) {
		launch(args);
	}

	static class Player {

		private final String team;
		private final String playerName;
		public Player(String team, String playerName) {
			this.team = team;
			this.playerName = playerName;
		}
		public String getTeam() {
			return team;
		}
		public String getPlayerName() {
			return playerName;
		}
		@Override
		public String toString() { return playerName + " (" + team + ")"; }
	}
}
```

## TableView

Para las aplicaciones comerciales de JavaFX, el `TableView` es un control esencial. Utilice a `TableView` cuando necesite presentar varios registros en una estructura plana de filas/columnas. Este ejemplo muestra los elementos básicos de a `TableView` y demuestra la potencia del componente cuando se aplica JavaFX Binding.

La aplicación de demostración es un `TableView`y un par de botones. Tiene cuatro TableColumns `TableView`: SKU, Artículo, Precio, Impuesto. Muestra `TableView`tres objetos en tres filas: teclado mecánico, documentos de productos, juntas tóricas. La siguiente captura de pantalla muestra la aplicación inmediatamente después del inicio.

<div style="text-align:center;">
    <img src="../../img/ud10/tableviewselectapp_screenshot.png" alt="tableviewselectapp_screenshot" style="max-width:85%;" />
</div>

La lógica deshabilitada de los botones se basa en las selecciones del archivo `TableView`. Inicialmente, no se seleccionan elementos, por lo que ambos botones están deshabilitados. Si se selecciona cualquier elemento, el primer elemento en la siguiente captura de pantalla, el Inventario `Button`está habilitado. `Button`También se habilita el Impuesto aunque requiere consultar el valor del Impuesto .

<div style="text-align:center;">
    <img src="../../img/ud10/tableviewselectapp_screenshot_selected_tax.png" alt="tableviewselectapp_screenshot_selected_tax" style="max-width:85%;" />
</div>

Si el valor del impuesto para el elemento seleccionado es falso, el impuesto `Button`se desactivará. Esta captura de pantalla muestra el segundo elemento seleccionado. El Inventario `Button`está habilitado pero el Impuesto `Button`no.

<div style="text-align:center;">
    <img src="../../img/ud10/tableviewselectapp_screenshot_selected_notax.png" alt="tableviewselectapp_screenshot_selected_notax" style="max-width:85%;" />
</div>

### Modelo y Declaraciones

A `TableView` se basa en un modelo que es un POJO llamado Item.

Los `TableView`y `TableColumn` usan genéricos en sus declaraciones. Para `TableView`, el parámetro de tipo es Artículo. Para TableColumns, los parámetros de tipo son Item y el tipo de campo. El constructor de `TableColumn`acepta un nombre de columna. En este ejemplo, los nombres de las columnas difieren ligeramente de los nombres de los campos reales.

La adición de elementos de modelo a `TableView`se realiza mediante la adición de elementos a la colección subyacente.

En este punto, `TableView`se ha configurado y se han agregado los datos de prueba. Sin embargo, si fuera a ver el programa, vería tres filas vacías. Esto se debe a que a JavaFX le falta el vínculo entre POJO y TableColumns. Ese enlace se agrega a TableColumns mediante cellValueFactory.

En este punto mostrará los datos en las columnas correspondientes.

### Selección

Para recuperar el elemento o elementos seleccionados en un `TableView`, use el objeto selectionModel separado. Llamar a tblItems.getSelectionModel() devuelve un objeto que incluye una propiedad "selectedItem". Esto se puede recuperar y usar en un método, por ejemplo, para abrir una pantalla de detalles de edición. Como alternativa, getSelectionModel() puede devolver una propiedad JavaFX "selectedItemProperty" para expresiones vinculantes.

En la aplicación de demostración, dos botones están vinculados al modelo de selección del archivo `TableView`. Sin enlace, puede agregar oyentes que examinen la selección y realicen una llamada como setDisabled() en un botón. Antes de la `TableView`selección, también necesitaría lógica de inicialización para manejar el caso en el que no hay selección. La sintaxis de vinculación expresa esta lógica en una declaración declarativa que puede manejar tanto el oyente como la inicialización en una sola línea.

La propiedad de desactivación de btnInventory será verdadera si no hay ningún elemento seleccionado (isNull()). Cuando se muestra la pantalla por primera vez, no se realiza ninguna selección y `Button`se desactiva. Una vez que se realiza cualquier selección, se habilita btnInventory (deshabilitar=falso).

la lógica btnCalcTax es un poco más compleja. btnCalcTax también está deshabilitado cuando no hay selección. Sin embargo, btnCalcTax también considerará el contenido del elemento seleccionado. Se usa un enlace compuesto or() para unir estas dos condiciones. Como antes, hay una expresión isNull() para no seleccionar. Bindings.select() comprueba el valor de Item.taxable. Un artículo gravable verdadero habilitará btnCalcTax mientras que un artículo falso deshabilitará el `Button`.

Bindings.select() es el mecanismo para extraer un campo de un objeto. selectedItemProperty() es el elemento seleccionado cambiante y "sujeto a impuestos" es la ruta de acceso de un solo salto al campo sujeto a impuestos.

Este ejemplo mostró cómo configurar un `TableView`basado en un POJO. También presentaba un par de poderosas expresiones vinculantes que le permiten vincular controles relacionados sin escribir oyentes adicionales ni código de inicialización. Es `TableView`un control indispensable para el desarrollador de aplicaciones empresariales JavaFX. Será el mejor y más conocido control para mostrar una lista de elementos estructurados.

### Código completo

**`Item.java`**

```java
public class Item {

    private final String sku;
    private final String descr;
    private final Float price;
    private final Boolean taxable;

    public Item(String sku, String descr, Float price, Boolean taxable) {
        this.sku = sku;
        this.descr = descr;
        this.price = price;
        this.taxable = taxable;
    }

    public String getSku() {
        return sku;
    }

    public String getDescr() {
        return descr;
    }

    public Float getPrice() {
        return price;
    }

    public Boolean getTaxable() {
        return taxable;
    }
}
```

**`TableSelectApp.java`**

```java
public class TableSelectApp extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        TableView<Item> tblItems = new TableView<>();
        tblItems.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);

        VBox.setVgrow(tblItems, Priority.ALWAYS );

        TableColumn<Item, String> colSKU = new TableColumn<>("SKU");
        TableColumn<Item, String> colDescr = new TableColumn<>("Item");
        TableColumn<Item, Float> colPrice = new TableColumn<>("Price");
        TableColumn<Item, Boolean> colTaxable = new TableColumn<>("Tax");

        colSKU.setCellValueFactory( new PropertyValueFactory<>("sku") );
        colDescr.setCellValueFactory( new PropertyValueFactory<>("descr") );
        colPrice.setCellValueFactory( new PropertyValueFactory<>("price") );
        colTaxable.setCellValueFactory( new PropertyValueFactory<>("taxable") );

        tblItems.getColumns().addAll(
            colSKU, colDescr, colPrice, colTaxable
        );

        tblItems.getItems().addAll(
            new Item("KBD-0455892", "Mechanical Keyboard", 100.0f, true),
            new Item( "145256", "Product Docs", 0.0f, false ),
            new Item( "OR-198975", "O-Ring (100)", 10.0f, true)
        );

        Button btnInventory = new Button("Inventory");
        Button btnCalcTax = new Button("Tax");

        btnInventory.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull()
        );

        btnCalcTax.disableProperty().bind(
            tblItems.getSelectionModel().selectedItemProperty().isNull().or(
                    Bindings.select(
                        tblItems.getSelectionModel().selectedItemProperty(),
                        "taxable"
                    ).isEqualTo(false)
            )
        );

        HBox buttonHBox = new HBox( btnInventory, btnCalcTax );
        buttonHBox.setSpacing( 8 );

        VBox vbox = new VBox( tblItems, buttonHBox );
        vbox.setPadding( new Insets(10) );
        vbox.setSpacing( 10 );

        Scene scene = new Scene(vbox);

        primaryStage.setTitle("TableSelectApp");
        primaryStage.setScene( scene );
        primaryStage.setHeight( 376 );
        primaryStage.setWidth( 667 );
        primaryStage.show();
    }

    public static void main(String[] args) {

        launch(args);
    }
}
```

## ImageView

JavaFX proporciona las clases `Image`y `ImageView`para mostrar imágenes gráficas BMP, GIF, JPEG y PNG. Imagen es una clase que contiene los bytes de la imagen y, opcionalmente, la información de escala. El objeto Imagen se carga mediante un subproceso en segundo plano y la clase Imagen proporciona métodos para interactuar con la operación de carga. El objeto Imagen se usa independientemente de ImageView para crear cursores e íconos de aplicaciones.

ImageView es un JavaFX `Node`que contiene un objeto de imagen. ImageView hace que una imagen esté disponible en todo el marco. Un ImageView se puede agregar a un contenedor solo o junto con otros controles de IU. Por ejemplo, se puede agregar una imagen `Label`configurando la propiedad gráfica de la etiqueta.

Las imágenes también se pueden mostrar y manipular usando JavaFX CSS.

Esta captura de pantalla muestra un `TilePane`que contiene cuatro mosaicos del mismo tamaño. Cada mosaico contiene un ImageView de un teclado.

<div style="text-align:center;">
    <img src="../../img/ud10/imageapp_screenshot.png" alt="imageapp_screenshot.png" style="max-width:80%;" />
</div>

La imagen superior izquierda se muestra con el tamaño de imagen original de 320x240. La imagen superior derecha está escalada proporcionalmente. Dado que la imagen superior derecha es un rectángulo y el mosaico que lo contiene es un cuadrado, hay espacios en la parte superior e inferior para mantener la proporción correcta al estirar el ancho.

La imagen inferior izquierda llena el contenedor por completo. Sin embargo, al hacer que la imagen rectangular se ajuste al contenedor cuadrado, la imagen no se escala proporcionalmente sino que se estira en ambas direcciones.

La imagen inferior derecha llena el contenedor utilizando una versión ampliada de la imagen. Se crea una ventana gráfica cuadrada a partir de un Rectangle2D de 100x100 y se amplía proporcionalmente. Si bien la imagen de baja calidad es borrosa, no se deforma.

### Imagen

La clase de imagen proporciona constructores para crear un objeto de imagen a partir de las dimensiones del archivo de imagen o de un objeto transformado. Estas tres llamadas al constructor crean los objetos Image que se usan en los mosaicos de arriba a la derecha, de abajo a la izquierda y de abajo a la derecha, respectivamente.

ImageApp.java        

```java
public class ImageApp extends Application {

    private final static String IMAGE_LOC = "images/keyboard.jpg";

    @Override
    public void start(Stage primaryStage) throws Exception {

        Image image2 = new Image(IMAGE_LOC, 360.0d, 360.0d, true, true );
        Image image3 = new Image(IMAGE_LOC, 360.0d, 360.0d, false, true);
        Image image4 = new Image(IMAGE_LOC);
```

La URL de cadena que se pasa a todas las formas del constructor de imágenes es relativa a la ruta de clase. También se puede usar una URL absoluta como "[https://www.bekwam.com/images/bekwam_logo_hdr_rounded.png](https://www.bekwam.com/images/bekwam_logo_hdr_rounded.png){:target="_blank"}". Tenga en cuenta que las URL absolutas no generarán un error si no se encuentra su recurso.

imagen2 e imagen3 especifican dimensiones, formando un cuadrado más grande que el rectángulo de la imagen original. image2 conservará la relación de aspecto ("verdadera"). El constructor de image3 no conserva la relación de aspecto y aparecerá estirado.

### Vista de imagen

ImageView es un contenedor de nodo que permite que el objeto de imagen se use en contenedores JavaFX y controles de interfaz de usuario. En la imagen superior izquierda, se usa una forma abreviada de ImageView que pasa solo la URL de la imagen. Respetará las dimensiones originales y no requiere un objeto de imagen adicional.

iv3 e iv3 se basan en los objetos image2 e image3. Recuerde que estos objetos produjeron imágenes transformadas que se ajustan al contenedor cuadrado.

iv4 también se basa en un objeto de imagen transformado, pero en el caso de iv4, la transformación se realiza a través del objeto ImageView en lugar de la imagen. ImageView.setFitHeight se llama en lugar de Image.setFitHeight.

Además, se ajusta la ventana gráfica de iv4. Viewport controla la parte visible de ImageView. En este caso, la ventana gráfica se define como una sección de 100x100 de la imagen desplazada 20 píxeles a la izquierda y 50 píxeles hacia arriba.

Esta sección mostró las clases Image e ImageView que se usan para mostrar una imagen en un contenedor u otro control de UI. Estas clases definen el comportamiento de escalado de la imagen y se pueden usar con una ventana gráfica Rectangle2D para brindar una personalización adicional de la visualización de la imagen.

### Fuente

El código fuente completo y el proyecto Gradle se pueden encontrar en el siguiente enlace:  [Código postal de origen de ImageApp](https://translate.google.com/website?sl=en&tl=es&hl=ca&client=webapp&u=https://courses.bekwam.net/public_tutorials/source/bkcourse_imageapp_sources.zip){:target="_blank"}

