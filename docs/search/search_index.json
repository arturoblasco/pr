{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"m\u00f3dulo de Programaci\u00f3n (PR)","text":""},{"location":"#indice-de-unidades","title":"\u00cdndice de unidades","text":"unidad UD 00 Conocimientos previos UD 01 Elementos de un programa inform\u00e1tico UD 02 Utilizaci\u00f3n de objetos y clases UD 03 Estructuras de control y excepciones UD 04 Estructuras de datos Arrays y matrices. Recursividad UD 05 Desarrollo de clases UD 06 Lectura y escritura de informaci\u00f3n UD 07 Colecciones UD 08 Composici\u00f3n, Herencia y Polimorfismo UD 09 Acceso a bases de datos UD 10 Interfaz gr\u00e1fica"},{"location":"default/","title":"UD 10 Interfaz gr\u00e1fica","text":"<p>... p\u00e1gina por defecto ...</p>"},{"location":"ud08/ud0801/","title":"8.1 Relaciones entre clases","text":"<p>Cuando estudiaste el concepto de clase, \u00e9sta fue descrita como una especie de mecanismo de definici\u00f3n (plantillas), en el que se basar\u00eda el entorno de ejecuci\u00f3n a la hora de construir un objeto: un mecanismo de definici\u00f3n de objetos.</p> <p>Por tanto, a la hora de dise\u00f1ar un conjunto de clases para modelar el conjunto de informaci\u00f3n cuyo tratamiento se desea automatizar, es importante establecer apropiadamente las posibles relaciones que puedan existir entre unas clases y otras.</p> <p>En algunos casos es posible que no exista relaci\u00f3n alguna entre unas clases y otras, pero lo m\u00e1s habitual es que s\u00ed exista: una clase puede ser una especializaci\u00f3n (relaci\u00f3n entre dos clases donde una de ellas, la subclase, es una versi\u00f3n m\u00e1s especializada que la otra, la superclase, compartiendo caracter\u00edsticas en com\u00fan pero a\u00f1adiendo ciertas caracter\u00edsticas espec\u00edficas que la especializan). El punto de vista inverso ser\u00eda la generalizaci\u00f3n (relaci\u00f3n entre dos clases donde una de ellas, la superclase, es una versi\u00f3n m\u00e1s gen\u00e9rica que la otra, la subclase, compartiendo caracter\u00edsticas en com\u00fan pero sin las propiedades espec\u00edficas que caracterizan a la subclase). Es decir, que entre unas clases y otras habr\u00e1 que definir cu\u00e1l es su relaci\u00f3n (si es que existe alguna).</p> <p>Se pueden distinguir diversos tipos de relaciones entre clases:</p> <ul> <li>Clientela. Cuando una clase utiliza objetos de otra clase (por ejemplo al pasarlos como par\u00e1metros a trav\u00e9s de un m\u00e9todo).</li> <li>Composici\u00f3n. Cuando alguno de los atributos de una clase es un objeto de otra clase.</li> <li>Anidamiento. Cuando se definen clases en el interior de otra clase.</li> <li>Herencia. Cuando una clase comparte determinadas caracter\u00edsticas con otra (clase base), a\u00f1adi\u00e9ndole alguna funcionalidad espec\u00edfica (especializaci\u00f3n).</li> </ul> <p>La relaci\u00f3n de clientela la llevas utilizando desde que has empezado a programar en Java, pues desde tu clase principal (clase con m\u00e9todo <code>main</code> ) has estado declarando, creando y utilizando objetos de otras clases. Por ejemplo, si utilizas un objeto <code>String</code> dentro de la clase principal de tu programa, \u00e9ste ser\u00e1 cliente de la clase <code>String</code> (como suceder\u00e1 con pr\u00e1cticamente cualquier programa que se escriba en Java). Es la relaci\u00f3n fundamental y m\u00e1s habitual entre clases (la utilizaci\u00f3n de unas clases por parte de otras) y, por supuesto, la que m\u00e1s vas a utilizar t\u00fa tambi\u00e9n; de hecho, ya la has estado utilizando y lo seguir\u00e1s haciendo.</p> <p>La relaci\u00f3n de composici\u00f3n es posible que ya la hayas tenido en cuenta si has definido clases que conten\u00edan (ten\u00edan como atributos) otros objetos en su interior, lo cual es bastante habitual. Por ejemplo, si escribes una clase donde alguno de sus atributos es un objeto de tipo <code>String</code> , ya se est\u00e1 produciendo una relaci\u00f3n de tipo composici\u00f3n (tu clase \"tiene\" un <code>String</code> , es decir, est\u00e1 compuesta por un objeto <code>String</code> y por algunos elementos m\u00e1s).</p> <p>La relaci\u00f3n de anidamiento (o anidaci\u00f3n) es quiz\u00e1 menos habitual, pues implica declarar unas clases dentro de otras (clases internas o anidadas). En algunos casos puede resultar \u00fatil para tener un nivel m\u00e1s de encapsulamiento (ocultamiento del estado de un objeto, de sus datos miembro o atributos) de manera que s\u00f3lo se puede cambiar mediante las operaciones (m\u00e9todos) definidas para ese objeto. Cada objeto est\u00e1 aislado del exterior de manera que se protegen los datos contra su modificaci\u00f3n por quien no tenga derecho a acceder a ellos, eliminando efectos secundarios y colaterales no deseados. Este modo de proceder permite que el usuario de una clase pueda obviar la implementaci\u00f3n de los m\u00e9todos y propiedades para concentrarse s\u00f3lo en c\u00f3mo usarlos. Por otro lado se evita que el usuario pueda cambiar su estado de manera imprevista e incontrolada, y oculta informaci\u00f3n (efecto que se consigue gracias a la encapsulaci\u00f3n: se evita la visibilidad de determinados miembros de una clase al resto del c\u00f3digo del programa para de ese modo comunicarse con los objetos de la clase \u00fanicamente a trav\u00e9s de su interfaz/m\u00e9todos).</p> <p>En el caso de la relaci\u00f3n de herencia tambi\u00e9n la has visto ya, pues seguro que has utilizado unas clases que derivaban de otras, sobre todo, en el caso de los objetos que forman parte de las interfaces gr\u00e1ficas. Lo m\u00e1s probable es que hayas tenido que declarar clases que derivaban de alg\u00fan componente gr\u00e1fico (<code>JFrame</code>, <code>JDialog</code>, etc.).</p> <p>Podr\u00eda decirse que tanto la composici\u00f3n como la anidaci\u00f3n son casos particulares de clientela, pues en realidad en todos esos casos una clase est\u00e1 haciendo uso de otra (al contener atributos que son objetos de la otra clase, al definir clases dentro de otras clases, al utilizar objetos en el paso de par\u00e1metros, al declarar variables locales utilizando otras clases, etc.).</p> <p>A lo largo de la unidad, ir\u00e1s viendo distintas posibilidades de implementaci\u00f3n de clases haciendo uso de todas estas relaciones, centr\u00e1ndonos especialmente en el caso de la herencia, que es la que permite establecer las relaciones m\u00e1s complejas.</p>"},{"location":"ud08/ud0801/#composicion","title":"Composici\u00f3n","text":"<p>Cuando en un sistema de informaci\u00f3n, una determinada entidad <code>A</code> contiene a otra <code>B</code> como una de sus partes, se suele decir que se est\u00e1 produciendo una relaci\u00f3n de composici\u00f3n. Es decir, el objeto de la clase <code>A</code> contiene a uno o varios objetos de la clase <code>B</code>.</p> <p>Por ejemplo, si describes una entidad <code>Pa\u00eds</code> compuesta por una serie de atributos, entre los cuales se encuentra una lista de comunidades aut\u00f3nomas, podr\u00edas decir que los objetos de la clase <code>Pa\u00eds</code> contienen varios objetos de la clase <code>ComunidadAutonoma</code>. Por otro lado, los objetos de la clase <code>ComunidadAutonoma</code> podr\u00edan contener como atributos objetos de la clase <code>Provincia</code>, la cual a su vez tambi\u00e9n podr\u00eda contener objetos de la clase <code>Municipio</code>.</p> <p>Como puedes observar, la composici\u00f3n puede encadenarse todas las veces que sea necesario hasta llegar a objetos b\u00e1sicos del lenguaje o hasta tipos primitivos que ya no contendr\u00e1n otros objetos en su interior. \u00c9sta es la forma m\u00e1s habitual de definir clases: mediante otras clases ya definidas anteriormente. Es una manera eficiente y sencilla de gestionar la reutilizaci\u00f3n de todo el c\u00f3digo ya escrito. Si se definen clases que describen entidades distinguibles y con funciones claramente definidas, podr\u00e1n utilizarse cada vez que haya que representar objetos similares dentro de otras clases.</p> <p>Anotaci\u00f3n</p> <p>La composici\u00f3n se da cuando una clase contiene alg\u00fan atributo que es una referencia a un objeto de otra clase.</p> <p>Una forma sencilla de plantearte si la relaci\u00f3n que existe entre dos clases A y B es de composici\u00f3n podr\u00eda ser mediante la expresi\u00f3n idiom\u00e1tica \"tiene un\": \"la clase A tiene uno o varios objetos de la clase B\", o visto de otro modo: \"Objetos de la clase B pueden formar parte de la clase A\". </p> Algunos ejemplos ... <ul> <li>Un coche tiene un motor y tiene cuatro ruedas.</li> <li>Una persona tiene un nombre, una fecha de nacimiento, una cuenta bancaria asociada para ingresar la n\u00f3mina, etc.</li> <li>Un cocodrilo bajo investigaci\u00f3n cient\u00edfica que tiene un n\u00famero de dientes determinado, una edad, unas coordenadas de ubicaci\u00f3n geogr\u00e1fica (medidas con GPS), etc.</li> </ul> Recuperando algunos ejemplos de clases que ya hemos utilizado anteriormente ... <ul> <li>Una clase <code>Rectangulo</code> podr\u00eda contener en su interior dos objetos de la clase <code>Punto</code> para almacenar los v\u00e9rtices inferior izquierdo y superior derecho.</li> <li>Una clase <code>Empleado</code> podr\u00eda contener en su interior un objeto de la clase <code>DNI</code> para almacenar su DNI/NIF, y otro objeto de la clase <code>CuentaBancaria</code> para guardar la cuenta en la que se realizan los ingresos en n\u00f3mina.</li> </ul> <p>\u00bfPodr\u00eda decirse que la relaci\u00f3n que existe entre la clase <code>Ave</code> y la clase <code>Loro</code> es una relaci\u00f3n de composici\u00f3n?</p> <p>No. Aunque claramente existe alg\u00fan tipo de relaci\u00f3n entre ambas, no parece que sea la de composici\u00f3n. No parece que se cumpla la expresi\u00f3n \"tiene un\": \"Un loro tiene un ave\". Se cumplir\u00eda m\u00e1s bien una expresi\u00f3n del tipo \"es un\": \"Un loro es un ave\". Algunos objetos que cumplir\u00edan la relaci\u00f3n de composici\u00f3n podr\u00edan ser <code>Pico</code> o <code>Alas</code>, pues \"un loro tiene un pico y dos alas\", del mismo modo que \"un ave tiene pico y dos alas\". Este tipo de relaci\u00f3n parece m\u00e1s de herencia (un loro es un tipo de ave).</p>"},{"location":"ud08/ud0801/#herencia","title":"Herencia","text":"<p>El mecanismo que permite crear clases bas\u00e1ndose en otras que ya existen es conocido como herencia. Como ya has visto en unidades anteriores, Java implementa la herencia mediante la utilizaci\u00f3n de la palabra reservada <code>extends</code>.</p> <p>El concepto de herencia es algo bastante simple y sin embargo muy potente: cuando se desea definir una nueva clase y ya existen clases que, de alguna manera, implementan parte de la funcionalidad que se necesita, es posible crear una nueva clase derivada de la que ya tienes. Al hacer esto se posibilita la reutilizaci\u00f3n de todos los atributos y m\u00e9todos de la clase que se ha utilizado como base (clase madre o superclase), sin la necesidad de tener que escribirlos de nuevo.</p> <p>Una subclase hereda todos los miembros de su clase madre (atributos, m\u00e9todos y clases internas). Los constructores no se heredan, aunque se pueden invocar desde la subclase.</p> Algunos ejemplos ... <ul> <li>Un coche es un veh\u00edculo (heredar\u00e1 atributos como la velocidad m\u00e1xima o m\u00e9todos como parar y arrancar).</li> <li>Un empleado es una persona (heredar\u00e1 atributos como el nombre o la fecha de nacimiento).</li> <li>Un rect\u00e1ngulo es una figura geom\u00e9trica en el plano (heredar\u00e1 m\u00e9todos como el c\u00e1lculo de la superficie o de su per\u00edmetro).</li> <li>Un cocodrilo es un reptil (heredar\u00e1 atributos como por ejemplo el n\u00famero de dientes).</li> </ul> <p>En este caso la expresi\u00f3n idiom\u00e1tica que puedes usar para plantearte si el tipo de relaci\u00f3n entre dos clases A y B es de herencia podr\u00eda ser \"es un\": \"la clase B es un tipo espec\u00edfico de la clase A\" (especializaci\u00f3n), o visto de otro modo: \"la clase A es un caso general de la clase B\" (generalizaci\u00f3n).</p> Recuperando algunos ejemplos de clases que ya hemos utilizado anteriormente ... <ul> <li>Una ventana en una aplicaci\u00f3n gr\u00e1fica puede ser una clase que herede de <code>JFrame</code> (componente <code>Swing</code>: <code>javax.swing.JFrame</code>), de esta manera esa clase ser\u00e1 un marco que dispondr\u00e1 de todos los m\u00e9todos y atributos de <code>JFrame</code> m\u00e1s aquellos que t\u00fa decidas incorporarle al rellenarlo de componentes gr\u00e1ficos.</li> <li>Una caja de di\u00e1logo puede ser un tipo de <code>JDialog</code> (otro componente <code>Swing</code>: <code>javax.swing.JDialog</code>).</li> </ul> <p>En Java, la clase <code>Object</code> (dentro del paquete <code>java.lang</code>) define e implementa el comportamiento com\u00fan a todas las clases (incluidas aquellas que t\u00fa escribas). Como recordar\u00e1s, ya se dijo que en Java cualquier clase deriva en \u00faltima instancia de la clase <code>Object</code>.</p> <p>Todas las clases tienen una clase madre, que a su vez tambi\u00e9n posee una superclase, y as\u00ed sucesivamente hasta llegar a la clase <code>Object</code> . De esta manera, se construye lo que habitualmente se conoce como una jerarqu\u00eda de clases, que en el caso de Java tendr\u00eda a la clase <code>Object</code> en la ra\u00edz.</p> <p>Anotaci\u00f3n</p> <p>Cuando escribas una clase en Java, puedes hacer que herede de una determinada clase madre (mediante el uso de <code>extends</code>) o bien no indicar ninguna herencia. En tal caso, aunque no indiques expl\u00edcitamente ning\u00fan tipo de herencia, el compilador asumir\u00e1 entonces de manera impl\u00edcita que tu clase hereda de la clase <code>Object</code>, que define e implementa el comportamiento com\u00fan a todas las clases.</p>"},{"location":"ud08/ud0801/#herencia-o-composicion","title":"\u00bfHerencia o composici\u00f3n?","text":"<p>Cuando escribas tus propias clases, debes intentar tener claro en qu\u00e9 casos utilizar la composici\u00f3n y cu\u00e1ndo la herencia:</p> <ul> <li>Composici\u00f3n: cuando una clase est\u00e1 formada por objetos de otras clases. En estos casos se incluyen objetos de esas clases, pero no necesariamente se comparten caracter\u00edsticas con ellos (no se heredan caracter\u00edsticas de esos objetos, sino que directamente se utilizar\u00e1n sus atributos y sus m\u00e9todos). Esos objetos incluidos no son m\u00e1s que atributos miembros de la clase que se est\u00e1 definiendo.</li> <li>Herencia: cuando una clase cumple todas las caracter\u00edsticas de otra. En estos casos la clase derivada es una especializaci\u00f3n (o particularizaci\u00f3n, extensi\u00f3n o restricci\u00f3n) de la clase base. Desde otro punto de vista se dir\u00eda que la clase base es una generalizaci\u00f3n de las clases derivadas.</li> </ul> Ejemplo <p>Imagina que dispones de una clase Punto (ya la has utilizado en otras ocasiones) y decides definir una nueva clase llamada C\u00edrculo. Dado que un punto tiene como atributos sus coordenadas en plano (x1, y1), decides que es buena idea aprovechar esa informaci\u00f3n e incorporarla en la clase Circulo que est\u00e1s escribiendo. Para ello utilizas la herencia, de manera que al derivar la clase C\u00edrculo de la clase Punto, tendr\u00e1s disponibles los atributos x1 e y1. Ahora solo faltar\u00eda a\u00f1adirle algunos atributos y m\u00e9todos m\u00e1s como por ejemplo el radio del c\u00edrculo, el c\u00e1lculo de su \u00e1rea y su per\u00edmetro, etc. </p> <p>En principio parece que la idea pueda funcionar pero es posible que m\u00e1s adelante, si contin\u00faas construyendo una jerarqu\u00eda de clases, observes que puedas llegar a conclusiones incongruentes al suponer que un c\u00edrculo es una especializaci\u00f3n de un punto (un tipo de punto). \u00bfTodas aquellas figuras que contengan uno o varios puntos deber\u00edan ser tipos de punto? \u00bfY si tienes varios puntos? \u00bfC\u00f3mo accedes a ellos? \u00bfUn rect\u00e1ngulo tambi\u00e9n tiene sentido que herede de un punto? No parece muy buena idea.</p> <p>Parece que en este caso habr\u00eda resultado mejor establecer una relaci\u00f3n de composici\u00f3n. Anal\u00edzalo detenidamente: \u00bfcu\u00e1l de estas dos situaciones te suena mejor?</p> <ol> <li>\"Un c\u00edrculo es un punto (su centro)\", y por tanto heredar\u00e1 las coordenadas x1 e y1 que tiene todo punto. Adem\u00e1s tendr\u00e1 otras caracter\u00edsticas espec\u00edficas como el radio o m\u00e9todos como el c\u00e1lculo de la longitud de su per\u00edmetro o de su \u00e1rea.</li> <li>\"Un c\u00edrculo tiene un punto (su centro)\", junto con algunos atributos m\u00e1s como por ejemplo el radio. Tambi\u00e9n tendr\u00e1 m\u00e9todos para el c\u00e1lculo de su \u00e1rea o de la longitud de su per\u00edmetro.</li> </ol> <p>Parece que en este caso la composici\u00f3n refleja con mayor fidelidad la relaci\u00f3n que existe entre ambas clases. Normalmente suele ser suficiente con plantearse las preguntas \"\u00bfB es un tipo de A?\" o \"\u00bfB contiene elementos de tipo A?\".</p>"},{"location":"ud08/ud0802/","title":"8.2 Composici\u00f3n","text":""},{"location":"ud08/ud0802/#sintaxis-de-la-composicion","title":"Sintaxis de la composici\u00f3n","text":"<p>Para indicar que una clase contiene objetos de otra clase no es necesaria ninguna sintaxis especial. Cada uno de esos objetos no es m\u00e1s que un atributo y, por tanto, debe ser declarado como tal:</p> Java<pre><code>class &lt;nombreClase&gt; {\n  [modificadores] &lt;NombreClase1&gt; nombreAtributo1;\n  [modificadores] &lt;NombreClase2&gt; nombreAtributo2;\n  &lt;NombreClase3&gt;[] listado;\n  ...    \n}\n</code></pre> <p>En unidades anteriores has trabajado con la clase <code>Punto</code>, que defin\u00eda las coordenadas de un punto en el plano, y con la clase <code>Rectangulo</code>, que defin\u00eda una figura de tipo rect\u00e1ngulo tambi\u00e9n en el plano a partir de dos de sus v\u00e9rtices (inferior izquierdo y superior derecho). Tal y como hemos formalizado ahora los tipos de relaciones entre clases, parece bastante claro que aqu\u00ed tendr\u00edas un caso de composici\u00f3n: \"un rect\u00e1ngulo contiene puntos\". Por tanto, podr\u00edas ahora redefinir los atributos de la clase <code>Rectangulo</code> (cuatro n\u00fameros reales) como dos objetos de tipo Punto:</p> Java<pre><code>class Rectangulo {\n  private Punto vertice1;\n  private Punto vertice2;\n  ...\n}\n</code></pre> <p>Ahora los m\u00e9todos de esta clase deber\u00e1n tener en cuenta que ya no hay cuatro atributos de tipo <code>double</code>, sino dos atributos de tipo <code>Punto</code> (cada uno de los cuales contendr\u00e1 en su interior dos atributos de tipo <code>double</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Intenta reescribir los siguientes los m\u00e9todos de la clase <code>Rectangulo</code> teniendo en cuenta ahora su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>):</p> <ul> <li> <p>M\u00e9todo <code>calcularSuperfice</code>, que calcula y devuelve el \u00e1rea de la superficie encerrada por la figura.</p> </li> <li> <p>M\u00e9todo <code>calcularPerimetro</code>, que calcula y devuelve la longitud del per\u00edmetro de la figura.</p> </li> </ul> <p>En ambos casos la interfaz no se ve modificada en absoluto (desde fuera su funcionamiento es el mismo), pero internamente deber\u00e1s tener en cuenta que ya no existen los atributos <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, de tipo <code>double</code>, sino los atributos <code>vertice1</code> y <code>vertice2</code> de tipo <code>Punto</code>.</p> Java<pre><code>package UD08._01_Ejemplo_2_1;\n\npublic class Punto {\nprivate double x;\nprivate double y;\n\npublic Punto(double x, double y) {\n    this.x = x;\n    this.y = y;\n}\n\npublic double getX() {\n    return x;\n}\n\npublic void setX(double x) {\n    this.x = x;\n}\n\npublic double getY() {\n    return y;\n}\n\npublic void setY(double y) {\n    this.y = y;\n}\n}\n</code></pre> Java<pre><code>public class Punto {\n    private double x;\n    private double y;\n\n    public Punto(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(double x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(double y) {\n        this.y = y;\n    } \n}\n</code></pre> <p>En la siguiente presentaci\u00f3n puedes observar detalladamente el proceso completo de elaboraci\u00f3n de la clase <code>Rectangulo</code> haciendo uso de la clase <code>Punto</code>:</p> <p>1) Objetos de tipo <code>Rectangulo</code> compuesto por objetos de tipo <code>Punto</code>:</p> <p></p> <p>2) Atributos de un objeto <code>Rectangulo</code> compuesto por objetos de tipo <code>Punto</code>:</p> <p></p> <p>3) Clase <code>Rectangulo</code>:</p> <p></p> <p>4) M\u00e9todo <code>calcularSuperficie</code>:</p> <p></p>"},{"location":"ud08/ud0802/#uso-de-la-composicion","title":"Uso de la composici\u00f3n","text":""},{"location":"ud08/ud0802/#preservacion-de-la-ocultacion","title":"Preservaci\u00f3n de la ocultaci\u00f3n","text":"<p>Como ya has observado, la relaci\u00f3n de composici\u00f3n no tiene m\u00e1s misterio a la hora de implementarse que simplemente declarar atributos de las clases que necesites dentro de la clase que est\u00e9s dise\u00f1ando.</p> <p>Ahora bien, cuando escribas clases que contienen objetos de otras clases (lo cual ser\u00e1 lo m\u00e1s habitual) deber\u00e1s tener un poco de precauci\u00f3n con aquellos m\u00e9todos que devuelvan informaci\u00f3n acerca de los atributos de la clase (m\u00e9todos \"consultores\" o de tipo get). </p> <p>Como ya viste en la unidad dedicada a la creaci\u00f3n de clases, lo normal suele ser declarar los atributos como privados (o protegidos, como veremos un poco m\u00e1s adelante) para ocultarlos a los posibles clientes de la clase (otros objetos que en el futuro har\u00e1n uso de la clase). Para que otros objetos puedan acceder a la informaci\u00f3n contenida en los atributos, o al menos a una parte de ella, deber\u00e1n hacerlo a trav\u00e9s de m\u00e9todos que sirvan de interfaz, de manera que s\u00f3lo se podr\u00e1 tener acceso a aquella informaci\u00f3n que el creador de la clase haya considerado oportuna. Del mismo modo, los atributos solamente ser\u00e1n modificados desde los m\u00e9todos de la clase, que decidir\u00e1n c\u00f3mo y bajo qu\u00e9 circunstancias deben realizarse esas modificaciones. Con esa metodolog\u00eda de acceso se ten\u00eda perfectamente separada la parte de manipulaci\u00f3n interna de los atributos de la interfaz con el exterior.</p> <p>Hasta ahora los m\u00e9todos de tipo get devolv\u00edan tipos primitivos, es decir, copias del contenido (a veces con alg\u00fan tipo de modificaci\u00f3n o de formato) que hab\u00eda almacenado en los atributos, pero los atributos segu\u00edan \"a salvo\" como elementos privados de la clase. Pero, a partir de este momento, al tener objetos dentro de las clases y no s\u00f3lo tipos primitivos, es posible que en un determinado momento interese devolver un objeto completo.</p> <p>Ahora bien, cuando vayas a devolver un objeto habr\u00e1s de obrar con mucha precauci\u00f3n. Si en un m\u00e9todo de la clase devuelves directamente un objeto que es un atributo, estar\u00e1s ofreciendo directamente una referencia a un objeto atributo que probablemente has definido como privado. \u00a1De esta forma est\u00e1s volviendo a hacer p\u00fablico un atributo que inicialmente era privado! </p> <p>Para evitar ese tipo de situaciones (ofrecer al exterior referencias a objetos privados) puedes optar por diversas alternativas, procurando siempre evitar la devoluci\u00f3n directa de un atributo que sea un objeto:</p> <ul> <li>Una opci\u00f3n podr\u00eda ser devolver siempre tipos primitivos.</li> <li>Dado que esto no siempre es posible, o como m\u00ednimo poco pr\u00e1ctico, otra posibilidad es crear un nuevo objeto que sea una copia del atributo que quieres devolver y utilizar ese objeto como valor de retorno. Es decir, crear una copia del objeto especialmente para devolverlo. De esta manera, el c\u00f3digo cliente de ese m\u00e9todo podr\u00e1 manipular a su antojo ese nuevo objeto, pues no ser\u00e1 una referencia al atributo original, sino un nuevo objeto con el mismo contenido.</li> </ul> <p>Por \u00faltimo, debes tener en cuenta que es posible que en algunos casos s\u00ed se necesite realmente la referencia al atributo original (algo muy habitual en el caso de atributos est\u00e1ticos). En tales casos, no habr\u00e1 problema en devolver directamente el atributo para que el c\u00f3digo llamante (cliente) haga el uso que estime oportuno de \u00e9l.</p> <p>A tener en cuenta</p> <p>Debes evitar por todos los medios la devoluci\u00f3n de un atributo que sea un objeto, pues estar\u00edas dando directamente una referencia al atributo, visible y manipulable desde fuera; salvo que se trate de un caso en el que deba ser as\u00ed.</p> <p>Para entender estas situaciones un poco mejor, podemos volver a la clase <code>Rectangulo</code> y observar sus nuevos m\u00e9todos de tipo get.</p> Revisa con cuidado el siguiente ejemplo <p>Dada la clase <code>Rectangulo</code>, escribe sus nuevos m\u00e9todos <code>getVertice1</code> y <code>getVertice2</code> para que devuelvan los v\u00e9rtices inferior izquierdo y superior derecho del rect\u00e1ngulo (objetos de tipo <code>Punto</code>), teniendo en cuenta su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>):</p> <p>Los m\u00e9todos de obtenci\u00f3n de v\u00e9rtices devolver\u00e1n objetos de la clase Punto:</p> Java<pre><code>public Punto getVertice1 (){\n    return vertice1;\n}\n\npublic Punto getVertice2 (){\n    return vertice2;\n}\n</code></pre> <p>Esto funcionar\u00eda perfectamente, pero deber\u00edas tener cuidado con este tipo de m\u00e9todos que devuelven directamente una referencia a un objeto atributo que probablemente has definido como privado. Est\u00e1s de alguna manera haciendo p\u00fablico un atributo que fue declarado como privado.</p> <p>Para evitar que esto suceda bastar\u00eda con crear un nuevo objeto que fuera una copia del atributo que se desea devolver (en este caso un objeto de la clase <code>Punto</code>).</p> <p>Aqu\u00ed tienes la soluci\u00f3n para la nueva clase <code>Rectangulo</code>:</p> Java<pre><code>class Rectangulo {\n    private Punto vertice1;\n    private Punto vertice2;\n\n    public double calcularSuperficie() {\n        double area, base, altura; // Variables locales\n        base = vertice2.getX() - vertice1.getX(); // Antes era x2 - x1\n        altura = vertice2.getY() - vertice1.getY(); // Antes era y2 - y1\n        area = base * altura;\n        return area;\n    }\n\n    public double CalcularPerimetro() {\n        double perimetro, base, altura; // Variables locales\n        base = vertice2.getX() - vertice1.getX(); // Antes era x2 - x1\n        altura = vertice2.getY() - vertice1.getY(); // Antes era y2 - y1\n        perimetro = 2 * base + 2 * altura;\n        return perimetro;\n    }\n\n    /*\n    * As\u00ed no!\n    *\n    *public Punto getVertice1mal() {\n    *    return vertice1;\n    *}\n    *\n    *public Punto getVertice2mal() {\n    *    return vertice2;\n    *}  \n    */\n\n    //Mejor de este modo\n    public Punto getVertice1() {\n        // Creaci\u00f3n de un nuevo punto extrayendo sus atributos\n        double x, y;\n        Punto p;\n        x = this.vertice1.getX();\n        y = this.vertice1.getY();\n        p = new Punto(x, y);\n        return p;\n    }\n\n    // O mejor as\u00ed:\n    public Punto getVertice2() {\n        // Utilizando el constructor copia de Punto (si es que est\u00e1 definido)\n        // Punto p;\n        // p = new Punto(this.vertice2); \n        // return p;\n\n        // o m\u00e1s corto:\n        // Uso del constructor copia\n        return new Punto(this.vertice2);\n    }\n\n    public Rectangulo(Punto vertice1, Punto vertice2) {\n        this.vertice1 = vertice1;\n        this.vertice2 = vertice2;\n    }\n\n    public static void main(String[] args) {\n        Punto puntoA = new Punto(0, 0);\n        Punto puntoB = new Punto(5, 5);\n\n        Rectangulo rectA = new Rectangulo(puntoA, puntoB);\n        System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n\n        puntoA.setX(4);\n        puntoA.setY(4);\n\n        Rectangulo rectB = new Rectangulo(puntoA, puntoB);\n        System.out.println(\"Creo un nuevo rectangulo, pero cambia el Per\u00edmetro del anterior\");\n        System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n        System.out.println(\"Per\u00edmetro del rectanculo B: \" + rectB.CalcularPerimetro());//4\n    }\n}\n</code></pre> <p>De esta manera, se devuelve un punto totalmente nuevo que podr\u00e1 ser manipulado sin ning\u00fan temor por parte del c\u00f3digo cliente de la clase pues es una copia para \u00e9l.</p>"},{"location":"ud08/ud0802/#llamadas-a-constructores","title":"Llamadas a constructores","text":"<p>Otro factor que debes considerar, a la hora de escribir clases que contengan como atributos objetos de otras clases, es su comportamiento a la hora de instanciarse. Durante el proceso de creaci\u00f3n de un objeto (constructor) de la clase contenedora habr\u00e1 que tener en cuenta tambi\u00e9n la creaci\u00f3n (llamadas a constructores) de aquellos objetos que son contenidos.</p> <p>A tener en cuenta</p> <p>El constructor de la clase contenedora debe invocar a los constructores de las clases de los objetos contenidos.</p> <p>En este caso hay que tener cuidado con las referencias a objetos que se pasan como par\u00e1metros para rellenar el contenido de los atributos. Es conveniente hacer una copia de esos objetos y utilizar esas copias para los atributos pues si se utiliza la referencia que se ha pasado como par\u00e1metro, el c\u00f3digo cliente de la clase podr\u00eda tener acceso a ella sin necesidad de pasar por la interfaz de la clase (volver\u00edamos a dejar abierta una puerta p\u00fablica a algo que quiz\u00e1 sea privado).</p> <p>Adem\u00e1s, si el objeto par\u00e1metro que se pas\u00f3 al constructor formaba parte de otro objeto, esto podr\u00eda ocasionar un desagradable efecto colateral si esos objetos son modificados en el futuro desde el c\u00f3digo cliente de la clase, ya que no sabes de d\u00f3nde provienen esos objetos, si fueron creados especialmente para ser usados por el nuevo objeto creado o si pertenecen a otro objeto que podr\u00eda modificarlos m\u00e1s tarde. Es decir, correr\u00edas el riesgo de estar \"compartiendo\" esos objetos con otras partes del c\u00f3digo, sin ning\u00fan tipo de control de acceso y con las nefastas consecuencias que eso podr\u00eda tener: cualquier cambio de ese objeto afectar\u00eda a partes del programa supuestamente independientes, que entienden ese objeto como suyo.</p> <p>A tener en cuenta</p> <p>En el fondo los objetos no son m\u00e1s que variables de tipo referencia a la zona de memoria en la que se encuentra toda la informaci\u00f3n del objeto en s\u00ed mismo. Esto es, puedes tener un \u00fanico objeto y m\u00faltiples referencias a \u00e9l. Pero s\u00f3lo se trata de un objeto, y cualquier modificaci\u00f3n desde una de sus referencias afectar\u00eda a todas las dem\u00e1s, pues estamos hablando del mismo objeto.</p> <p>Recuerda tambi\u00e9n que s\u00f3lo se crean objetos cuando se llama a un constructor (uso de new). Si realizas asignaciones o pasos de par\u00e1metros, no se est\u00e1n copiando o pasando copias de los objetos, sino simplemente de las referencias, y por tanto se tratar\u00e1 siempre del mismo objeto. </p> <p>Se trata de un efecto similar al que suced\u00eda en los m\u00e9todos de tipo get, pero en este caso en sentido contrario (en lugar de que nuestra clase \"regale\" al exterior uno de sus atributos objeto mediante una referencia, en esta ocasi\u00f3n se \"adue\u00f1a\" de un par\u00e1metro objeto que probablemente pertenezca a otro objeto y que es posible que el futuro haga uso de \u00e9l).</p> <p>Para entender mejor estos posibles efectos podemos continuar con el ejemplo de la clase <code>Rectangulo</code> que contiene en su interior dos objetos de la clase <code>Punto</code>. En los constructores del rect\u00e1ngulo habr\u00e1 que incluir todo lo necesario para crear dos instancias de la clase <code>Punto</code> evitando las referencias a par\u00e1metros (haciendo copias).</p> Revisa con cuidado el siguiente ejemplo <p>Intenta rescribir los constructores de la clase <code>Rectangulo</code> teniendo en cuenta ahora su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>): 1) Un constructor sin par\u00e1metros (para sustituir al constructor por defecto) que haga que los valores iniciales de las esquinas del rect\u00e1ngulo sean (0,0) y (1,1). 2) Un constructor con cuatro par\u00e1metros, <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, que cree un rect\u00e1ngulo con los v\u00e9rtices (<code>x1</code>, <code>y1</code>) y (<code>x2</code>, <code>y2</code>). 3) Un constructor con dos par\u00e1metros, <code>punto1</code>, <code>punto2</code>, que rellene los valores iniciales de los atributos del rect\u00e1ngulo con los valores proporcionados a trav\u00e9s de los par\u00e1metros. 4) Un constructor con dos par\u00e1metros, <code>base</code> y <code>altura</code>, que cree un rect\u00e1ngulo donde el v\u00e9rtice inferior derecho est\u00e9 ubicado en la posici\u00f3n (0,0) y que tenga una base y una altura tal y como indican los dos par\u00e1metros proporcionados. 5) Un constructor copia.</p> <p>POSIBLE SOLUCI\u00d3N</p> <p>Durante el proceso de creaci\u00f3n de un objeto (constructor) de la clase contenedora (en este caso <code>Rectangulo</code>) hay que tener en cuenta tambi\u00e9n la creaci\u00f3n (llamada a constructores) de aquellos objetos que son contenidos (en este caso objetos de la clase Punto). 1) En el caso del primer constructor, habr\u00e1 que crear dos puntos con las coordenadas (0,0) y (1,1) y asignarlos a los atributos correspondientes (<code>vertice1</code> y <code>vertice2</code>):</p> Java<pre><code>public Rectangulo (){\n    this.vertice1 = new Punto (0,0);\n    this.vertice2 = new Punto (1,1);\n}\n</code></pre> <p>2) Para el segundo constructor habr\u00e1 que crear dos puntos con las coordenadas x1, y1, x2, y2 que han sido pasadas como par\u00e1metros:</p> Java<pre><code>public Rectangulo (double x1, double y1, double x2, double y2){\n    this.vertice1 = new Punto (x1, y1);\n    this.vertice2 = new Punto (x2, y2);\n}\n</code></pre> <p>3) En el caso del tercer constructor puedes utilizar directamente los dos puntos que se pasan como par\u00e1metros para construir los v\u00e9rtices del rect\u00e1ngulo.</p> Java<pre><code>public Rectangulo (Punto vertice1, Punto vertice2) {\n    this.vertice1 = vertice1;\n    this.vertice2 = vertice2;\n}\n</code></pre> <p>Ahora bien, esto podr\u00eda ocasionar un efecto colateral no deseado si esos objetos de tipo Punto son modificados en el futuro desde el c\u00f3digo cliente del constructor (no sabes si esos puntos fueron creados especialmente para ser usados por el rect\u00e1ngulo o si pertenecen a otro objeto que podr\u00eda modificarlos m\u00e1s tarde).</p> <p>Por tanto, para este caso quiz\u00e1 fuera recomendable crear dos nuevos puntos a imagen y semejanza de los puntos que se han pasado como par\u00e1metros. Para ello tendr\u00edas dos opciones:</p> <p>a) Llamar al constructor de la clase Punto con los valores de los atributos (x, y).</p> Java<pre><code>public Rectangulo(Punto vertice1, Punto vertice2) {\n    this.vertice1 = new Punto(vertice1.getX(), vertice1.getY());\n    this.vertice2 = new Punto(vertice2.getX(), vertice2.getY());\n}\n</code></pre> <p>b) Llamar al constructor copia de la clase Punto, si es que se dispone de \u00e9l.</p> Java<pre><code>public Rectangulo (Punto vertice1, Punto vertice2) {\n    this.vertice1 = new Punto (vertice1);\n    this.vertice2 = new Punto (vertice2);\n}\n</code></pre> <p>4) Para el cuarto caso, el caso del constructor que recibe como par\u00e1metros la base y la altura, habr\u00e1 que crear sendos v\u00e9rtices con valores (0,0) y (0 + base, 0 + altura), o lo que es lo mismo: (0,0) y (base, altura).</p> Java<pre><code>public Rectangulo(double base, double altura) {\n    this.vertice1 = new Punto(0,0);\n    this.vertice2 = new Punto(base, altura);\n}\n</code></pre> <p>5) Quedar\u00eda finalmente por implementar el constructor copia, quinto caso:</p> Java<pre><code>public Rectangulo (Rectangulo r) {\n    this.vertice1 = new Punto (r.getVertice1());\n    this.vertice2 = new Punto (r.getVertice2());\n}\n</code></pre> <p>En este caso nuevamente volvemos a clonar los atributos <code>vertice1</code> y <code>vertice2</code> del objeto <code>r</code> que se ha pasado como par\u00e1metro para evitar tener que compartir esos atributos en los dos rect\u00e1ngulos. As\u00ed ahora el m\u00e9todo main que comprueba la clase Rectangulo funciona correctamente:</p> Java<pre><code>public static void main(String[] args) {\n    Punto puntoA = new Punto(0, 0);\n    Punto puntoB = new Punto(5, 5);\n\n    Rectangulo rectA = new Rectangulo(puntoA, puntoB);\n    System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n\n    puntoA.setX(4);\n    puntoA.setY(4);\n\n    Rectangulo rectB = new Rectangulo(puntoA, puntoB);\n    System.out.println(\"Creo un nuevo rectangulo, pero cambia el Per\u00edmetro del anterior\");\n    System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n    System.out.println(\"Per\u00edmetro del rectanculo B: \" + rectB.CalcularPerimetro());//4\n}\n</code></pre>"},{"location":"ud08/ud0802/#clases-anidadas-o-internas","title":"Clases anidadas o internas","text":"<p>En algunos lenguajes, es posible definir una clase dentro de otra clase (clases internas):</p> Java<pre><code>class ClaseContenedora {\n  // Cuerpo de la clase\n  ...\n  class ClaseInterna {\n    // Cuerpo de la clase interna\n    ...\n  }\n}\n</code></pre> <p>Se pueden distinguir varios tipos de clases internas:</p> <ul> <li>Clases internas est\u00e1ticas (o clases anidadas), declaradas con el modificador <code>static</code>.</li> <li>Clases internas miembro, conocidas habitualmente como clases internas. Declaradas al m\u00e1ximo nivel de la clase contenedora y no est\u00e1ticas.</li> <li>Clases internas locales, que se declaran en el interior de un bloque de c\u00f3digo (normalmente dentro de un m\u00e9todo).</li> <li>Clases an\u00f3nimas, similares a las internas locales, pero sin nombre (s\u00f3lo existir\u00e1 un objeto de ellas y, al no tener nombre, no tendr\u00e1n constructores). Se suelen usar en la gesti\u00f3n de eventos en los interfaces gr\u00e1ficos.</li> <li>Aqu\u00ed tienes algunos ejemplos:</li> </ul> Java<pre><code>class ClaseContenedora {\n  ...\n  static class ClaseAnidadaEstatica {\n     ...\n  }\n  class ClaseInterna {\n    ...\n  }\n}\n</code></pre> <p>Las clases anidadas, como miembros de una clase que son (miembros de <code>ClaseContenedora</code>), pueden ser declaradas con los modificadores <code>public</code>, <code>protected</code>, <code>private</code> o de <code>paquete</code>, como el resto de miembros.</p> <p>Las clases internas (no est\u00e1ticas) tienen acceso a otros miembros de la clase dentro de la que est\u00e1 definida aunque sean privados (se trata en cierto modo de un miembro m\u00e1s de la clase), mientras que las anidadas (est\u00e1ticas) no.</p> <p>Las clases internas se utilizan en algunos casos para:</p> <ul> <li>Agrupar clases que s\u00f3lo tiene sentido que existan en el entorno de la clase en la que han sido definidas, de manera que se oculta su existencia al resto del c\u00f3digo.</li> <li>Incrementar el nivel de encapsulaci\u00f3n y ocultamiento.</li> <li>Proporcionar un c\u00f3digo fuente m\u00e1s legible y f\u00e1cil de mantener (el c\u00f3digo de las clases internas y anidadas est\u00e1 m\u00e1s cerca de donde es usado).</li> </ul> <p>En Java es posible definir clases internas y anidadas, permitiendo todas esas posibilidades. Aunque para los ejemplos con los que vas a trabajar no las vas a necesitar por ahora. </p>"},{"location":"ud08/ud0803/","title":"8.3 Herencia","text":"<p>Como ya has estudiado, la herencia es el mecanismo que permite definir una nueva clase a partir de otra, pudiendo a\u00f1adir nuevas caracter\u00edsticas, sin tener que volver a escribir todo el c\u00f3digo de la clase base.</p> <p>La clase de la que se hereda suele ser llamada clase base, clase madre o superclase (de la que hereda otra clase. Se heredar\u00e1n todas aquellas caracter\u00edsticas que la clase madre permita). A la clase que hereda se le suele llamar clase hija, clase derivada o subclase (que hereda de otra clase. Se heredan todas aquellas caracter\u00edsticas que la clase madre permita).</p> <p>Una clase derivada puede ser a su vez clase madre de otra que herede de ella y as\u00ed sucesivamente dando lugar a una jerarqu\u00eda de clases, excepto aquellas que est\u00e9n en la parte de arriba de la jerarqu\u00eda (s\u00f3lo ser\u00e1n clases madre) o en la parte de abajo (s\u00f3lo ser\u00e1n clases hijas). </p> <p>Una clase hija no tiene acceso a los miembros privados de su clase madre, tan solo a los p\u00fablicos (como cualquier parte del c\u00f3digo tendr\u00eda) y a los protegidos (a los que s\u00f3lo tienen acceso las clases derivadas y las del mismo paquete). Aquellos miembros que sean privados en la clase base tambi\u00e9n habr\u00e1n sido heredados, pero el acceso a ellos estar\u00e1 restringido al propio funcionamiento de la superclase y s\u00f3lo se podr\u00e1 acceder a ellos si la superclase ha dejado alg\u00fan medio indirecto para hacerlo (por ejemplo a trav\u00e9s de alg\u00fan m\u00e9todo). </p> <p>Todos los miembros de la superclase, tanto atributos como m\u00e9todos, son heredados por la subclase. Algunos de estos miembros heredados podr\u00e1n ser redefinidos o sobrescritos (overriden) y tambi\u00e9n podr\u00e1n a\u00f1adirse nuevos miembros. De alguna manera podr\u00eda decirse que est\u00e1s \"ampliando\" la clase base con caracter\u00edsticas adicionales o modificando algunas de ellas (proceso de especializaci\u00f3n).</p> <p>A tener en cuenta</p> <p>Una clase derivada extiende la funcionalidad de la clase base sin tener que volver a escribir el c\u00f3digo de la clase base.</p>"},{"location":"ud08/ud0803/#sintaxis-de-la-herencia","title":"Sintaxis de la herencia","text":"<p>En Java la herencia se indica mediante la palabra reservada <code>extends</code>:</p> Java<pre><code>[modificador] class ClasePadre {\n  // Cuerpo de la clase\n  ...\n}\n\n[modificador] class ClaseHija extends ClasePadre {\n  // Cuerpo de la clase\n  ...\n}\n</code></pre> <p>Imagina que tienes una clase <code>Persona</code> que contiene atributos como <code>nombre</code>, <code>apellidos</code> y <code>fecha de nacimiento</code>:</p> Java<pre><code>public class Persona {\n  String nombre;\n  String apellidos;\n  LocalDate fechaNacim;\n  ...\n}\n</code></pre> <p>Es posible que, m\u00e1s adelante, necesites una clase <code>Alumno</code> que compartir\u00e1 esos atributos (dado que todo alumno es una persona, pero con algunas caracter\u00edsticas espec\u00edficas que lo especializan). En tal caso tendr\u00edas la posibilidad de crear una clase <code>Alumno</code> que repitiera todos esos atributos o bien heredar de la clase <code>Persona</code>:</p> Java<pre><code>public class Alumno extends Persona {\n  String grupo;\n  double notaMedia;\n  ...\n}\n</code></pre> <p>A partir de ahora, un objeto de la clase <code>Alumno</code> contendr\u00e1 los atributos <code>grupo</code> y <code>notaMedia</code> (propios de la clase <code>Alumno</code>), pero tambi\u00e9n <code>nombre</code>, <code>apellidos</code> y <code>fechaNacim</code> (propios de su clase base <code>Persona</code> y que por tanto ha heredado).</p> Revisa con cuidado el siguiente ejemplo <p>Imagina que tambi\u00e9n necesitas una clase Profesor, que contar\u00e1 con atributos como nombre, apellidos, fecha de nacimiento, salario y especialidad. \u00bfC\u00f3mo crear\u00edas esa nueva clase y qu\u00e9 atributos le a\u00f1adir\u00edas? Est\u00e1 claro que un Profesor es otra especializaci\u00f3n de Persona, al igual que lo era Alumno, as\u00ed que podr\u00edas crear otra clase derivada de Persona y as\u00ed aprovechar los atributos gen\u00e9ricos (nombre, apellidos, fecha de nacimiento) que posee todo objeto de tipo Persona. Tan solo faltar\u00eda a\u00f1adirle sus atributos espec\u00edficos (salario y especialidad):</p> Java<pre><code>public class Profesor extends Persona {\n    String especialidad;\n    double salario;\n    ...\n}\n</code></pre>"},{"location":"ud08/ud0803/#acceso-a-miembros-heredados","title":"Acceso a miembros heredados","text":"<p>Como ya has visto anteriormente, no es posible acceder a miembros privados de una superclase. Para poder acceder a ellos podr\u00edas pensar en hacerlos p\u00fablicos, pero entonces estar\u00edas dando la opci\u00f3n de acceder a ellos a cualquier objeto externo y es probable que tampoco sea eso lo deseable. Para ello se invent\u00f3 el modificador protected (protegido) que permite el acceso desde clases heredadas, pero no desde fuera de las clases (estrictamente hablando, desde fuera del paquete), que ser\u00edan como miembros privados.</p> <p>En la unidad dedicada a la utilizaci\u00f3n de clases ya estudiaste los posibles modificadores de acceso que pod\u00eda tener un miembro: sin modificador (acceso de paquete), p\u00fablico, privado o protegido.</p> <p>Aqu\u00ed tienes de nuevo el resumen:</p> modificador Misma clase Mismo paquete Subclase Otro paquete <code>public</code> \u2714 \u2714 \u2714 \u2714 <code>protected</code> \u2714 \u2714 \u2714 \u274c Sin modificador (<code>package</code>) \u2714 \u2714 \u274c \u274c <code>private</code> \u2714 \u274c \u274c \u274c <p>Los modificadores de acceso son excluyentes</p> <p>S\u00f3lo se puede utilizar uno de ellos en la declaraci\u00f3n de un atributo.</p> <p>Si en el ejemplo anterior de la clase <code>Persona</code> se hubieran definido sus atributos como private:</p> Java<pre><code>public class Persona {\n  private String nombre;\n  private String apellidos;\n  ...\n}\n</code></pre> <p>Al definir la clase <code>Alumno</code> como heredera de <code>Persona</code>, no habr\u00edas tenido acceso a esos atributos, pudiendo ocasionar un grave problema de operatividad al intentar manipular esa informaci\u00f3n. Por tanto, en estos casos lo m\u00e1s recomendable habr\u00eda sido declarar esos atributos como <code>protected</code> o bien sin modificador (para que tambi\u00e9n tengan acceso a ellos otras clases del mismo paquete, si es que se considera oportuno):</p> Java<pre><code>public class Persona {\n  protected String nombre;\n  protected String apellidos;\n  ...\n}\n</code></pre> <p>privacidad de atributos</p> <p>S\u00f3lo en aquellos casos en los que se desea expl\u00edcitamente que un miembro de una clase no pueda ser accesible desde una clase derivada deber\u00eda utilizarse el modificador private. En el resto de casos es recomendable utilizar protected, o bien no indicar modificador (acceso a nivel de paquete).</p> Revisa con cuidado el siguiente ejemplo <p>Reescribe las clases <code>Alumno</code> y <code>Profesor</code> utilizando el modificador protected para sus atributos del mismo modo que se ha hecho para su superclase <code>Persona</code>.</p> <p>1) Clase <code>Alumno</code>. Se trata simplemente de a\u00f1adir el modificador de acceso protected a los nuevos atributos que a\u00f1ade la clase. Java<pre><code>public class Alumno extends Persona {\n    protected String grupo;\n    protected double notaMedia;\n    ...\n}\n</code></pre></p> <p>2) Clase <code>Profesor</code>. Exactamente igual que en la clase <code>Alumno</code>. Java<pre><code>public class Profesor extends Persona {\n    protected String especialidad;\n    protected double salario;\n    ...\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#utilizacion-de-miembros-heredados","title":"Utilizaci\u00f3n de miembros heredados","text":""},{"location":"ud08/ud0803/#atributos","title":"Atributos","text":"<p>Los atributos heredados por una clase son, a efectos pr\u00e1cticos, iguales que aquellos que sean definidos espec\u00edficamente en la nueva clase derivada.</p> <p>En el ejemplo anterior la clase <code>Persona</code> dispon\u00eda de tres atributos y la clase <code>Alumno</code>, que heredaba de ella, a\u00f1ad\u00eda dos atributos m\u00e1s. Desde un punto de vista funcional podr\u00edas considerar que la clase <code>Alumno</code> tiene cinco atributos: tres por ser <code>Persona</code> (nombre, apellidos, fecha de nacimiento) y otros dos m\u00e1s por ser <code>Alumno</code> (grupo y nota media).</p> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases Alumno y Profesor que has utilizado anteriormente, implementa m\u00e9todos get y set en las clases Alumno y Profesor para trabajar con sus cinco atributos (tres heredados m\u00e1s dos espec\u00edficos).</p> <p>POSIBLE SOLUCI\u00d3N</p> <p>1) Clase <code>Alumno</code>. Se trata de heredar de la clase Persona y por tanto utilizar con normalidad sus atributos heredados como si pertenecieran a la propia clase (de hecho se puede considerar que le pertenecen, dado que los ha heredado). Java<pre><code>import java.time.LocalDate;\n\npublic class Alumno extends Persona {\n\n    protected String grupo;\n    protected double notaMedia;\n\n    // M\u00e9todo getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    public String getGrupo() {\n        return grupo;\n    }\n\n    public double getNotaMedia() {\n        return notaMedia;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public void setGrupo(String grupo) {\n        this.grupo = grupo;\n    }\n\n    public void setNotaMedia(double notaMedia) {\n        this.notaMedia = notaMedia;\n    }\n}\n</code></pre></p> <p>Si te fijas, puedes utilizar sin problema la referencia <code>this</code> a la propia clase con esos atributos heredados, pues pertenecen a la clase: <code>this.nombre</code>, <code>this.apellidos</code>, etc.</p> <p>2) Clase <code>Profesor</code>. Seguimos exactamente el mismo procedimiento que con la clase Alumno. Java<pre><code>import java.time.LocalDate;\n\npublic class Profesor extends Persona {\n    String especialidad;\n    double salario;\n\n    // M\u00e9todos getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    public String getEspecialidad() {\n        return especialidad;\n    }\n\n    public double getSalario() {\n        return salario;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public void setSalario(double salario) {\n        this.salario = salario;\n    }\n\n    public void setESpecialidad(String especialidad) {\n        this.especialidad = especialidad;\n    }\n}\n</code></pre></p> <p>Una conclusi\u00f3n que puedes extraer de este c\u00f3digo es que has tenido que escribir los m\u00e9todos <code>get</code> y <code>set</code> para los tres atributos heredados, pero \u00bfno habr\u00eda sido posible definir esos seis m\u00e9todos en la clase base y as\u00ed estas dos clases derivadas hubieran tambi\u00e9n heredado esos m\u00e9todos? La respuesta es afirmativa y de hecho es como lo vas a hacer a partir de ahora. De esa manera te habr\u00edas evitado tener que escribir seis m\u00e9todos en la clase <code>Alumno</code> y otros seis en la clase <code>Profesor</code>. </p> <p>As\u00ed que, recuerda! se pueden heredar tanto los atributos como los m\u00e9todos.</p> <p>Aqu\u00ed tienes un ejemplo de c\u00f3mo podr\u00edas haber definido la clase Persona para que luego se hubieran podido heredar de ella sus m\u00e9todos (y no s\u00f3lo sus atributos):</p> <p>SOLUCI\u00d3N IMPLEMENTADA CORRECTAMENTE (I) Java<pre><code>import java.time.LocalDate;\n\npublic class Persona {\n    protected String nombre;\n    protected String apellidos;\n    protected LocalDate fechaNacimiento;\n\n    // M\u00e9todos getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n}\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n        }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#metodos","title":"M\u00e9todos","text":"<p>Del mismo modo que se heredan los atributos, tambi\u00e9n se heredan los m\u00e9todos, convirti\u00e9ndose a partir de ese momento en otros m\u00e9todos m\u00e1s de la clase derivada, junto a los que hayan sido definidos espec\u00edficamente.</p> <p>En el ejemplo de la clase <code>Persona</code>, si dispusi\u00e9ramos de m\u00e9todos get y set para cada uno de sus tres atributos (<code>nombre</code>, <code>apellidos</code>, <code>fechaNacim</code>), tendr\u00edas seis m\u00e9todos que podr\u00edan ser heredados por sus clases derivadas. Podr\u00edas decir entonces que la clase Alumno, derivada de Persona, tiene diez m\u00e9todos:</p> <ul> <li>Seis por ser Persona (<code>getNombre</code>, <code>getApellidos</code>, <code>getFechaNacim</code>, <code>setNombre</code>, <code>setApellidos</code>, <code>setFechaNacim</code>).</li> <li>Oros cuatro m\u00e1s por ser Alumno (<code>getGrupo</code>, <code>setGrupo</code>, <code>getNotaMedia</code>, <code>setNotaMedia</code>).</li> </ul> <p>Sin embargo, s\u00f3lo tendr\u00edas que definir esos cuatro \u00faltimos (los espec\u00edficos) pues los gen\u00e9ricos ya los has heredado de la superclase.</p> Revisa con cuidado el siguiente ejemplo Java<pre><code>public class Profesor extends Persona {\n\nString especialidad;\ndouble salario;\n\n// M\u00e9todos getXXXXX\npublic String getEspecialidad() {\n    return especialidad;\n}\n\npublic double getSalario() {\n    return salario;\n}\n\n// M\u00e9todos setXXXXX\npublic void setSalario(double salario) {\n    this.salario = salario;\n}\n\npublic void setESpecialidad(String especialidad) {\n    this.especialidad = especialidad;\n}\n}    \n</code></pre>"},{"location":"ud08/ud0803/#redefinicion-de-metodos-heredados","title":"Redefinici\u00f3n de m\u00e9todos heredados","text":"<p>Una clase puede redefinir algunos de los m\u00e9todos que ha heredado de su clase base. El nuevo m\u00e9todo (especializado) sustituye al heredado. Esto se conoce como sobrescritura de m\u00e9todos.</p> <p>En cualquier caso, aunque un m\u00e9todo sea sobrescrito o redefinido, a\u00fan es posible acceder a \u00e9l a trav\u00e9s de la referencia super, aunque s\u00f3lo se podr\u00e1 acceder a m\u00e9todos de la clase madre y no a m\u00e9todos de clases superiores en la jerarqu\u00eda de herencia.</p> <p>Los m\u00e9todos redefinidos pueden ampliar su accesibilidad con respecto a la que ofrezca el m\u00e9todo original de la superclase, pero nunca restringirla. Por ejemplo, si un m\u00e9todo es declarado como protected o de paquete en la clase base, podr\u00eda ser redefinido como public en una clase derivada. Los m\u00e9todos est\u00e1ticos o de clase no pueden ser sobrescritos. Los originales de la clase base permanecen inalterables a trav\u00e9s de toda la jerarqu\u00eda de herencia.</p> <p>En el ejemplo de la clase <code>Alumno</code>, podr\u00edan redefinirse algunos de los m\u00e9todos heredados. Por ejemplo, imagina que el m\u00e9todo <code>getApellidos</code> devuelva la cadena \"Alumno: \" junto con los apellidos del alumno. En tal caso habr\u00eda que rescribir ese m\u00e9todo para realizara esa modificaci\u00f3n:</p> Ejemplo: m\u00e9todo obtener atributo apellidos de <code>Alumno</code> Java<pre><code>public String getApellidos () {\n    return \"Alumno: \" + apellidos;\n}\n</code></pre> <p>Cuando sobrescribas un m\u00e9todo heredado en Java puedes (no es necesario) incluir la anotaci\u00f3n <code>@Override</code>. Esto indicar\u00e1 al compilador que tu intenci\u00f3n es sobrescribir el m\u00e9todo de la clase madre. De este modo, si te equivocas (por ejemplo, al escribir el nombre del m\u00e9todo) y no lo est\u00e1s realmente sobrescribiendo, el compilador producir\u00e1 un error y as\u00ed podr\u00e1s darte cuenta del fallo. En el caso del ejemplo anterior quedar\u00eda:</p> Ejemplo: m\u00e9todo obtener atributo apellidos de <code>Alumno</code> sobreescrito Java<pre><code>@Override\npublic String getApellidos () {\n    return \"Alumno: \" + apellidos;\n}\n</code></pre> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, redefine el m\u00e9todo <code>getNombre</code> para que devuelva la cadena \"Alumno: \", junto con el nombre del alumno, si se trata de un objeto de la clase Alumno o bien \"Profesor: \", junto con el nombre del profesor, si se trata de un objeto de la clase Profesor.</p> <p>1) Clase <code>Alumno</code>. Al heredar de la clase Persona tan solo es necesario escribir m\u00e9todos para los nuevos atributos (m\u00e9todos especializados de acceso a los atributos especializados), pues los m\u00e9todos gen\u00e9ricos (de acceso a los atributos gen\u00e9ricos) ya forman parte de la clase al haberlos heredado. Esos son los m\u00e9todos que se implementaron en el ejercicio anterior (<code>getGrupo</code>, <code>setGrupo</code>, etc.).</p> <p>Ahora bien, hay que escribir otro m\u00e9todo m\u00e1s, pues tienes que redefinir el m\u00e9todo <code>getNombre</code> para que tenga un comportamiento un poco diferente al <code>getNombre</code> que se hereda de la clase base <code>Persona</code>: Java<pre><code>// M\u00e9todo getNombre\n@Override\npublic String getNombre (){\n    return \"Alumno: \" + this.nombre;\n}\n</code></pre></p> <p>En este caso podr\u00eda decirse que se \"renuncia\" al m\u00e9todo heredado para redefinirlo con un comportamiento m\u00e1s especializado y acorde con la clase derivada.</p> <p>2) Clase <code>Profesor</code>. Seguimos exactamente el mismo procedimiento que con la clase Alumno (redefinici\u00f3n del m\u00e9todo <code>getNombre</code>). Java<pre><code>// M\u00e9todo getNombre\n@Override\npublic String getNombre() {\n    return \"Profesor: \" + this.nombre;\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#ampliacion-de-metodos-heredados","title":"Ampliaci\u00f3n de m\u00e9todos heredados","text":"<p>Hasta ahora, has visto que para redefinir o sustituir un m\u00e9todo de una superclase es suficiente con crear otro m\u00e9todo en la subclase que tenga el mismo nombre que el m\u00e9todo que se desea sobrescribir. Pero, en otras ocasiones, puede que lo que necesites no sea sustituir completamente el comportamiento del m\u00e9todo de la superclase, sino simplemente ampliarlo.</p> <p>Para poder hacer esto necesitas poder preservar el comportamiento antiguo (el de la superclase) y a\u00f1adir el nuevo (el de la subclase). Para ello, puedes invocar desde el m\u00e9todo \"ampliador\" de la clase derivada al m\u00e9todo \"ampliado\" de la clase superior (teniendo ambos m\u00e9todos el mismo nombre). \u00bfC\u00f3mo se puede conseguir eso? Puedes hacerlo mediante el uso de la referencia super.</p> <p>La palabra reservada super es una referencia a la clase madre de la clase en la que te encuentres en cada momento (es algo similar a this, que representaba una referencia a la clase actual). De esta manera, podr\u00edas invocar a cualquier m\u00e9todo de tu superclase (si es que se tiene acceso a \u00e9l).</p> <p>Por ejemplo, imagina que la clase Persona dispone de un m\u00e9todo que permite mostrar el contenido de algunos datos personales de los objetos de este tipo (nombre, apellidos, etc.). Por otro lado, la clase Alumno tambi\u00e9n necesita un m\u00e9todo similar, pero que muestre tambi\u00e9n su informaci\u00f3n especializada (grupo, nota media, etc.). \u00bfC\u00f3mo podr\u00edas aprovechar el m\u00e9todo de la superclase para no tener que volver a escribir su contenido en la subclase?</p> <p>Podr\u00eda hacerse de una manera tan sencilla como la siguiente:</p> Ejemplo: m\u00e9todo mostrarDatos de <code>Alumno</code> Java<pre><code>public void mostrarDatos () {\n  super.mostrarDatos();  // Llamada al m\u00e9todo \"mostrar\" de la superclase\n  // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n  System.out.printf (\"Grupo: %s\\n\", this.grupo);\n  System.out.printf (\"Nota media: %5.2f\\n\", this.notaMedia);\n}\n</code></pre> <p>Este tipo de ampliaciones de m\u00e9todos resultan especialmente \u00fatiles por ejemplo en el caso de los constructores, donde se podr\u00eda ir llamando a los constructores de cada superclase encadenadamente hasta el constructor de la clase en la c\u00faspide de la jerarqu\u00eda (el constructor de la clase <code>Object</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, define un m\u00e9todo mostrar para la clase Persona, que muestre el contenido de los atributos (datos personales) de un objeto de la clase Persona. A continuaci\u00f3n, define sendos m\u00e9todos mostrar especializados para las clases Alumno y Profesor que \"ampl\u00eden\" la funcionalidad del m\u00e9todo mostrar original de la clase Persona.</p> <p>1) M\u00e9todo mostrar de la clase <code>Persona</code>. Java<pre><code>public void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n}\n</code></pre></p> <p>2) M\u00e9todo mostrar de la clase <code>Alumno</code>. Llamamos al m\u00e9todo mostrar de su clase madre (<code>Persona</code>) y luego a\u00f1adimos la funcionalidad espec\u00edfica para la subclase <code>Alumno</code>: Java<pre><code>public void mostrarDatos() {\n    super.mostrarDatos();  // Llamada al m\u00e9todo \"mostrarDatos\" de la superclase\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Grupo:\", this.grupo);\n    System.out.printf (\"%-18s%-5.2f\\n\", \"Nota media:\", this.notaMedia);\n}\n</code></pre></p> <p>3) M\u00e9todo mostrar de la clase <code>Profesor</code>. Llamamos al m\u00e9todo mostrar de su clase madre (<code>Persona</code>) y luego a\u00f1adimos la funcionalidad espec\u00edfica para la subclase <code>Profesor</code>: Java<pre><code>public void mostrarDatos() {\n    super.mostrarDatos();\n\n    System.out.printf (\"%-18s%s\\n\", \"Especialidad:\", this.especialidad);\n    System.out.printf (\"%-18s%-7.2f \u20ac\\n\", \"Salario:\", this.salario);\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#constructores-y-herencia","title":"Constructores y herencia","text":"<p>Recuerda que cuando estudiaste los constructores viste que un constructor de una clase puede llamar a otro constructor de la misma clase, previamente definido, a trav\u00e9s de la referencia this. En estos casos, la utilizaci\u00f3n de this s\u00f3lo pod\u00eda hacerse en la primera l\u00ednea de c\u00f3digo del constructor. </p> <p>Como ya has visto, un constructor de una clase derivada puede hacer algo parecido para llamar al constructor de su clase base mediante el uso de la palabra super. De esta manera, el constructor de una clase derivada puede llamar primero al constructor de su superclase para que inicialice los atributos heredados y posteriormente se inicializar\u00e1n los atributos espec\u00edficos de la clase: los no heredados. Nuevamente, esta llamada tambi\u00e9n debe ser la primera sentencia de un constructor (con la \u00fanica excepci\u00f3n de que exista una llamada a otro constructor de la clase mediante this). </p> <p>Si no se incluye una llamada a <code>super()</code> dentro del constructor, el compilador incluye autom\u00e1ticamente una llamada al constructor por defecto de clase base (llamada a <code>super()</code>). Esto da lugar a una llamada en cadena de constructores de superclase hasta llegar a la clase m\u00e1s alta de la jerarqu\u00eda (que en Java es la clase <code>Object</code>).</p> <p>En el caso del constructor por defecto (el que crea el compilador si el programador no ha escrito ninguno), el compilador a\u00f1ade lo primero de todo, antes de la inicializaci\u00f3n de los atributos a sus valores por defecto, una llamada al constructor de la clase base mediante la referencia super.</p> <p>A la hora de destruir un objeto (m\u00e9todo <code>finalize</code>) es importante llamar a los finalizadores en el orden inverso a como fueron llamados los constructores (primero se liberan los recursos de la clase derivada y despu\u00e9s los de la clase base mediante la llamada <code>super.finalize()</code>).</p> <p>Si la clase Persona tuviera un constructor de este tipo:</p> Java<pre><code>public Persona (String nombre, String apellidos, LocalDate fechaNacim) {\n  this.nombe = nombre;\n  this.apellidos = apellidos;\n  this.fechaNacim = new LocalDate (fechaNacim);\n}\n</code></pre> <p>Podr\u00edas llamarlo desde un constructor de una clase derivada (por ejemplo Alumno) de la siguiente forma:</p> Java<pre><code>public Alumno (String nombre, String apellidos, LocalDate fechaNacim, String grupo, double notaMedia) {\n  super (nombre, apellidos, fechaNacim);\n  this.grupo = grupo;\n  this.notaMedia = notaMedia;\n}\n</code></pre> <p>En realidad se trata de otro recurso m\u00e1s para optimizar la reutilizaci\u00f3n de c\u00f3digo, en este caso el del constructor, que aunque no es heredado, s\u00ed puedes invocarlo para no tener que reescribirlo.</p> Ejemplo: constructor de <code>Alumno</code> que hereda parte del constructor de <code>Persona</code> Java<pre><code>public Alumno(String nombre, String apellidos, LocalDate fechaNacimiento, String grupo, double notaMedia) {\n    super(nombre, apellidos, fechaNacimiento);\n    this.grupo = grupo;\n    this.notaMedia = notaMedia;\n}\n</code></pre>"},{"location":"ud08/ud0803/#creacion-y-utilizacion-de-clases-derivadas","title":"Creaci\u00f3n y utilizaci\u00f3n de clases derivadas","text":"<p>Ya has visto c\u00f3mo crear una clase derivada, c\u00f3mo acceder a los miembros heredados de las clases superiores, c\u00f3mo redefinir algunos de ellos e incluso c\u00f3mo invocar a un constructor de la superclase. Ahora se trata de poner en pr\u00e1ctica todo lo que has aprendido para que puedas crear tus propias jerarqu\u00edas de clases, o basarte en clases que ya existan en Java para heredar de ellas, y las utilices de manera adecuada para que tus aplicaciones sean m\u00e1s f\u00e1ciles de escribir y mantener.</p> <p>La idea de la herencia no es complicar los programas, sino todo lo contrario: simplificarlos al m\u00e1ximo. Procurar que haya que escribir la menor cantidad posible de c\u00f3digo repetitivo e intentar facilitar en lo posible la realizaci\u00f3n de cambios (bien para corregir errores bien para incrementar la funcionalidad).</p>"},{"location":"ud08/ud0803/#la-clase-object-en-java","title":"La clase <code>Object</code> en Java","text":"<p>Todas las clases en Java son descendentes (directos o indirectos) de la clase Object. Esta clase define los estados y comportamientos b\u00e1sicos que deben tener todos los objetos. Entre estos comportamientos, se encuentran:</p> <ul> <li>La posibilidad de compararse.</li> <li>La capacidad de convertirse a cadenas.</li> <li>La habilidad de devolver la clase del objeto.</li> </ul> <p>Entre los m\u00e9todos que incorpora la clase <code>Object</code> y que por tanto hereda cualquier clase en Java tienes:</p> <p>Principales m\u00e9todos de la clase <code>Object</code>:</p> M\u00e9todo Descripci\u00f3n <code>Object()</code> Constructor. <code>clone()</code> M\u00e9todo clonador: crea y devuelve una copia del objeto (\"clona\" el objeto). <code>boolean equals(Object obj)</code> Indica si el objeto pasado como par\u00e1metro es igual a este objeto. <code>void finalize()</code> M\u00e9todo llamado por el recolector de basura cuando \u00e9ste considera que no queda ninguna referencia a este objeto en el entorno de ejecuci\u00f3n. <code>int hashCode()</code> Devuelve un c\u00f3digo hash para el objeto. <code>toString()</code> Devuelve una representaci\u00f3n del objeto en forma de String. <p>La clase <code>Object</code>representa la superclase que se encuentra en la c\u00faspide de la jerarqu\u00eda de herencia en Java. Cualquier clase (incluso las que t\u00fa implementes) acaban heredando de ella.</p>"},{"location":"ud08/ud0803/#herencia-multiple","title":"Herencia m\u00faltiple","text":"<p>En determinados casos podr\u00edas considerar la posibilidad de que se necesite heredar de m\u00e1s de una clase, para as\u00ed disponer de los miembros de dos (o m\u00e1s) clases disjuntas (que no derivan una de la otra). La herencia m\u00faltiple permite hacer eso: recoger las distintas caracter\u00edsticas (atributos y m\u00e9todos) de clases diferentes formando una nueva clase derivada de varias clases base.</p> <p>El problema en estos casos es la posibilidad que existe de que se produzcan ambig\u00fcedades; as\u00ed, si tuvi\u00e9ramos miembros con el mismo identificador en clases base diferentes, en tal caso, \u00bfqu\u00e9 miembro se hereda? Para evitar esto, los compiladores suelen solicitar que ante casos de ambig\u00fcedad, se especifique de manera expl\u00edcita la clase de la cual se quiere utilizar un determinado miembro que pueda ser ambiguo.</p> <p>Ahora bien, la posibilidad de herencia m\u00faltiple no est\u00e1 disponible en todos los lenguajes orientados a objetos, \u00bflo estar\u00e1 en Java? La respuesta es negativa.</p> <p></p> <p>En Java ...</p> <p>... no existe la herencia m\u00faltiple de clases.</p>"},{"location":"ud08/ud0804/","title":"8.4 Clases abstractas","text":"<p>En determinadas ocasiones, es posible que necesites definir una clase que represente un concepto lo suficientemente abstracto como para que nunca vayan a existir instancias de ella (objetos). \u00bfTendr\u00eda eso sentido? \u00bfQu\u00e9 utilidad podr\u00eda tener?</p> <p>Imagina una aplicaci\u00f3n para un centro educativo que utilice las clases de ejemplo Alumno y Profesor, ambas subclases de Persona. Es m\u00e1s que probable que esa aplicaci\u00f3n nunca llegue a necesitar objetos de la clase Persona, pues ser\u00edan demasiado gen\u00e9ricos como para poder ser utilizados (no contendr\u00edan suficiente informaci\u00f3n espec\u00edfica). Podr\u00edas llegar entonces a la conclusi\u00f3n de que la clase Persona ha resultado de utilidad como clase base para construir otras clases que hereden de ella, pero no como una clase instanciable de la cual vayan a existir objetos. A este tipo de clases se les llama clases abstractas.</p> <p>A tener en cuenta</p> <p>En algunos casos puede resultar \u00fatil disponer de clases que nunca ser\u00e1n instanciadas, sino que proporcionan un marco o modelo a seguir por sus clases derivadas dentro de una jerarqu\u00eda de herencia. Son las clases abstractas.</p> <p>La posibilidad de declarar clases abstractas es una de las caracter\u00edsticas m\u00e1s \u00fatiles de los lenguajes orientados a objetos, pues permiten dar unas l\u00edneas generales de c\u00f3mo es una clase sin tener que implementar todos sus m\u00e9todos o implementando solamente algunos de ellos. Esto resulta especialmente \u00fatil cuando las distintas clases derivadas deban proporcionar los mismos m\u00e9todos indicados en la clase base abstracta, pero su implementaci\u00f3n sea espec\u00edfica para cada subclase. </p> <p>Imagina que est\u00e1s trabajando en un entorno de manipulaci\u00f3n de objetos gr\u00e1ficos y necesitas trabajar con l\u00edneas, c\u00edrculos, rect\u00e1ngulos, etc. Estos objetos tendr\u00e1n en com\u00fan algunos atributos que representen su estado (ubicaci\u00f3n, color del contorno, color de relleno, etc.) y algunos m\u00e9todos que modelen su comportamiento (dibujar, rellenar con un color, escalar, desplazar, rotar, etc.). Algunos de ellos ser\u00e1n comunes para todos ellos (por ejemplo la ubicaci\u00f3n o el desplazamiento) y sin embargo otros (como por ejemplo dibujar) necesitar\u00e1n una implementaci\u00f3n espec\u00edfica dependiendo del tipo de objeto. Pero, en cualquier caso, todos ellos necesitan esos m\u00e9todos (tanto un c\u00edrculo como un rect\u00e1ngulo necesitan el m\u00e9todo dibujar, aunque se lleven a cabo de manera diferente). En este caso resultar\u00eda muy \u00fatil disponer de una clase abstracta objeto gr\u00e1fico donde se definir\u00edan las l\u00edneas generales (algunos atributos concretos comunes, algunos m\u00e9todos concretos comunes implementados y algunos m\u00e9todos gen\u00e9ricos comunes sin implementar) de un objeto gr\u00e1fico y m\u00e1s adelante, seg\u00fan se vayan definiendo clases especializadas (l\u00edneas, c\u00edrculos, rect\u00e1ngulos), se ir\u00e1n concretando en cada subclase aquellos m\u00e9todos que se dejaron sin implementar en la clase abstracta.</p>"},{"location":"ud08/ud0804/#declaracion-de-una-clase-abstracta","title":"Declaraci\u00f3n de una clase abstracta","text":"<p>Ya has visto que una clase abstracta es una clase que no se puede instanciar, es decir, que no se pueden crear objetos a partir de ella. La idea es permitir que otras clases deriven de ella, proporcionando un modelo gen\u00e9rico y algunos m\u00e9todos de utilidad general. Las clases abstractas se declaran mediante el modificador <code>abstract</code>:</p> Java<pre><code>[modificador_acceso] abstract class nombreClase [herencia] [interfaces] {\n  ...\n}\n</code></pre> <p>A tener en cuenta</p> <p>Una clase puede contener en su interior m\u00e9todos declarados como <code>abstract</code> (m\u00e9todos para los cuales s\u00f3lo se indica la cabecera, pero no se proporciona su implementaci\u00f3n). En tal caso, la clase tendr\u00e1 que ser necesariamente tambi\u00e9n <code>abstract</code>. Esos m\u00e9todos tendr\u00e1n que ser posteriormente implementados en sus clases derivadas.</p> <p>Por otro lado, una clase tambi\u00e9n puede contener m\u00e9todos totalmente implementados (no abstractos), los cuales ser\u00e1n heredados por sus clases derivadas y podr\u00e1n ser utilizados sin necesidad de definirlos (pues ya est\u00e1n implementados).</p> <p>Cuando trabajes con clases abstractas debes tener en cuenta:</p> <ul> <li>Una clase abstracta s\u00f3lo puede usarse para crear nuevas clases derivadas. No se puede hacer un new de una clase abstracta. Se producir\u00eda un error de compilaci\u00f3n.</li> <li>Una clase abstracta puede contener m\u00e9todos totalmente definidos (no abstractos) y m\u00e9todos sin definir (m\u00e9todos abstractos).</li> </ul> Revisa con cuidado el siguiente ejemplo <p>Bas\u00e1ndote en la jerarqu\u00eda de clases de ejemplo (<code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>), que ya has utilizado en otras ocasiones, modifica lo que consideres oportuno para que <code>Persona</code> sea, a partir de ahora, una clase abstracta (no instanciable) y las otras dos clases sigan siendo clases derivadas de ella, pero s\u00ed instanciables. En este caso lo \u00fanico que habr\u00eda que hacer es a\u00f1adir el modificador <code>abstract</code> a la clase <code>Persona</code>. El resto de la clase permanecer\u00eda igual y las clases Alumno y Profesor no tendr\u00edan porqu\u00e9 sufrir ninguna modificaci\u00f3n.</p> Java<pre><code>public abstract class Persona {\n    protected String nombre;\n    protected String apellidos;\n    protected LocalDate fechaNacimiento;\n    ...\n}\n</code></pre> <p>A partir de ahora no podr\u00e1n existir objetos de la clase <code>Persona</code>. El compilador generar\u00eda un error.</p> <p>Localiza en la API de Java alg\u00fan ejemplo de clase abstracta.</p> <p>Existen una gran cantidad de clases abstractas en la API de Java. Aqu\u00ed tienes un par de ejemplos:</p> <ul> <li>La clase <code>AbstractList</code>:</li> </ul> Java<pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;\n</code></pre> <p>De la que heredan clases instanciable como <code>Vector</code> o <code>ArrayList</code>.</p> <ul> <li>La clase <code>AbstractSequentialList</code>:</li> </ul> Java<pre><code>public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt;\n</code></pre> <p>Que hereda de <code>AbstractList</code> y de la que hereda la clase <code>LinkedList</code>.    </p>"},{"location":"ud08/ud0804/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Un m\u00e9todo abstracto es un m\u00e9todo declarado en una clase para el cual esa clase no proporciona la implementaci\u00f3n. Si una clase dispone de al menos un m\u00e9todo abstracto se dice que es una clase abstracta. Toda clase que herede (sea subclase) de una clase abstracta debe implementar todos los m\u00e9todos abstractos de su superclase o bien volverlos a declarar como abstractos (y por tanto tambi\u00e9n ser\u00eda abstracta). Para declarar un m\u00e9todo abstracto en Java se utiliza el modificador <code>abstract</code>) es un m\u00e9todo cuya implementaci\u00f3n no se define, sino que se declara \u00fanicamente su interfaz (cabecera) para que su cuerpo sea implementado m\u00e1s adelante en una clase derivada.</p> <p>Un m\u00e9todo se declara como abstracto mediante el uso del modificador <code>abstract</code> (como en las clases abstractas):</p> Java<pre><code>[modificador_acceso] abstract &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones];\n</code></pre> <p>A tener en cuenta</p> <p>Cuando una clase contiene un m\u00e9todo abstracto tiene que declararse como abstracta obligatoriamente.</p> <p>Imagina que tienes una clase <code>Empleado</code> gen\u00e9rica para diversos tipos de empleado y tres clases derivadas: <code>EmpleadoFijo</code> (tiene un salario fijo m\u00e1s ciertos complementos), <code>EmpleadoTemporal</code> (salario fijo m\u00e1s otros complementos diferentes) y <code>EmpleadoComercial</code> (una parte de salario fijo y unas comisiones por cada operaci\u00f3n). La clase <code>Empleado</code> podr\u00eda contener un m\u00e9todo abstracto <code>calcularNomina</code>, pues sabes que se m\u00e9todo ser\u00e1 necesario para cualquier tipo de empleado (todo empleado cobra una n\u00f3mina). Sin embargo el c\u00e1lculo en s\u00ed de la n\u00f3mina ser\u00e1 diferente si se trata de un empleado fijo, un empleado temporal o un empleado comercial, y ser\u00e1 dentro de las clases especializadas de <code>Empleado</code> (<code>EmpleadoFijo</code> \u0327 <code>EmpleadoTemporal</code>, <code>EmpleadoComercial</code>) donde se implementen de manera espec\u00edfica el c\u00e1lculo de las mismas.</p> <p>Debes tener en cuenta al trabajar con m\u00e9todos abstractos:</p> <ul> <li>Un m\u00e9todo abstracto implica que la clase a la que pertenece tiene que ser abstracta, pero eso no significa que todos los m\u00e9todos de esa clase tengan que ser abstractos.</li> <li>Un m\u00e9todo abstracto no puede ser privado (no se podr\u00eda implementar, dado que las clases derivadas no tendr\u00edan acceso a \u00e9l).</li> <li>Los m\u00e9todos abstractos no pueden ser est\u00e1ticos, pues los m\u00e9todos est\u00e1ticos no pueden ser redefinidos (y los m\u00e9todos abstractos necesitan ser redefinidos).</li> </ul> Revisa con cuidado el siguiente ejemplo <p>Bas\u00e1ndote en la jerarqu\u00eda de clases <code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>, crea un m\u00e9todo abstracto llamado <code>mostrarDatos</code> para la clase <code>Persona</code>. Dependiendo del tipo de persona (<code>alumno</code> o <code>profesor</code>) el m\u00e9todo <code>mostrarDatos</code> tendr\u00e1 que mostrar unos u otros datos personales (habr\u00e1 que hacer implementaciones espec\u00edficas en cada clase derivada). Una vez hecho esto, implementa completamente las tres clases (con todos sus atributos y m\u00e9todos) y util\u00edzalas en un peque\u00f1o programa de ejemplo que cree un objeto de tipo <code>Alumno</code> y otro de tipo <code>Profesor</code>, los rellene con informaci\u00f3n y muestre esa informaci\u00f3n en la pantalla a trav\u00e9s del m\u00e9todo mostrar. Dado que el m\u00e9todo <code>mostrarDatos</code> no va a ser implementado en la clase Persona, ser\u00e1 declarado como abstracto y no se incluir\u00e1 su implementaci\u00f3n: Java<pre><code>protected abstract void mostrarDatos ();\n</code></pre></p> <p>Recuerda que el simple hecho de que la clase <code>Persona</code> contenga un m\u00e9todo abstracto hace que la clase sea abstracta (y deber\u00e1 indicarse como tal en su declaraci\u00f3n): </p> Java<pre><code>public abstract class Persona {\n...\n</code></pre> <p>En el caso de la clase <code>Alumno</code> habr\u00e1 que hacer una implementaci\u00f3n espec\u00edfica del m\u00e9todo mostrarDatos y lo mismo para el caso de la clase <code>Profesor</code>.</p> <p>1) M\u00e9todo mostrarDatos para la clase <code>Alumno</code>. Java<pre><code>@Override\npublic void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Grupo:\", this.grupo);\n    System.out.printf (\"%-18s%-5.2f\\n\", \"Nota media:\", this.notaMedia);    \n}\n</code></pre></p> <p>2) M\u00e9todo mostrarDatos para la clase <code>Profesor</code>. Java<pre><code>@Override\npublic void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Especialidad:\", this.especialidad);\n    System.out.printf (\"%-18s%-7.2f \u20ac\\n\", \"Salario:\", this.salario);\n}\n</code></pre></p> <p>3) Programa de ejemplo de uso.</p> <p>Un peque\u00f1o programa de ejemplo de uso del m\u00e9todo mostrar en estas dos clases podr\u00eda ser:</p> Java<pre><code>import java.time.LocalDate;\n\npublic class EjemploUso {\n\n    public static void main(String[] args) {\n        // Declaraci\u00f3n de objetos\n        Alumno alumno;\n        Profesor profesor;\n        // Creaci\u00f3n de objetos (llamada a constructores)\n        alumno = new Alumno(\"Juan\", \"Torres\", LocalDate.of(1990, 10, 6), \"1DAW\", 7.5);\n        profesor = new Profesor(\"Antonio\", \"Campos\", LocalDate.of(1970, 8, 15), \"Informatica\", 1750);\n        // Utilizaci\u00f3n del m\u00e9todo mostrar\n        alumno.mostrarDatos();\n        profesor.mostrarDatos();\n    }\n}\n</code></pre> <p>La salida debe ser algo parecido a esto:</p> Bash<pre><code>Nombre:           Juan\nApellidos:        Torres\nFecha nacimiento: 6/10/1990\nGrupo:            1DAW\nNota media:       7,50\nNombre:           Antonio\nApellidos:        Campos\nFecha nacimiento: 15/08/1970\nEspecialidad:     Informatica\nSalario:          1750,00 \u20ac\n</code></pre>"},{"location":"ud08/ud0804/#clases-y-metodos-finales","title":"Clases y m\u00e9todos finales","text":"<p>En unidades anteriores has visto el modificador final, aunque s\u00f3lo lo has utilizado por ahora para atributos y variables (por ejemplo para declarar atributos constantes, que una vez que toman un valor ya no pueden ser modificados). Pero este modificador tambi\u00e9n puede ser utilizado con clases y con m\u00e9todos (con un comportamiento que no es exactamente igual, aunque puede encontrarse cierta analog\u00eda: no se permite heredar o no se permite redefinir).</p> <p>Una clase declarada como <code>final</code> no puede ser heredada, es decir, no puede tener clases derivadas. La jerarqu\u00eda de clases a la que pertenece acaba en ella (no tendr\u00e1 clases hijas):</p> Java<pre><code>[modificador_acceso] final class nombreClase [herencia] [interfaces]\n</code></pre> <p>Un m\u00e9todo tambi\u00e9n puede ser declarado como <code>final</code>, en tal caso, ese m\u00e9todo no podr\u00e1 ser redefinido en una clase derivada:</p> Java<pre><code>[modificador_acceso] final &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones]\n</code></pre> <p>Si intentas redefinir un m\u00e9todo <code>final</code> en una subclase se producir\u00e1 un error de compilaci\u00f3n.</p> <p>Distintos contextos en los que puede aparecer el modificador <code>final</code>:</p> Lugar Funci\u00f3n Como modificador de clase. La clase no puede tener subclases. Como modificador de atributo. El atributo no podr\u00e1 ser modificado una vez que tome un valor. Sirve para definir constantes. Como modificador al declarar un m\u00e9todo El m\u00e9todo no podr\u00e1 ser redefinido en una clase derivada. Como modificador al declarar una variable referencia. Una vez que la variable tome un valor referencia (un objeto), no se podr\u00e1 cambiar. La variable siempre apuntar\u00e1 al mismo objeto, lo cual no quiere decir que ese objeto no pueda ser modificado internamente a trav\u00e9s de sus m\u00e9todos. Pero la variable no podr\u00e1 apuntar a otro objeto diferente. Como modificador en un par\u00e1metro de un m\u00e9todo El valor del par\u00e1metro (ya sea un tipo primitivo o una referencia) no podr\u00e1 modificarse dentro del c\u00f3digo del m\u00e9todo. <p>Veamos un ejemplo de cada posibilidad:</p> <p>1) Modificador de una clase.</p> Java<pre><code>public final class ClaseSinDescendencia { // Clase \"no heredable\"\n  ...\n}\n</code></pre> <p>2) Modificador de un atributo.</p> Java<pre><code>public class ClaseEjemplo {\n  // Valor constante conocido en tiempo de compilaci\u00f3n\n  final double PI = 3.14159265;\n\n  // Valor constante conocido solamente en tiempo de ejecuci\u00f3n\n  final int SEMILLA = (int) Math.random()*10+1;\n  ...\n}\n</code></pre> <p>3) Modificador de un m\u00e9todo.</p> Java<pre><code>public final metodoNoRedefinible (int parametro1) { // M\u00e9todo \"no redefinible\"\n  ...\n} \n</code></pre> <p>4) Modificador en una variable referencia.</p> Java<pre><code>// Referencia constante: siempre se apuntar\u00e1 al mismo objeto Alumno\n// reci\u00e9n creado, aunque este objeto pueda sufrir modificaciones.\nfinal Alumno PRIMER_ALUMNO = new Alumno (\"Pepe\", \"Torres\", 9.55);\n\n// Si la variable no es una referencia (tipo primitivo), \n// ser\u00eda una constante m\u00e1s (como un atributo constante).\nfinal int NUMERO_DIEZ = 10; // Valor constante (dentro del \u00e1mbito de vida de la variable)\n</code></pre> <p>5) Modificador en un par\u00e1metro de un m\u00e9todo.</p> Java<pre><code>void metodoConParametrosFijos (final int par1, final int par2) {\n  // Los par\u00e1metros \"par1\" y \"par2\" no podr\u00e1n\n  // sufrir modificaciones aqu\u00ed dentro\n  ...\n}\n</code></pre>"},{"location":"ud08/ud0805/","title":"8.5 Interfaces","text":"<p>Has visto c\u00f3mo la herencia permite definir especializaciones (o extensiones) de una clase base que ya existe sin tener que volver a repetir todo el c\u00f3digo de \u00e9sta. Este mecanismo da la oportunidad de que la nueva clase especializada (o extendida) disponga de toda la interfaz que tiene su clase base.</p> <p>Tambi\u00e9n has estudiado c\u00f3mo los m\u00e9todos abstractos permiten establecer una interfaz para marcar las l\u00edneas generales de un comportamiento com\u00fan de superclase que deber\u00edan compartir de todas las subclases.</p> <p>Si llevamos al l\u00edmite esta idea de interfaz, podr\u00edas llegar a tener una clase abstracta donde todos sus m\u00e9todos fueran abstractos. De este modo estar\u00edas dando \u00fanicamente el marco de comportamiento, sin ning\u00fan m\u00e9todo implementado, de las posibles subclases que heredar\u00e1n de esa clase abstracta. La idea de una interfaz (o interface) es precisamente \u00e9sa: disponer de un mecanismo que permita especificar cu\u00e1l debe ser el comportamiento que deben tener todos los objetos que formen parte de una determinada clasificaci\u00f3n (no necesariamente jer\u00e1rquica).</p> <p>Una interfaz consiste principalmente en una lista de declaraciones de m\u00e9todos sin implementar, que caracterizan un determinado comportamiento. Si se desea que una clase tenga ese comportamiento, tendr\u00e1 que implementar esos m\u00e9todos establecidos en la interfaz. En este caso no se trata de una relaci\u00f3n de herencia (la clase B es una especializaci\u00f3n de la clase A, o la subclase B es del tipo de la superclase A), sino m\u00e1s bien una relaci\u00f3n \"de implementaci\u00f3n de comportamientos\" (la clase B implementa los m\u00e9todos establecidos en la interfaz A, o los comportamientos indicados por A son llevados a cabo por B; pero no que B sea de clase A).</p> <p>Imagina que est\u00e1s dise\u00f1ando una aplicaci\u00f3n que trabaja con clases que representan distintos tipos de animales. Algunas de las acciones que quieres que lleven a cabo est\u00e1n relacionadas con el hecho de que algunos animales sean depredadores (por ejemplo: observar una presa, perseguirla, com\u00e9rsela, etc.) o sean presas (observar, huir, esconderse, etc.). Si creas la clase <code>Le\u00f3n</code>, esta clase podr\u00eda implementar una interfaz <code>Depredador</code>, mientras que otras clases como <code>Gacela</code> implementar\u00edan las acciones de la interfaz <code>Presa</code>. Por otro lado, podr\u00edas tener tambi\u00e9n el caso de la clase <code>Rana</code>, que implementar\u00eda las acciones de la interfaz <code>Depredador</code> (pues es cazador de peque\u00f1os insectos), pero tambi\u00e9n la de <code>Presa</code> (pues puede ser cazado y necesita las acciones necesarias para protegerse).</p> <p></p>"},{"location":"ud08/ud0805/#concepto-de-interfaz","title":"Concepto de interfaz","text":"<p>Una interfaz en Java consiste esencialmente en una lista de declaraciones de m\u00e9todos sin implementar, junto con un conjunto de constantes.</p> <p>Estos m\u00e9todos sin implementar indican un comportamiento, un tipo de conducta, aunque no especifican c\u00f3mo ser\u00e1 ese comportamiento (implementaci\u00f3n), pues eso depender\u00e1 de las caracter\u00edsticas espec\u00edficas de cada clase que decida implementar esa interfaz. Podr\u00eda decirse que una interfaz se encarga de establecer qu\u00e9 comportamientos hay que tener (qu\u00e9 m\u00e9todos), pero no dice nada de c\u00f3mo deben llevarse a cabo esos comportamientos (implementaci\u00f3n). Se indica s\u00f3lo la forma, no la implementaci\u00f3n.</p> <p>En cierto modo podr\u00edas imaginar el concepto de interfaz como un gui\u00f3n que dice: \"\u00e9ste es el protocolo de comunicaci\u00f3n que deben presentar todas las clases que implementen esta interfaz\". Se proporciona una lista de m\u00e9todos p\u00fablicos y, si quieres dotar a tu clase de esa interfaz, tendr\u00e1s que definir todos y cada uno de esos m\u00e9todos p\u00fablicos.</p> <p>En conclusi\u00f3n: una interfaz se encarga de establecer unas l\u00edneas generales sobre los comportamientos (m\u00e9todos) que deber\u00edan tener los objetos de toda clase que implemente esa interfaz, es decir, que no indican lo que el objeto es (de eso se encarga la clase y sus superclases), sino acciones (capacidades) que el objeto deber\u00eda ser capaz de realizar. Es por esto que el nombre de muchas interfaces en Java termina con sufijos del tipo \"\u2010able\", \"\u2010or\", \"\u2010ente\" y cosas del estilo, que significan algo as\u00ed como capacidad o habilidad para hacer o ser receptores de algo (configurable, serializable, modificable, clonable, ejecutable, administrador, servidor, buscador, etc.), dando as\u00ed la idea de que se tiene la capacidad de llevar a cabo el conjunto de acciones especificadas en la interfaz.</p> <p>Imag\u00ednate por ejemplo la clase <code>Coche</code>, subclase de <code>Veh\u00edculo</code>. Los coches son veh\u00edculos a motor, lo cual implica una serie de acciones como, por ejemplo, arrancar el motor o detener el motor. Esa acci\u00f3n no la puedes heredar de <code>Veh\u00edculo</code>, pues no todos los veh\u00edculos tienen porqu\u00e9 ser a motor (piensa por ejemplo en una clase <code>Bicicleta</code>), y no puedes heredar de otra clase pues ya heredas de <code>Veh\u00edculo</code>. Una soluci\u00f3n podr\u00eda ser crear una interfaz <code>Arrancable</code>, que proporcione los m\u00e9todos t\u00edpicos de un objeto a motor (no necesariamente veh\u00edculos). De este modo la clase <code>Coche</code> sigue siendo subclase de <code>Veh\u00edculo</code>, pero tambi\u00e9n implementar\u00eda los comportamientos de la interfaz <code>Arrancable</code>, los cuales podr\u00edan ser tambi\u00e9n implementados por otras clases, hereden o no de <code>Veh\u00edculo</code> (por ejemplo una clase <code>Motocicleta</code> o bien una clase <code>Motosierra</code>). La clase <code>Coche</code> implementar\u00e1 su m\u00e9todo arrancar de una manera, la clase <code>Motocicleta</code> lo har\u00e1 de otra (aunque bastante parecida) y la clase <code>Motosierra</code> de otra forma probablemente muy diferente, pero todos tendr\u00e1n su propia versi\u00f3n del m\u00e9todo arrancar como parte de la interfaz <code>Arrancable</code>.</p> <p>Seg\u00fan esta concepci\u00f3n, podr\u00edas hacerte la siguiente pregunta: \u00bfpodr\u00e1 una clase implementar varias interfaces? La respuesta en este caso s\u00ed es afirmativa.</p> <p>A tener en cuenta</p> <p>Una clase puede adoptar distintos modelos de comportamiento establecidos en diferentes interfaces. Es decir una clase puede implementar varias interfaces.</p>"},{"location":"ud08/ud0805/#clase-abstracta-o-interfaz","title":"\u00bfClase abstracta o interfaz?","text":"<p>Observando el concepto de interfaz que se acaba de proponer, podr\u00eda caerse en la tentaci\u00f3n de pensar que es pr\u00e1cticamente lo mismo que una clase abstracta en la que todos sus m\u00e9todos sean abstractos.</p> <p>Es cierto que en ese sentido existe un gran parecido formal entre una clase abstracta y una interfaz, pudi\u00e9ndose en ocasiones utilizar indistintamente una u otra para obtener un mismo fin. Pero, a pesar de ese gran parecido, existen algunas diferencias, no s\u00f3lo formales, sino tambi\u00e9n conceptuales, muy importantes:</p> <ul> <li>Una clase no puede heredar de varias clases, aunque sean abstractas (herencia m\u00faltiple). Sin embargo s\u00ed puede implementar una o varias interfaces y adem\u00e1s seguir heredando de una clase. </li> <li>Una interfaz no puede definir m\u00e9todos (no implementa su contenido), tan solo los declara o enumera.</li> <li>Una interfaz puede hacer que dos clases tengan un mismo comportamiento independientemente de sus ubicaciones en una determinada jerarqu\u00eda de clases (no tienen que heredar las dos de una misma superclase, pues no siempre es posible seg\u00fan la naturaleza y propiedades de cada clase).</li> <li>Una interfaz permite establecer un comportamiento de clase sin apenas dar detalles, pues esos detalles a\u00fan no son conocidos (depender\u00e1n del modo en que cada clase decida implementar la interfaz).</li> <li>Las interfaces tienen su propia jerarqu\u00eda, diferente e independiente de la jerarqu\u00eda de clases.</li> </ul> <p>De todo esto puede deducirse que una clase abstracta proporciona una interfaz disponible s\u00f3lo a trav\u00e9s de la herencia. S\u00f3lo quien herede de esa clase abstracta dispondr\u00e1 de esa interfaz. Si una clase no pertenece a esa misma jerarqu\u00eda (no hereda de ella) no podr\u00e1 tener esa interfaz. Eso significa que para poder disponer de la interfaz podr\u00edas:</p> <ol> <li>Volver a escribirla para esa jerarqu\u00eda de clases. Lo cual no parece una buena soluci\u00f3n.</li> <li>Hacer que la clase herede de la superclase que proporciona la interfaz que te interesa, sac\u00e1ndola de su jerarqu\u00eda original y convirti\u00e9ndola en clase derivada de algo de lo que conceptualmente no deber\u00eda ser una subclase. Es decir, estar\u00edas forzando una relaci\u00f3n \"es un\" cuando en realidad lo m\u00e1s probable es que esa relaci\u00f3n no exista. Tampoco parece la mejor forma de resolver el problema.</li> </ol> <p>Sin embargo, una interfaz s\u00ed puede ser implementada por cualquier clase, permitiendo que clases que no tengan ninguna relaci\u00f3n entre s\u00ed (pertenecen a distintas jerarqu\u00edas) puedan compartir un determinado comportamiento (una interfaz) sin tener que forzar una relaci\u00f3n de herencia que no existe entre ellas.</p> <p>A partir de ahora podemos hablar de otra posible relaci\u00f3n entre clases: la de compartir un determinado comportamiento (interfaz). Dos clases podr\u00edan tener en com\u00fan un determinado conjunto de comportamientos sin que necesariamente exista una relaci\u00f3n jer\u00e1rquica entre ellas. Tan solo cuando haya realmente una relaci\u00f3n de tipo \"es un\" se producir\u00e1 herencia.</p> <p>A tener en cuenta</p> <p>Si s\u00f3lo vas a proporcionar una lista de m\u00e9todos abstractos (interfaz), sin definiciones de m\u00e9todos ni atributos de objeto, suele ser recomendable definir una interfaz antes que clase abstracta. Es m\u00e1s, cuando vayas a definir una supuesta clase base, puedes comenzar declar\u00e1ndola como interfaz y s\u00f3lo cuando veas que necesitas definir m\u00e9todos o variables miembro, puedes entonces convertirla en clase abstracta (no instanciable) o incluso en una clase instanciable.</p>"},{"location":"ud08/ud0805/#definicion-de-interfaces","title":"Definici\u00f3n de interfaces","text":"<p>La declaraci\u00f3n de una interfaz en Java es similar a la declaraci\u00f3n de una clase, aunque con algunas variaciones:</p> <ul> <li>Se utiliza la palabra reservada <code>interface</code> en lugar de <code>class</code>.</li> <li>Puede utilizarse el modificador <code>public</code>. Si incluye este modificador la interfaz debe tener el mismo nombre que el archivo <code>.java</code> en el que se encuentra (exactamente igual que suced\u00eda con las clases). Si no se indica el modificador <code>public</code>, el acceso ser\u00e1 por omisi\u00f3n o \"de paquete\" (como suced\u00eda con las clases). </li> <li>Todos los miembros de la interfaz (atributos y m\u00e9todos) son <code>public</code> de manera impl\u00edcita. No es necesario indicar el modificador <code>public</code>, aunque puede hacerse.</li> <li>Todos los atributos son de tipo <code>final</code> y <code>public</code> (tampoco es necesario especificarlo), es decir, constantes y p\u00fablicos. Hay que darles un valor inicial.</li> <li>Todos los m\u00e9todos son abstractos tambi\u00e9n de manera impl\u00edcita (tampoco hay que indicarlo). No tienen cuerpo, tan solo la cabecera.</li> </ul> <p></p> <p>Como puedes observar, una interfaz consiste esencialmente en una lista de atributos finales (constantes) y m\u00e9todos abstractos (sin implementar). Su sintaxis quedar\u00eda entonces:</p> Java<pre><code>[public] interface &lt;NombreInterfaz&gt; {\n  [public] [final] &lt;tipo1&gt; &lt;atributo1&gt; = &lt;valor1&gt;;\n  [public] [final] &lt;tipo2&gt; &lt;atributo2&gt; = &lt;valor2&gt;;\n  ...\n  [public] [abstract] &lt;tipo_devuelto1&gt; &lt;nombreMetodo1&gt; ([lista_par\u00e1metros]);\n  [public] [abstract] &lt;tipo_devuelto2&gt; &lt;nombreMetodo2&gt; ([lista_par\u00e1metros]);\n  ...\n}\n</code></pre> <p>Si te fijas, la declaraci\u00f3n de los m\u00e9todos termina en punto y coma, pues no tienen cuerpo, al igual que sucede con los m\u00e9todos abstractos de las clases abstractas. El ejemplo de la interfaz <code>Depredador</code> que hemos visto antes podr\u00eda quedar entonces as\u00ed:</p> Java<pre><code>public interface Depredador {\n  void perseguir (Animal presa);\n  void cazar (Animal presa);\n  ...\n}\n</code></pre> <p>Ser\u00e1n las clases que implementen esta interfaz (<code>Le\u00f3n</code>, <code>Leopardo</code>, <code>Cocodrilo</code>, <code>Rana</code>, <code>Lagarto</code>, <code>Hombre</code>, etc.) las que definan cada uno de los m\u00e9todos por dentro.</p> Revisa con cuidado el siguiente ejemplo <p>Crea una interfaz en Java cuyo nombre sea <code>Imprimible</code> y que contenga algunos m\u00e9todos \u00fatiles para mostrar el contenido de una clase: 1) M\u00e9todo <code>devolverContenidoString</code>, que crea un <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve. El formato ser\u00e1 una lista de pares \"nombre=valor\" de cada atributo separado por comas y la lista completa encerrada entre llaves: \"<code>{&lt;nombre_atributo_1&gt;=&lt;valor_atributo_1&gt;, ..., &lt;nombre_atributo_n&gt;=&lt;valor_atributo_n&gt;}</code>\".</p> <p>2) M\u00e9todo <code>devolverContenidoArrayList</code>, que crea un <code>ArrayList</code> de <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve.</p> <p>3) M\u00e9todo <code>devolverContenidoHashMap</code>, similar al anterior, pero en lugar devolver en un <code>ArrayList</code> los valores de los atributos, se devuelve en una <code>HashMap</code> en forma de pares (<code>nombre</code>, <code>valor</code>). Se trata simplemente de declarar la interfaz e incluir en su interior esos tres m\u00e9todos:</p> Java<pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic interface Imprimible {\n\n    String devolverContenidoString();\n    ArrayList devolverContenidoArrayList();\n    HashMap devolverContenidoHashMap();\n}\n</code></pre> <p>El c\u00f3mo se implementar\u00e1n cada uno de esos m\u00e9todos depender\u00e1 exclusivamente de cada clase que decida implementar esta interfaz.</p>"},{"location":"ud08/ud0805/#implementacion-de-interfaces","title":"Implementaci\u00f3n de interfaces","text":"<p>Como ya has visto, todas las clases que implementan una determinada interfaz est\u00e1n obligadas a proporcionar una definici\u00f3n (implementaci\u00f3n) de los m\u00e9todos de esa interfaz, adoptando el modelo de comportamiento propuesto por \u00e9sta.</p> <p>Dada una interfaz, cualquier clase puede especificar dicha interfaz mediante el mecanismo denominado implementaci\u00f3n de interfaces. Para ello se utiliza la palabra reservada implements:</p> Java<pre><code>class NombreClase implements NombreInterfaz {\n</code></pre> <p>De esta manera, la clase est\u00e1 diciendo algo as\u00ed como \"la interfaz indica los m\u00e9todos que debo implementar, pero voy a ser yo (la clase) quien los implemente\".</p> <p>Es posible indicar varios nombres de interfaces separ\u00e1ndolos por comas:</p> Java<pre><code>class NombreClase implements NombreInterfaz1, NombreInterfaz2,... {\n</code></pre> <p>Cuando una clase implementa una interfaz, tiene que redefinir sus m\u00e9todos nuevamente con acceso p\u00fablico. Con otro tipo de acceso se producir\u00e1 un error de compilaci\u00f3n. Es decir, que del mismo modo que no se pod\u00edan restringir permisos de acceso en la herencia de clases, tampoco se puede hacer en la implementaci\u00f3n de interfaces.</p> <p>Una vez implementada una interfaz en una clase, los m\u00e9todos de esa interfaz tienen exactamente el mismo tratamiento que cualquier otro m\u00e9todo, sin ninguna diferencia, pudiendo ser invocados, heredados, redefinidos, etc.</p> <p>En el ejemplo de los depredadores, al definir la clase Le\u00f3n, habr\u00eda que indicar que implementa la interfaz Depredador:</p> Java<pre><code>class Leon implements Depredador {\n</code></pre> <p>En realidad la definici\u00f3n completa de la clase <code>Leon</code> deber\u00eda ser:</p> Java<pre><code>class Leon extends Felino implements Depredador {\n</code></pre> <p>A tener en cuenta</p> <p>El orden de <code>extends</code> e <code>implements</code> es importante, primero se define la herencia y a continuaci\u00f3n la interfaces que implementa.</p> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contenga la interfaz:</p> Java<pre><code>void perseguir (Animal presa) {\n  // Implementaci\u00f3n del m\u00e9todo localizar para un le\u00f3n\n  ...\n}\n</code></pre> <p>En el caso de clases que pudieran ser a la vez <code>Depredador</code> y <code>Presa</code>, tendr\u00edan que implementar ambas interfaces, como podr\u00eda suceder con la clase Rana:</p> Java<pre><code>class Rana implements Depredador, Presa {\n</code></pre> <p>Que de manera completa quedar\u00eda:</p> Java<pre><code>class Rana extends Anfibio implements Depredador, Presa {\n</code></pre> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contengan ambas interfaces, tanto las de Depredador (localizar, cazar, etc.) como las de Presa (observar, huir, etc.).</p> Revisa con cuidado el siguiente ejemplo <p>Haz que las clases <code>Alumno</code> y <code>Profesor</code> implementen la interfaz <code>Imprimible</code> que se ha escrito en el ejercicio anterior.</p> <p>La primera opci\u00f3n que se te puede ocurrir es pensar que en ambas clases habr\u00e1 que indicar que implementan la interfaz <code>Imprimible</code> y por tanto definir los m\u00e9todos que \u00e9sta incluye: <code>devolverContenidoString</code>, <code>devolverContenidoHashMap</code> y <code>devolverContenidoArrayList</code>.</p> <p>Si las clases <code>Alumno</code> y <code>Profesor</code> no heredaran de la misma clase habr\u00eda que hacerlo obligatoriamente as\u00ed, pues no comparten superclase y precisamente para eso sirven las interfaces: para implementar determinados comportamientos que no pertenecen a la estructura jer\u00e1rquica de herencia en la que se encuentra una clase (de esta manera, clases que no tienen ninguna relaci\u00f3n de herencia podr\u00edan compartir interfaz).</p> <p>Pero en este caso podr\u00edamos aprovechar que ambas clases s\u00ed son subclases de una misma superclase (heredan de la misma) y hacer que la interfaz <code>Imprimible</code> sea implementada directamente por la superclase (<code>Persona</code>) y de este modo ahorrarnos bastante c\u00f3digo. As\u00ed no har\u00eda falta indicar expl\u00edcitamente que <code>Alumno</code> y <code>Profesor</code> implementan la interfaz <code>Imprimible</code>, pues lo estar\u00e1n haciendo de forma impl\u00edcita al heredar de una clase que ya ha implementado esa interfaz (la clase <code>Persona</code>, que es padre de ambas).</p> <p>Una vez que los m\u00e9todos de la interfaz est\u00e9n implementados en la clase <code>Persona</code>, tan solo habr\u00e1 que redefinir o ampliar los m\u00e9todos de la interfaz para que se adapten a cada clase hija espec\u00edfica (<code>Alumno</code> o <code>Profesor</code>), ahorr\u00e1ndonos tener que escribir varias veces la parte de c\u00f3digo que obtiene los atributos gen\u00e9ricos de la clase <code>Persona</code>.</p> <p>1) Clase <code>Persona</code>.</p> <p>Indicamos que se va a implementar la interfaz <code>Imprimible</code>:</p> Java<pre><code>public abstract class Persona implements Imprimible {\n...\n</code></pre> <p>Definimos el m\u00e9todo <code>devolverContenidoHashMap</code> a la manera de como debe ser implementado para la clase Persona. Podr\u00eda quedar, por ejemplo, as\u00ed:</p> Java<pre><code>@Override\npublic HashMap devolverContenidoHashMap() {\n    // Creamos la HashMap que va a ser devuelta\n    HashMap contenido = new HashMap();\n    // A\u00f1adimos los atributos de la clase\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n    contenido.put(\"nombre\", this.nombre);\n    contenido.put(\"apellidos\", this.apellidos);\n    contenido.put(\"fechaNacim\", stringFecha);\n    // Devolvemos la HashMap\n    return contenido;\n}\n</code></pre> <p>Del mismo modo, definimos tambi\u00e9n el m\u00e9todo <code>devolverContenidoArrayList</code>:</p> Java<pre><code>@Override\npublic ArrayList devolverContenidoArrayList() {\n    // Creamos la ArrayList que va a ser devuelta\n    ArrayList contenido = new ArrayList();\n    // A\u00f1adimos los atributos de la clase\n    DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"d/MM/yyyy\");\n    String stringFecha = formato.format(this.fechaNacim);\n    contenido.add(this.nombre);\n    contenido.add(this.apellidos);\n    contenido.add(stringFecha);\n    // Devolvemos la ArrayList\n    return contenido;\n}\n</code></pre> <p>Y por \u00faltimo el m\u00e9todo <code>devolverContenidoString</code>:</p> Java<pre><code>@Override\npublic String devolverContenidoString() {\n    DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"d/MM/yyyy\");\n    String stringFecha = formato.format(this.fechaNacim);\n    String contenido = \"{\" + this.nombre + \", \" + this.apellidos + \", \" + stringFecha + \"}\";\nreturn contenido;\n}\n</code></pre> <p>2) Clase <code>Alumno</code>.</p> <p>Esta clase hereda de la clase Persona, de manera que heredar\u00e1 los tres m\u00e9todos anteriores. Tan solo habr\u00e1 que redefinirlos para que, aprovechando el c\u00f3digo ya escrito en la superclase, se a\u00f1ada la funcionalidad espec\u00edfica que aporta esta subclase.</p> Java<pre><code>public class Alumno extends Persona {\n...\n</code></pre> <p>Como puedes observar no ha sido necesario incluir el <code>implements Imprimible</code>, pues el <code>extends Persona</code> lo lleva impl\u00edcito dado que <code>Persona</code> ya implementaba ese interfaz. Lo que haremos entonces ser\u00e1 llamar al m\u00e9todo que estamos redefiniendo utilizando la referencia a la superclase <code>super</code>.</p> <p>El m\u00e9todo <code>devolverContenidoHashMap</code> podr\u00eda quedar, por ejemplo, as\u00ed:</p> Java<pre><code>@Override\npublic HashMap devolverContenidoHashMap() {\n    // Llamada al m\u00e9todo de la superclase\n    HashMap contenido = super.devolverContenidoHashMap();\n    // A\u00f1adimos los atributos espec\u00edficos de la clase\n    contenido.put(\"grupo\", this.grupo);\n    contenido.put(\"notaMedia\", this.notaMedia);\n    // Devolvemos la HashMap rellena\n    return contenido;\n}\n</code></pre> <p>3) Clase <code>Profesor</code>. En este caso habr\u00eda que proceder exactamente de la misma manera que con la clase Alumno: redefiniendo los m\u00e9todos de la interfaz <code>Imprimible</code> para a\u00f1adir la funcionalidad espec\u00edfica que aporta esta subclase, en este caso mostraremos la redifinici\u00f3n del m\u00e9todo <code>devolverContenidoArrayList()</code>:</p> Java<pre><code>@Override\npublic ArrayList devolverContenidoArrayList() {\n    // Llamada al m\u00e9todo de la superclase\n    ArrayList contenido = super.devolverContenidoArrayList();\n    // A\u00f1adimos los atributos espec\u00edficos de la clase\n    contenido.add(this.especialidad);\n    contenido.add(this.salario);\n    // Devolvemos la ArrayList\n    return contenido;\n}\n</code></pre> <p>y la redefinici\u00f3n del m\u00e9todo <code>devolverContenidoString()</code>:</p> Java<pre><code>@Override\npublic String devolverContenidoString() {\n    // Llamada al m\u00e9todo de la superclase\n    String contenido = super.devolverContenidoString();\n    //Eliminamos el \u00faltimo car\u00e1cter, que contiene una llave de cierre.\n    contenido = contenido.substring(0, contenido.length() - 1);\n    contenido = contenido + \", \" + this.especialidad + \", \" + this.salario + \"}\";\n    // Devolvemos el String creado.\n    return contenido;\n}\n</code></pre>"},{"location":"ud08/ud0805/#un-ejemplo-de-implementacion-de-interfaces-la-interfaz-series","title":"Un ejemplo de implementaci\u00f3n de interfaces: la interfaz Series","text":"<p>En la forma tradicional de una interfaz, los m\u00e9todos se declaran utilizando solo su tipo de devoluci\u00f3n y firma. Son, esencialmente, m\u00e9todos abstractos. Por lo tanto, cada clase que incluye dicha interfaz debe implementar todos sus m\u00e9todos.</p> <p>A tener en cuenta</p> <p>En una interfaz, los m\u00e9todos son impl\u00edcitamente p\u00fablicos.</p> <p>A tener en cuenta</p> <p>Las variables declaradas en una interfaz no son variables de instancia. En cambio, son impl\u00edcitamente public, final, y static, y deben inicializarse. Por lo tanto, son esencialmente constantes.</p> <p>Aqu\u00ed hay un ejemplo de una definici\u00f3n de interfaz. Especifica la interfaz a una clase que genera una serie de n\u00fameros.</p> Java<pre><code>public interface Series {\n  int getSiguiente(); //Retorna el siguiente n\u00famero de la serie\n  void reiniciar();   //Reinicia\n  void setComenzar(int x); //Establece un valor inicial\n}\n</code></pre> <p>Esta interfaz se declara p\u00fablica para que pueda ser implementada por c\u00f3digo en cualquier paquete.</p> <p>Los m\u00e9todos que implementan una interfaz deben declararse p\u00fablicos. Adem\u00e1s, el tipo del m\u00e9todo de implementaci\u00f3n debe coincidir exactamente con el tipo especificado en la definici\u00f3n de la interfaz.</p> <p>Aqu\u00ed hay un ejemplo que implementa la interfaz de <code>Series</code> mostrada anteriormente. Crea una clase llamada <code>DeDos</code>, que genera una serie de n\u00fameros, cada uno mayor que el anterior.</p> Java<pre><code>class DeDos implements Series {\n  int iniciar;\n  int valor;\n\n  DeDos(){\n    iniciar = 0;\n    valor = 0;\n  }\n\n  public int getSiguiente() {\n    valor += 2;\n    return valor;\n  }\n\n  public void reiniciar() {\n    valor = iniciar;\n  }\n\n  public void setComenzar(int x) {\n    iniciar = x;\n    valor = x;\n  }\n}\n</code></pre> <p>Observa que los m\u00e9todos <code>getSiguiente()</code>, <code>reiniciar()</code> y <code>setComenzar()</code> se declaran utilizando el especificador de acceso p\u00fablico (<code>public</code>). Esto es necesario. Siempre que implementes un m\u00e9todo definido por una interfaz, debe implementarse como p\u00fablico porque todos los miembros de una interfaz son impl\u00edcitamente p\u00fablicos.</p> <p>Aqu\u00ed hay una clase que demuestra <code>DeDos</code>:</p> Java<pre><code>class SeriesDemo {\n  public static void main(String[] args) {\n    DeDos ob = new DeDos();\n    for (int i=0; i&lt;5; i++){\n      System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n    }\n    System.out.println(\"\\nReiniciando\");\n    ob.reiniciar();\n    for (int i=0; i&lt;5; i++){\n      System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n    }\n    System.out.println(\"\\nIniciando en 100\");\n    ob.setComenzar(100);\n    for (int i=0; i&lt;5; i++){\n      System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n    }\n  }\n}\n</code></pre> <p>Salida:</p> Bash<pre><code>Siguiente valor es: 2\nSiguiente valor es: 4\nSiguiente valor es: 6\nSiguiente valor es: 8\nSiguiente valor es: 10\nReiniciando\nSiguiente valor es: 2\nSiguiente valor es: 4\nSiguiente valor es: 6\nSiguiente valor es: 8\nSiguiente valor es: 10\nIniciando en 100\nSiguiente valor es: 102\nSiguiente valor es: 104\nSiguiente valor es: 106\nSiguiente valor es: 108\nSiguiente valor es: 110\n</code></pre> <p>Est\u00e1 permitido y es com\u00fan para las clases que implementan interfaces definir miembros adicionales propios. Por ejemplo, la siguiente versi\u00f3n de <code>DeDos</code> agrega el m\u00e9todo <code>getAnterior()</code>, que devuelve el valor anterior:</p> Java<pre><code>class DeDos implements Series {\n    int iniciar;\n    int valor;\n    int anterior;\n\n    DeDos(){\n        iniciar = 0;\n        valor = 0;\n    }\n\n    public int getSiguiente() {\n        anterior = valor;\n        valor += 2;\n        return valor;\n    }\n\n    public void reiniciar() {\n        valor = iniciar;\n        anterior = valor-2;\n    }\n\n    public void setComenzar(int x) {\n        iniciar = x;\n        valor = x;\n        anterior = x-2;\n    }\n\n    //A\u00f1adiendo un m\u00e9todo que no est\u00e1 definido en Series\n    int getAnterior(){\n        return anterior;\n    }\n}\n</code></pre> <p>Observa que la adici\u00f3n de <code>getAnterior()</code> requiri\u00f3 un cambio en las implementaciones de los m\u00e9todos definidos por <code>Series</code>. Sin embargo, dado que la interfaz con esos m\u00e9todos permanece igual, el cambio es continuo y no rompe el c\u00f3digo preexistente. Esta es una de las ventajas de las interfaces.</p> <p>Como se explic\u00f3, cualquier cantidad de clases puede implementar una interfaz. Por ejemplo, aqu\u00ed hay una clase llamada <code>DeTres</code> que genera una serie que consta de m\u00faltiplos de tres:</p> Java<pre><code>public class DeTres implements Series{\n    int iniciar;\n    int valor;\n\n    DeTres(){\n        iniciar = 0;\n        valor = 0;\n    }\n\n    public int getSiguiente() {\n        valor += 3;\n        return valor;\n    }\n\n    public void reiniciar() {\n        valor = iniciar;\n    }\n\n    public void setComenzar(int x) {\n        iniciar = x;\n        valor = x;\n    }\n}\n</code></pre>"},{"location":"ud08/ud0805/#simulacion-de-la-herencia-multiple-mediante-el-uso-de-interfaces","title":"Simulaci\u00f3n de la herencia m\u00faltiple mediante el uso de interfaces","text":"<p>Una interfaz no tiene espacio de almacenamiento asociado (no se van a declarar objetos de un tipo de interfaz), es decir, no tiene implementaci\u00f3n.</p> <p>En algunas ocasiones es posible que interese representar la situaci\u00f3n de que \"una clase X es de tipo A, de tipo B, y de tipo C\", siendo A, B, C clases disjuntas (no heredan unas de otras). Hemos visto que ser\u00eda un caso de herencia m\u00faltiple que Java no permite.</p> <p>Para poder simular algo as\u00ed, podr\u00edas definir tres interfaces A, B, C que indiquen los comportamientos (m\u00e9todos) que se deber\u00edan tener seg\u00fan se pertenezca a una supuesta clase A, B, o C, pero sin implementar ning\u00fan m\u00e9todo concreto ni atributos de objeto (s\u00f3lo interfaz).</p> <p>De esta manera la clase X podr\u00eda a la vez:</p> <ol> <li>Implementar las interfaces A, B, C, que la dotar\u00edan de los comportamientos que deseaba heredar de las clases A, B, C.</li> <li>Heredar de otra clase Y, que le proporcionar\u00eda determinadas caracter\u00edsticas dentro de su taxonom\u00eda o jerarqu\u00eda de objeto (atributos, m\u00e9todos implementados y m\u00e9todos abstractos).</li> </ol> <p>En el ejemplo que hemos visto de las interfaces <code>Depredador</code> y <code>Presa</code>, tendr\u00edas un ejemplo de esto: la clase <code>Rana</code>, que es subclase de <code>Anfibio</code>, implementa una serie de comportamientos propios de un <code>Depredador</code> y, a la vez, otros m\u00e1s propios de una <code>Presa</code>. Esos comportamientos (m\u00e9todos) no forman parte de la superclase <code>Anfibio</code>, sino de las interfaces. Si se decide que la clase <code>Rana</code> debe de llevar a cabo algunos otros comportamientos adicionales, podr\u00edan a\u00f1adirse a una nueva interfaz y la clase <code>Rana</code> implementar\u00eda una tercera interfaz.</p> <p></p> <p>De este modo, con el mecanismo \"una herencia pero varias interfaces\", podr\u00edan conseguirse resultados similares a los obtenidos con la herencia m\u00faltiple.</p> <p>Ahora bien, del mismo modo que suced\u00eda con la herencia m\u00faltiple, puede darse el problema de la colisi\u00f3n de nombres al implementar dos interfaces que tengan un m\u00e9todo con el mismo identificador. En tal caso puede suceder lo siguiente:</p> <ul> <li>Si los dos m\u00e9todos tienen diferentes par\u00e1metros no habr\u00e1 problema aunque tengan el mismo nombre pues se realiza una sobrecarga de m\u00e9todos.</li> <li>Si los dos m\u00e9todos tienen un valor de retorno de un tipo diferente, se producir\u00e1 un error de compilaci\u00f3n (al igual que sucede en la sobrecarga cuando la \u00fanica diferencia entre dos m\u00e9todos es \u00e9sa).</li> </ul> <p>Si los dos m\u00e9todos son exactamente iguales en identificador, par\u00e1metros y tipo devuelto, entonces solamente se podr\u00e1 implementar uno de los dos m\u00e9todos. En realidad se trata de un solo m\u00e9todo pues ambos tienen la misma interfaz (mismo identificador, mismos par\u00e1metros y mismo tipo devuelto).</p> <p>A tener en cuenta</p> <p>La utilizaci\u00f3n de nombres id\u00e9nticos en diferentes interfaces que pueden ser implementadas a la vez por una misma clase puede causar, adem\u00e1s del problema de la colisi\u00f3n de nombres, dificultades de legibilidad en el c\u00f3digo, pudiendo dar lugar a confusiones. Si es posible intenta evitar que se produzcan este tipo de situaciones.</p>"},{"location":"ud08/ud0805/#herencia-de-interfaces","title":"Herencia de interfaces","text":"<p>Las interfaces, al igual que las clases, tambi\u00e9n permiten la herencia. Para indicar que una interfaz hereda de otra se indica nuevamente con la palabra reservada <code>extends</code>. Pero en este caso s\u00ed se permite la herencia m\u00faltiple de interfaces. Si se hereda de m\u00e1s de una interfaz se indica con la lista de interfaces separadas por comas.</p> <p>Por ejemplo, dadas las interfaces <code>InterfazUno</code> e <code>InterfazDos</code>:</p> Java<pre><code>public interface InterfazUno {\n  // M\u00e9todos y constantes de la interfaz Uno\n}\n\npublic interface InterfazDos {\n  // M\u00e9todos y constantes de la interfaz Dos\n}\n</code></pre> <p>Podr\u00eda definirse una nueva interfaz que heredara de ambas:</p> Java<pre><code>public interface InterfazCompleja extends InterfazUno, InterfazDos {\n  // M\u00e9todos y constantes de la interfaz compleja\n} \n</code></pre> \u00bfPuede una clase implementar varias interfaces diferentes a la vez? <p>Observa el siguiente esquema UML:  Las clases <code>Kangaroo</code> y <code>Lion</code> implementan varias clases:     - <code>Kangaroo</code> : <code>Herbivore</code>, <code>TwoLeggedMammal</code> y <code>Animal</code>     - <code>Lion</code> : <code>Animal</code>, <code>FourLeggedMammal</code>, <code>Hunter</code> y <code>Carnivore</code></p> Ejemplo 5.5 <p>\u00bfPuede una interfaz heredar de varias interfaces diferentes a la vez?</p> <p>Observa el anterior esquema UML: Lass interfaces <code>Human</code> y <code>Omnivore</code> heredan de varias interfaces: - <code>Human</code> : de <code>TwoLeggedMammal</code>, <code>Omnivore</code>, <code>Mammal</code> y <code>Hunter</code> - <code>Omnivore</code> : <code>Herbivore</code> y <code>Carnivore</code>.</p> Ejemplo 5.6 <p>Supongamos una situaci\u00f3n en la que nos interesa dejar constancia de que ciertas clases deben implementar una funcionalidad te\u00f3rica determinada, diferente en cada clase afectada. Estamos hablando, pues, de la definici\u00f3n de un m\u00e9todo te\u00f3rico que algunas clases deber\u00e1n implementar. Un ejemplo real puede ser el m\u00e9todo <code>calculoImporteJubilacion()</code> aplicable, de manera diferente, a muchas tipolog\u00edas de trabajadores y, por tanto, podr\u00edamos pensar en dise\u00f1ar una clase <code>Trabajador</code> en que uno de sus m\u00e9todos fuera <code>calculoImporteJubilacion()</code>. Esta soluci\u00f3n es v\u00e1lida si estamos dise\u00f1ando una jerarqu\u00eda de clases a partir de la clase <code>Trabajador</code> de la que cuelguen las clases correspondientes a las diferentes tipolog\u00edas de trabajadores (metal\u00fargicos, hosteler\u00eda, inform\u00e1ticos, profesores...). Adem\u00e1s, disponemos del concepto de clase abstracta que cada subclase implemente obligatoriamente el m\u00e9todo <code>calculoImporteJubilacion()</code>. Pero, \u00bfy si resulta que ya tenemos las clases <code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> en otras jerarqu\u00edas de clases? La soluci\u00f3n consiste en hacer que estas clases derivaran de la clase <code>Trabajador</code>, sin abandonar la derivaci\u00f3n que pudieran tener, ser\u00eda factible en lenguajes orientados a objetos que soportaran la herencia m\u00faltiple, pero esto no es factible en el lenguaje Java. Para superar esta limitaci\u00f3n, Java proporciona las interfaces.</p> <p>Una interfaz es una maqueta contenedora de una lista de m\u00e9todos abstractos y datos miembro (de tipos primitivos o de clases). Los atributos, si existen, son impl\u00edcitamente consideradas <code>static</code> y <code>final</code>. Los m\u00e9todos, si existen, son impl\u00edcitamente considerados <code>public</code>.</p> <p>Para entender en qu\u00e9 nos pueden ayudar las interface, necesitamos saber:     - Una interfaz puede ser implementada por m\u00faltiples clases, de manera similar a como una clase puede ser superclase de m\u00faltiples clases.     - Las clases que implementan una interfaz est\u00e1n obligadas a sobrescribir todos los m\u00e9todos definidos en la interfaz. Si la definici\u00f3n de alguno de los m\u00e9todos a sobrescribir coincide con la definici\u00f3n de alg\u00fan m\u00e9todo heredado, este desaparece de la clase.     - Una clase puede implementar m\u00faltiples interfaces, a diferencia de la derivaci\u00f3n, que s\u00f3lo se permite una \u00fanica clase base.     - Una interfaz introduce un nuevo tipo de dato, por la que nunca habr\u00e1 ninguna instancia, pero s\u00ed objetos usuarios de la interfaz (objetos de las clases que implementan la interfaz). Todas las clases que implementan una interfaz son compatibles con el tipo introducido por la interfaz.     - Una interfaz no proporciona ninguna funcionalidad a un objeto (ya que la clase que implementa la interfaz es la que debe definir la funcionalidad de todos los m\u00e9todos), pero en cambio proporciona la posibilidad de formar parte de la funcionalidad de otros objetos (pas\u00e1ndola por par\u00e1metro en m\u00e9todos de otras clases).     - La existencia de las interfaces posibilita la existencia de una jerarqu\u00eda de tipo (que no debe confundirse con la jerarqu\u00eda de clases) que permite la herencia m\u00faltiple.     - Una interfaz no se puede instanciar, pero s\u00ed se puede hacer referencia.</p> <p>As\u00ed, si <code>I</code> es una interfaz y <code>C</code> es una clase que implementa la interfaz, se pueden declarar referencias al tipo <code>I</code> que apunten objetos de <code>C</code>:</p> Java<pre><code>I obj = new C (&lt;par\u00e1metros&gt;);\n</code></pre> <ul> <li>Las interfaces pueden heredar de otras interfaces y, a diferencia de la derivaci\u00f3n de clases, pueden heredar de m\u00e1s de una interfaz.</li> </ul> <p>As\u00ed, si dise\u00f1amos la interfaz <code>Trabajador</code>, podemos hacer que las clases ya existentes (<code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> ...) la implementen y, por tanto, los objetos de estas clases, adem\u00e1s de ser objetos de las superclases respectivas, pasan a ser considerados objetos usuarios del tipo <code>Trabajador</code>. Con esta actuaci\u00f3n nos veremos obligados a implementar el m\u00e9todo <code>calculoImporteJubilacion()</code> a todas las clases que implementen la interfaz.</p> <p>Alguien no experimentado en la gesti\u00f3n de interfaces puede pensar: \u00bfpor qu\u00e9 tanto revuelo con las interfaces si hubi\u00e9ramos podido dise\u00f1ar directamente un m\u00e9todo llamado <code>calculoImporteJubilacion()</code> en las clases afectadas sin necesidad de definir ninguna interfaz?</p> <p>La respuesta radica en el hecho de que la declaraci\u00f3n de la interfaz lleva impl\u00edcita la declaraci\u00f3n del tipo <code>Trabajador</code> y, por tanto, podremos utilizar los objetos de todas las clases que implementen la interfaz en cualquier m\u00e9todo de cualquier clase que tenga alg\u00fan argumento referencia al tipo <code>Trabajador</code> como, por ejemplo, en un hipot\u00e9tico m\u00e9todo de una hipot\u00e9tica clase llamada Hacienda:</p> Java<pre><code>public void enviarBorradorIRPF(Trabajador t) {...}\n</code></pre> <p>Por el hecho de existir la interfaz <code>Trabajador</code>, todos los objetos de las clases que la implementan (<code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> ...) se pueden pasar como par\u00e1metro en las llamadas al m\u00e9todo <code>enviarBorradorIRPF(Trabajador t)</code>.</p> <p>La sintaxis para declarar una interfaz es:</p> Java<pre><code>[public] interface &lt;NombreInterfaz&gt; [extends &lt;Nombreinterfaz1&gt;, &lt;Nombreinterfaz2&gt;...] {\n    &lt;CuerpoInterfaz&gt;\n}\n</code></pre> <p>Las interfaces tambi\u00e9n se pueden asignar a un paquete. La inexistencia del modificador de acceso p\u00fablico hace que la interfaz sea accesible a nivel del paquete.</p> <p>Para los nombres de las interfaces, se aconseja seguir el mismo criterio que para los nombres de las clases. </p> <p>En la documentaci\u00f3n de Java, las interfaces se identifican r\u00e1pidamente entre las clases porque est\u00e1n en cursiva.</p> <p>El cuerpo de la interfaz es la lista de m\u00e9todos y/o constantes que contiene la interfaz. Para las constantes no hay que indicar que son <code>static</code> y <code>final</code> y para los m\u00e9todos no hay que indicar que son <code>public</code>. Estas caracter\u00edsticas se asignan impl\u00edcitamente.</p> <p>La sintaxis para declarar una clase que implemente una o m\u00e1s interfaces es:</p> Java<pre><code>[final] [public] class &lt;NombreClase&gt; [extends &lt;NombreClaseBase&gt;] implements &lt;NombreInterfaz1&gt;, &lt;NomInterfaz2&gt;... {\n    &lt;CuerpoDeLaClase&gt;\n}\n</code></pre> <p>Los m\u00e9todos de las interfaces a implementar en la clase deben ser obligatoriamente de acceso p\u00fablico.</p> <p>Por \u00faltimo, comentar que, como por definici\u00f3n todos los datos miembro que se definen en una interfaz son <code>static</code> y <code>final</code>, y dado que las interfaz no se pueden instanciar, tambi\u00e9n resultan una buena herramienta para implantar grupos de constantes.</p> <p>As\u00ed, por ejemplo:</p> Java<pre><code>public interface DiasSemana {\n    int LUNES = 1, MARTES = 2, MIERCOLES = 3, JUEVES = 4;\n    int VIERNES = 5, SABADO = 6, DOMINGO = 7;\n    String[] NOMBRES_DIAS = {\"\", \"lunes\", \"martes\", \"mi\u00e9rcoles\", \"jueves\", \"viernes\", \"s\u00e1bado\", \"domingo\"};\n}\n</code></pre> <p>Esta definici\u00f3n nos permite utilizar las constantes declaradas en cualquier clase que implemente la interfaz, de manera tan simple como:</p> <p>Java<pre><code>System.out.println (DiasSemana.NOMBRES_DIAS[LUNES]);\n</code></pre> Ejemplo de dise\u00f1o de interfaz e implementaci\u00f3n en una clase Se presentan un par de interfaces que incorporan datos (de tipo primitivo y de referencia en clase) y m\u00e9todos y una clase que las implementa. En la declaraci\u00f3n de la clase se ve que s\u00f3lo implementa la interfaz <code>B</code>, pero como esta interfaz deriva de la interfaz <code>A</code> resulta que la clase est\u00e1 implementando las dos interfaces.</p> Java<pre><code>import java.util.Date;\n\ninterface A {\n    Date ULTIMA_CREACION = new Date(0, 0, 1);\n    void metodoA();\n}\n\ninterface B extends A {\n    int VALOR_B = 20;\n    // 1 \u22121 \u22121900\n    void metodoB();\n}\n\npublic class Anexo5Interfaces implements B {\n\n    private long b;\n    private Date fechaCreacion = new Date();\n\n    public Anexo5Interfaces(int factor) {\n        b = VALOR_B * factor;\n        ULTIMA_CREACION.setTime(fechaCreacion.getTime());\n}\n\n@Override\npublic void metodoA() {\n    System.out.println(\"En metodoA, ULTIMA_CREACION = \" + ULTIMA_CREACION);\n}\n\n@Override\npublic void metodoB() {\n    System.out.println(\"En metodoB, b = \" + b);\n}\n\npublic static void main(String args[]) {\n    System.out.println(\"Inicialmente, ULTIMA_CREACION = \" + ULTIMA_CREACION);\n    Anexo5Interfaces obj = new Anexo5Interfaces(5);\n    obj.metodoA();\n    obj.metodoB();\n    A pa = obj;\n    B pb = obj;\n}\n}\n</code></pre> <p>Si lo ejecutamos obtendremos:</p> Bash<pre><code>Inicialmente, ULTIMA_CREACION = Mon Jan 01 00:00:00 CET 1900\nEn metodoA, ULTIMA_CREACION = Thu Aug 26 16:09:47 CEST 2021\nEn metodoB, b = 100\n</code></pre> <p>El ejemplo sirve para ilustrar algunos puntos:</p> <ul> <li>Comprobamos que los datos miembro de las interfaces son <code>static</code>, ya que en el m\u00e9todo <code>main()</code> hacemos referencia al dato miembro <code>ULTIMA_CREACION</code> sin indicar ning\u00fan objeto de la clase.</li> <li>Si hubi\u00e9ramos intentado modificar los datos <code>VALOR_B</code> o <code>ULTIMA_CREACION</code> no habr\u00edamos podido porque es final, pero en cambio s\u00ed podemos modificar el contenido del objeto <code>Date</code> apuntado por <code>ULTIMA_CREACION</code>, que corresponde al momento temporal de la \u00faltima creaci\u00f3n de un objeto ya cada nueva creaci\u00f3n se actualiza su contenido.</li> <li>En las dos \u00faltimas instrucciones del m\u00e9todo <code>main()</code> vemos que podemos declarar variables <code>pa</code> y <code>pb</code> de las interfaces y utilizarlas para hacer referencia a objetos de la clase <code>EjemploInterfaz()</code>.</li> </ul>"},{"location":"ud08/ud0806/","title":"8.6 Polimorfismo","text":"<p>El polimorfismo es otro de los grandes pilares sobre los que se sustenta la Programaci\u00f3n Orientada a Objetos (junto con la encapsulaci\u00f3n y la herencia). Se trata nuevamente de otra forma m\u00e1s de establecer diferencias entre interfaz e implementaci\u00f3n, es decir, entre el qu\u00e9 y el c\u00f3mo. </p> <p>La encapsulaci\u00f3n te ha permitido agrupar caracter\u00edsticas (atributos) y comportamientos (m\u00e9todos) dentro de una misma unidad (clase), pudiendo darles un mayor o menor componente de visibilidad, y permitiendo separar al m\u00e1ximo posible la interfaz de la implementaci\u00f3n.</p> <p>Por otro lado la herencia te ha proporcionado la posibilidad de tratar a los objetos como pertenecientes a una jerarqu\u00eda de clases. Esta capacidad va a ser fundamental a la hora de poder manipular muchos posibles objetos de clases diferentes como si fueran de la misma clase (polimorfismo).</p> <p>El polimorfismo te va a permitir mejorar la organizaci\u00f3n y la legibilidad del c\u00f3digo as\u00ed como la posibilidad de desarrollar aplicaciones que sean m\u00e1s f\u00e1ciles de ampliar a la hora de incorporar nuevas funcionalidades. Si la implementaci\u00f3n y la utilizaci\u00f3n de las clases es lo suficientemente gen\u00e9rica y extensible ser\u00e1 m\u00e1s sencillo poder volver a este c\u00f3digo para incluir nuevos requerimientos.</p>"},{"location":"ud08/ud0806/#concepto-de-polimorfismo","title":"Concepto de polimorfismo","text":"<p>El polimorfismo consiste en la capacidad de poder utilizar una referencia a un objeto de una determinada clase como si fuera de otra clase (en concreto una subclase). Es una manera de decir que una clase podr\u00eda tener varias (poli) formas (morfismo).</p> <p>Un m\u00e9todo \"polim\u00f3rfico\" ofrece la posibilidad de ser distinguido (saber a qu\u00e9 clase pertenece) en tiempo de ejecuci\u00f3n en lugar de en tiempo de compilaci\u00f3n. Para poder hacer algo as\u00ed es necesario utilizar m\u00e9todos que pertenecen a una superclase y que en cada subclase se implementan de una forma en particular. En tiempo de compilaci\u00f3n se invocar\u00e1 al m\u00e9todo sin saber exactamente si ser\u00e1 el de una subclase u otra (pues se est\u00e1 invocando al de la superclase). S\u00f3lo en tiempo de ejecuci\u00f3n (una vez instanciada una u otra subclase) se conocer\u00e1 realmente qu\u00e9 m\u00e9todo (de qu\u00e9 subclase) es el que finalmente va a ser invocado.</p> <p>Esta forma de trabajar te va a permitir hasta cierto punto \"desentenderte\" del tipo de objeto espec\u00edfico (subclase) para centrarte en el tipo de objeto gen\u00e9rico (superclase). De este modo podr\u00e1s manipular objetos hasta cierto punto \"desconocidos\" en tiempo de compilaci\u00f3n y que s\u00f3lo durante la ejecuci\u00f3n del programa se sabr\u00e1 exactamente de qu\u00e9 tipo de objeto (subclase) se trata.</p> <p>A tener en cuenta</p> <p>El polimorfismo ofrece la posibilidad de que toda referencia a un objeto de una superclase pueda tomar la forma de una referencia a un objeto de una de sus subclases. Esto te va a permitir escribir programas que procesen objetos de clases que formen parte de la misma jerarqu\u00eda como si todos fueran objetos de sus superclases.</p> <p>A tener en cuenta</p> <p>El polimorfismo puede llevarse a cabo tanto con superclases (abstractas o no) como con interfaces.</p> <p>Dada una superclase X, con un m\u00e9todo m, y dos subclases A y B, que redefinen ese m\u00e9todo m, podr\u00edas declarar un objeto O de tipo X que durante la ejecuci\u00f3n podr\u00e1 ser de tipo A o de tipo B (algo desconocido en tiempo de compilaci\u00f3n). Esto significa que al invocarse el m\u00e9todo m de X (superclase), se estar\u00e1 en realidad invocando al m\u00e9todo m de A o de B (alguna de sus subclases). Por ejemplo:</p> <p>Java<pre><code>// Declaraci\u00f3n de una referencia a un objeto de tipo X\nClaseX obj; // Objeto de tipo X (superclase)\n...\n\n// Zona del programa donde se instancia un objeto de tipo A (subclase) y se le asigna a la referencia obj.\n// La variable obj adquiere la forma de la subclase A.\nobj = new ClaseA();\n...\n\n// Otra zona del programa.\n// Aqu\u00ed se instancia un objeto de tipo B (subclase) y se le asigna a la referencia obj.\n// La variable obj adquiere la forma de la subclase B.\nobj = new ClaseB();\n...\n\n// Zona donde se utiliza el m\u00e9todo m sin saber realmente qu\u00e9 subclase se est\u00e1 utilizando.\n// (S\u00f3lo se sabr\u00e1 durante la ejecuci\u00f3n del programa)\n\nobj.m()\n // Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de A o de B).\n...\n</code></pre> Imagina que est\u00e1s trabajando con las clases <code>Alumno</code> y <code>Profesor</code> y que en determinada zona del c\u00f3digo podr\u00edas tener objetos, tanto de un tipo como de otro, pero eso s\u00f3lo se sabr\u00e1 seg\u00fan vaya discurriendo la ejecuci\u00f3n del programa. En algunos casos, es posible que un determinado objeto pudiera ser de la clase <code>Alumno</code> y en otros de la clase <code>Profesor</code>, pero en cualquier caso ser\u00e1n objetos de la clase <code>Persona</code>. Eso significa que la llamada a un m\u00e9todo de la clase <code>Persona</code> (por ejemplo <code>devolverContenidoString</code>) en realidad ser\u00e1 en unos casos a un m\u00e9todo (con el mismo nombre) de la clase <code>Alumno</code> y, en otros, a un m\u00e9todo (con el mismo nombre tambi\u00e9n) de la clase <code>Profesor</code>. Esto ser\u00e1 posible hacerlo gracias a la ligadura din\u00e1mica.</p>"},{"location":"ud08/ud0806/#ligadura-dinamica","title":"Ligadura din\u00e1mica","text":"<p>La conexi\u00f3n que tiene lugar durante una llamada a un m\u00e9todo suele ser llamada ligadura (conexi\u00f3n o vinculaci\u00f3n que tiene lugar durante una llamada a un m\u00e9todo para saber qu\u00e9 c\u00f3digo debe ser ejecutado. Puede ser est\u00e1tica o din\u00e1mica, vinculaci\u00f3n o enlace (en ingl\u00e9s binding). Si esta vinculaci\u00f3n se lleva a cabo durante el proceso de compilaci\u00f3n, se le suele llamar ligadura est\u00e1tica (la vinculaci\u00f3n que se produce en la llamada a un m\u00e9todo con la clase a la que pertenece ese m\u00e9todo se realiza en tiempo de compilaci\u00f3n. Es decir, que antes de generar el c\u00f3digo ejecutable se conoce exactamente el m\u00e9todo (a qu\u00e9 clase pertenece) que ser\u00e1 llamado. Tambi\u00e9n conocido como vinculaci\u00f3n temprana). En los lenguajes tradicionales, no orientados a objetos, \u00e9sta es la \u00fanica forma de poder resolver la ligadura (en tiempo de compilaci\u00f3n). Sin embargo, en los lenguajes orientados a objetos existe otra posibilidad: la ligadura din\u00e1mica (la vinculaci\u00f3n que se produce en la llamada a un m\u00e9todo con la clase a la que pertenece ese m\u00e9todo se realiza en tiempo de ejecuci\u00f3n. Es decir, que al generar el c\u00f3digo ejecutable no se conoce exactamente el m\u00e9todo (a qu\u00e9 clase pertenece) que ser\u00e1 llamado. S\u00f3lo se sabr\u00e1 cuando el programa est\u00e9 en ejecuci\u00f3n. Tambi\u00e9n conocida como vinculaci\u00f3n tard\u00eda, enlace tard\u00edo o late binding.</p> <p>La ligadura din\u00e1mica hace posible que sea el tipo de objeto instanciado (obtenido mediante el constructor finalmente utilizado para crear el objeto) y no el tipo de la referencia (el tipo indicado en la declaraci\u00f3n de la variable que apuntar\u00e1 al objeto) lo que determine qu\u00e9 versi\u00f3n del m\u00e9todo va a ser invocada. El tipo de objeto al que apunta la variable de tipo referencia s\u00f3lo podr\u00e1 ser conocido durante la ejecuci\u00f3n del programa y por eso el polimorfismo necesita la ligadura din\u00e1mica. </p> <p>En el ejemplo anterior de la clase X y sus subclases A y B, la llamada al m\u00e9todo m s\u00f3lo puede resolverse mediante ligadura din\u00e1mica, pues es imposible saber en tiempo de compilaci\u00f3n si el m\u00e9todo m que debe ser invocado ser\u00e1 el definido en la subclase A o el definido en la subclase B:</p> Java<pre><code>//Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de A o de B). \nobj.m() // Esta llamada ser\u00e1 resuelta en tiempo de ejecuci\u00f3n (ligadura din\u00e1mica)\n</code></pre> Revisa con cuidado el siguiente ejemplo 2 <p>Imag\u00ednate una clase que represente a instrumento musical gen\u00e9rico (<code>Instrumento</code>) y dos subclases que representen tipos de instrumentos espec\u00edficos (por ejemplo <code>Flauta</code> y <code>Piano</code>). Todas las clases tendr\u00e1n un m\u00e9todo <code>tocarNota</code>, que ser\u00e1 espec\u00edfico para cada subclase.</p> <p>Haz un peque\u00f1o programa de ejemplo en Java que utilice el polimorfismo (referencias a la superclase que se convierten en instancias espec\u00edficas de subclases) y la ligadura din\u00e1mica (llamadas a un m\u00e9todo que a\u00fan no est\u00e1n resueltas en tiempo de compilaci\u00f3n) con estas clases que representan instrumentos musicales. Puedes implementar el m\u00e9todo <code>tocarNota</code> mediante la escritura de un mensaje en pantalla.</p> <p>La clase Instrumento podr\u00eda tener un \u00fanico m\u00e9todo (<code>tocarNota</code>):</p> Java<pre><code>public abstract class Instrumento {\n\npublic void tocarNota(String nota) {\n    System.out.format(\"Instrumento: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> <p>En el caso de las clases <code>Piano</code> y <code>Flauta</code> puede ser similar, heredando de Instrumento y redefiniendo el m\u00e9todo tocarNota:</p> Java<pre><code>public class Flauta extends Instrumento {\n\n@Override\npublic void tocarNota(String nota) {\n    System.out.format(\"Flauta: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> Java<pre><code>public class Piano extends Instrumento {\n\n@Override\npublic void tocarNota(String nota) {\n    System.out.format(\"Piano: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> <p>Creamos una clase para comprobar su funcionamiento <code>EjemploUso</code>:</p> Java<pre><code>import java.util.Scanner;\n\npublic class EjemploUso {\n\n    public static void main(String[] args) {\n        Scanner teclado = new Scanner(System.in);\n        System.out.print(\"Deseas un Piano o una Flauta (p o f)?: \");\n        char respuesta = teclado.nextLine().toLowerCase().charAt(0);\n\n        Instrumento instrumento1; // Ejemplo de objeto polim\u00f3rfico (podr\u00e1 ser Piano o Flauta)\n        if (respuesta == 'p') {\n            // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Piano)\n            instrumento1 = new Piano();\n        } else {\n            // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Flauta)\n            instrumento1 = new Flauta();\n        }\n        // Interpretamos una nota con el objeto instrumento1\n        // No sabemos si se ejecutar\u00e1 el m\u00e9todo tocarNota de Piano o de Flauta (depender\u00e1 de la ejecuci\u00f3n)\n        instrumento1.tocarNota(\"do\"); // Ejemplo de ligadura din\u00e1mica (tiempo de ejecuci\u00f3n)\n    }\n}\n</code></pre> <p>A la hora de declarar una referencia a un objeto de tipo instrumento, utilizamos la superclase (Instrumento):</p> Java<pre><code>Instrumento instrumento1; // Ejemplo de objeto polim\u00f3rfico (podr\u00e1 ser Piano o Flauta)\n</code></pre> <p>Sin embargo, a la hora de instanciar el objeto, utilizamos el constructor de alguna de sus subclases (Piano, Flauta, etc.): Java<pre><code>if (respuesta == 'p') {\n    // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Piano)\n    instrumento1 = new Piano();\n} else {\n    // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Flauta)\n    instrumento1 = new Flauta();\n}\n</code></pre></p> <p>Finalmente, a la hora de invocar el m\u00e9todo <code>tocarNota</code>, no sabremos a qu\u00e9 versi\u00f3n (de qu\u00e9 subclase) de <code>tocarNota</code> se estar\u00e1 llamando, pues depender\u00e1 del tipo de objeto (subclase) que se haya instanciado. Se estar\u00e1 utilizando por tanto la ligadura din\u00e1mica: </p> Java<pre><code>// Interpretamos una nota con el objeto instrumento1\n// No sabemos si se ejecutar\u00e1 el m\u00e9todo tocarNota de Piano o de Flauta (depender\u00e1 de la ejecuci\u00f3n)\ninstrumento1.tocarNota(\"do\"); // Ejemplo de ligadura din\u00e1mica (tiempo de ejecuci\u00f3n)\n</code></pre>"},{"location":"ud08/ud0806/#limitaciones-de-la-ligadura-dinamica","title":"Limitaciones de la ligadura din\u00e1mica","text":"<p>Como has podido comprobar, el polimorfismo se basa en la utilizaci\u00f3n de referencias de un tipo m\u00e1s \"amplio\" (superclases) que los objetos a los que luego realmente van a apuntar (subclases). Ahora bien, existe una importante restricci\u00f3n en el uso de esta capacidad, pues el tipo de referencia limita cu\u00e1les son los m\u00e9todos que se pueden utilizar y los atributos a los que se pueden acceder.</p> <p>A tener en cuenta</p> <p>No se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. S\u00f3lo se pueden utilizar los miembros declarados en la superclase, aunque la definici\u00f3n que finalmente se utilice en su ejecuci\u00f3n sea la de la subclase.</p> <p>Veamos un ejemplo: si dispones de una clase <code>Profesor</code> que es subclase de <code>Persona</code> y declaras una variable como referencia un objeto de tipo <code>Persona</code>. Aunque m\u00e1s tarde esa variable haga referencia a un objeto de tipo <code>Profesor</code> (subclase), los miembros a los que podr\u00e1s acceder sin que el compilador produzca un error ser\u00e1n los miembros de <code>Profesor</code> que hayan sido heredados de <code>Persona</code> (superclase). De este modo, se garantiza que los m\u00e9todos que se intenten llamar van a existir cualquiera que sea la subclase de <code>Persona</code> a la que se apunte desde esa referencia.</p> <p>En el ejemplo de las clases <code>Persona</code>, <code>Profesor</code> y <code>Alumno</code>, el polimorfismo nos permitir\u00eda declarar variables de tipo <code>Persona</code> y m\u00e1s tarde hacer con ellas referencia a objetos de tipo <code>Profesor</code> o <code>Alumno</code>, pero no deber\u00edamos intentar acceder con esa variable a m\u00e9todos que sean espec\u00edficos de la clase <code>Profesor</code> o de la clase <code>Alumno</code>, tan solo a m\u00e9todos que sabemos que van a existir seguro en ambos tipos de objetos (m\u00e9todos de la superclase <code>Persona</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Haz un peque\u00f1o programa en Java en el que se declare una variable de tipo <code>Persona</code>, se pidan algunos datos sobre esa persona (nombre, apellidos y si es alumno o si es profesor), y se muestren nuevamente esos datos en pantalla, teniendo en cuenta que esa variable no puede ser instanciada como un objeto de tipo <code>Persona</code> (es una clase abstracta) y que tendr\u00e1s que instanciarla como <code>Alumno</code> o como <code>Profesor</code>. Recuerda que para poder recuperar sus datos necesitar\u00e1s hacer uso de la ligadura din\u00e1mica y que tan solo deber\u00edas acceder a m\u00e9todos que sean de la superclase.</p> <p>Si tuvi\u00e9ramos diferentes variables referencia a objetos de las clases <code>Alumno</code> y <code>Profesor</code> tendr\u00edas algo as\u00ed:</p> Java<pre><code>Alumno obj1;\nProfesor obj2;\n...\n// Si se dan ciertas condiciones el objeto ser\u00e1 de tipo Alumno y lo tendr\u00e1s en obj1\nSystem.out.printf (\"Nombre: %s\\n\", obj1.getNombre());\n// Si se dan otras condiciones el objeto ser\u00e1 de tipo Profesor y lo tendr\u00e1s en obj2\nSystem.out.printf (\"Nombre: %s\\n\", obj2.getNombre());\n</code></pre> <p>Pero si pudieras tratar de una manera m\u00e1s gen\u00e9rica la situaci\u00f3n, podr\u00edas intentar algo as\u00ed:</p> Java<pre><code>Persona obj;\n// Si se dan ciertas condiciones el objeto ser\u00e1 de tipo Alumno y por tanto lo instanciar\u00e1s como tal\nobj = new Alumno (&lt;par\u00e1metros&gt;);\n// Si se otras condiciones el objeto ser\u00e1 de tipo Profesor y por tanto lo instanciar\u00e1s como tal\nobj = new Profesor (&lt;par\u00e1metros&gt;);\n</code></pre> <p>De esta manera la variable obj podr\u00eda contener una referencia a un objeto de la superclase <code>Persona</code> de subclase <code>Alumno</code> o bien de subclase <code>Profesor</code> (polimorfismo).</p> <p>Esto significa que independientemente del tipo de subclase que sea (<code>Alumno</code> o <code>Profesor</code>), podr\u00e1s invocar a m\u00e9todos de la superclase <code>Persona</code> y durante la ejecuci\u00f3n se resolver\u00e1n como m\u00e9todos de alguna de sus subclases:</p> Java<pre><code>//En tiempo de compilaci\u00f3n no se sabr\u00e1 de qu\u00e9 subclase de Persona ser\u00e1 obj.\n//Habr\u00e1 que esperar la ejecuci\u00f3n para que el entorno lo sepa e invoque al m\u00e9todo adecuado.\nSystem.out.format(\"Contenido del objeto: %s\\n\", obj.devolverContenidoString());\n</code></pre> <p>Por \u00faltimo recuerda que debes de proporcionar constructores a las subclases <code>Alumno</code> y <code>Profesor</code> que sean \"compatibles\" con algunos de los constructores de la superclase <code>Persona</code>, pues al llamar a un constructor de una subclase, su formato debe coincidir con el de alg\u00fan constructor de la superclase (como debe suceder en general con cualquier m\u00e9todo que sea invocado utilizando la ligadura din\u00e1mica).</p> <p>Constructor \"compatible\" para <code>Alumno</code>:</p> Java<pre><code>public Alumno(String nombre, String apellidos, LocalDate fechaNacim){\n    super(nombre, apellidos, fechaNacim);\n}\n</code></pre> <p>y el constructor \"compatible\" para <code>Profesor</code>:</p> Java<pre><code>public Profesor(String nombre, String apellidos, LocalDate fechaNacim) {\n    super(nombre, apellidos, fechaNacim);\n}\n</code></pre> <p>Aqu\u00ed tienes el ejemplo completo de la clase <code>EjemploUso</code>:</p> Java<pre><code>import java.time.LocalDate;\nimport java.util.Scanner;\n\npublic class EjemploUso {\n\npublic static void main(String[] args) {\n    Persona obj;\n    Scanner teclado = new Scanner(System.in);\n    System.out.print(\"Deseas crear un Profesor o un Alumno ('p' o 'a')?: \");\n    char respuesta = teclado.nextLine().toLowerCase().charAt(0);\n\n    if (respuesta == 'a') {\n        // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Alumno)\n        obj = new Alumno(\"Alumno\", \"Apellidos\", LocalDate.of(1977, 3, 8));\n    } else {\n        // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Profesor)\n        obj = new Profesor(\"Profe\", \"Apellidos\", LocalDate.of(1977, 3, 8));\n    }\n    System.out.format(\"Contenido del objeto: %s\\n\", obj.devolverContenidoString());\n}\n}\n</code></pre>"},{"location":"ud08/ud0806/#interfaces-y-polimorfismo","title":"Interfaces y polimorfismo","text":"<p>Es posible tambi\u00e9n llevar a cabo el polimorfismo mediante el uso de interfaces. Un objeto puede tener una referencia cuyo tipo sea una interfaz, pero para que el compilador te lo permita, la clase cuyo constructor se utilice para crear el objeto deber\u00e1 implementar esa interfaz (bien por si misma o bien porque la implemente alguna superclase). Un objeto cuya referencia sea de tipo interfaz s\u00f3lo puede utilizar aquellos m\u00e9todos definidos en la interfaz, es decir, que no podr\u00e1n utilizarse los atributos y m\u00e9todos espec\u00edficos de su clase, tan solo los de la interfaz.</p> <p>Las referencias de tipo interfaz permiten unificar de una manera bastante estricta la forma de utilizarse de objetos que pertenezcan a clases muy diferentes (pero que todas ellas implementan la misma interfaz). De este modo podr\u00edas hacer referencia a diferentes objetos que no tienen ninguna relaci\u00f3n jer\u00e1rquica entre s\u00ed utilizando la misma variable (referencia a la interfaz). Lo \u00fanico que los distintos objetos tendr\u00edan en com\u00fan es que implementan la misma interfaz. </p> <p>A tener en cuenta</p> <p>En este caso s\u00f3lo podr\u00e1s llamar a los m\u00e9todos de la interfaz y no a los espec\u00edficos de las clases.</p> <p>Por ejemplo, si ten\u00edas una variable de tipo referencia a la interfaz <code>Arrancable</code>, podr\u00edas instanciar objetos de tipo <code>Coche</code> o <code>Motosierra</code> y asignarlos a esa referencia (teniendo en cuenta que ambas clases no tienen una relaci\u00f3n de herencia). Sin embargo, tan solo podr\u00e1s usar en ambos casos los m\u00e9todos y los atributos de la interfaz <code>Arrancable</code> (por ejemplo arrancar) y no los de <code>Coche</code> o los de <code>Motosierra</code> (s\u00f3lo los gen\u00e9ricos, nunca los espec\u00edficos).</p> <p>En el caso de las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, podr\u00edas declarar, por ejemplo, variables del tipo <code>Imprimible</code>:</p> Java<pre><code>Imprimible obj; // Imprimible es una interfaz y no una clase\n</code></pre> <p>Con este tipo de referencia podr\u00edas luego apuntar a objetos tanto de tipo Profesor como de tipo Alumno, pues ambos implementan la interfaz <code>Imprimible</code>:</p> Java<pre><code>// En algunas circunstancias podr\u00eda suceder esto:\nobj = new Alumno (nombre, apellidos, fecha, grupo, nota); // Polimorfismo con interfaces\n...\n\n// En otras circunstancias podr\u00eda suceder esto:\nobj = new Profesor (nombre, apellidos, fecha, especialidad, salario); // Polimorfismo con interfaces\n...\n</code></pre> <p>Y m\u00e1s adelante hacer uso de la ligadura din\u00e1mica:</p> Java<pre><code>// Llamadas s\u00f3lo a m\u00e9todos de la interfaz\nString contenido;\ncontenido = obj.devolverContenidoString(); // Ligadura din\u00e1mica con interfaces\n</code></pre>"},{"location":"ud08/ud0806/#conversion-de-objetos","title":"Conversi\u00f3n de objetos","text":"<p>Como ya has visto, en principio no se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. Si deseas tener acceso a todos los m\u00e9todos y atributos espec\u00edficos del objeto subclase tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting) que convierta la referencia m\u00e1s general (superclase) en la del tipo espec\u00edfico del objeto (subclase).</p> <p>Para que puedas realizar conversiones entre distintas clases es obligatorio que exista una relaci\u00f3n de herencia entre ellas (una debe ser clase derivada de la otra). Se realizar\u00e1 una conversi\u00f3n impl\u00edcita o autom\u00e1tica de subclase a superclase siempre que sea necesario, pues un objeto de tipo subclase siempre contendr\u00e1 toda la informaci\u00f3n necesaria para ser considerado un objeto de la superclase.</p> <p>Ahora bien, la conversi\u00f3n en sentido contrario (de superclase a subclase) debe hacerse de forma expl\u00edcita y seg\u00fan el caso podr\u00eda dar lugar a errores por falta de informaci\u00f3n (atributos) o de m\u00e9todos. En tales casos se produce una excepci\u00f3n de tipo <code>ClassCastException</code>. </p> <p>Por ejemplo, imagina que tienes una clase <code>Animal</code> y una clase <code>Besugo</code>, subclase de <code>Animal</code>:</p> Java<pre><code>class Animal {\n    public String nombre;\n}\n\nclass Besugo extends Animal {\n    public double peso;\n}\n</code></pre> <p>A continuaci\u00f3n declaras una variable referencia a la clase <code>Animal</code> (superclase) pero sin embargo le asignas una referencia a un objeto de la clase <code>Besugo</code> (subclase) haciendo uso del polimorfismo:</p> Java<pre><code>Animal obj; // Referencia a objetos de la clase Animal\nobj = new Besugo(); // Referencia a objetos clase Animal, pero apunta realmente a objeto clase Besugo (polimorfismo)\n</code></pre> <p>El objeto que acabas de crear como instancia de la clase <code>Besugo</code> (subclase de <code>Animal</code>) contiene m\u00e1s informaci\u00f3n que la que la referencia <code>obj</code> te permite en principio acceder sin que el compilador genere un error (pues es de clase <code>Animal</code>). En concreto los objetos de la clase <code>Besugo</code> disponen de <code>nombre</code> y <code>peso</code>, mientras que los objetos de la clase <code>Animal</code> s\u00f3lo de <code>nombre</code>. Para acceder a esa informaci\u00f3n adicional de la clase especializada (<code>peso</code>) tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting):</p> Java<pre><code>// Casting del tipo Animal al tipo Besugo (funcionar\u00e1 bien porque el objeto es realmente del tipo B)\nSystem.out.printf (\"obj.peso=%f\\n\", ((Besugo) obj).peso);\n</code></pre> <p>Sin embargo si se hubiera tratado de una instancia de la clase <code>Animal</code> y hubieras intentado acceder al miembro <code>peso</code>, se habr\u00eda producido una excepci\u00f3n de tipo <code>ClassCastException</code>:</p> Java<pre><code>Animal obj; // Referencia a objetos de la clase Animal\nobj = new Animal (); // Referencia a objetos de la clase Animal, y apunta realmente a un objeto de la clase Animal\n\n// Casting del tipo Animal al tipo Besugo (puede dar problemas porque el objeto es realmente del tipo Animal):\n// Funciona (la clase Animal tiene nombre)\nSystem.out.printf (\"obj.nombre=%s\\n\", ((Besugo) obj).nombre);\n\n// \u00a1Error en ejecuci\u00f3n! (la clase Animal no tiene peso). Producir\u00e1 una ClassCastException.\nSystem.out.printf (\"obj.peso=%f\\n\", ((Besugo) obj).peso);\n</code></pre>"},{"location":"ud08/ud0807/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li>Curso Java. Herencia I. V\u00eddeo 40</li> <li>Curso Java. Herencia II. V\u00eddeo 41</li> <li>Curso Java. Herencia III. Dise\u00f1ando la herencia. V\u00eddeo 42</li> <li>Curso Java. Polimorfismo y enlazado din\u00e1mico. V\u00eddeo 43</li> <li>Curso Java. Casting de objetos. Clases y m\u00e9todos final. V\u00eddeo 44</li> <li>Curso Java. Clases Abstractas I. V\u00eddeo 45</li> <li>Curso Java. Clases Abstractas II. V\u00eddeo 46</li> <li>Curso Java. Modificadores de acceso. Clase Object. V\u00eddeo 47</li> <li>Curso Java. Interfaces y clases internas. Interfaces I. V\u00eddeo 49</li> <li>Curso Java. Interfaces y clases internas Interfaces II. V\u00eddeo 50</li> <li>Curso Java. Interfaces y clases internas Interfaces III. V\u00eddeo 51</li> <li>Curso Java. Interfaces y clases internas Interfaces IV. V\u00eddeo 52</li> <li>Curso Java. Interfaces y clases internas. Clases internas I. V\u00eddeo 53</li> <li>Curso Java. Interfaces y clases internas. Clases internas II. V\u00eddeo 54</li> </ul>"},{"location":"ud08/ud0808/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>Apuntes Lionel</li> </ul>"},{"location":"ud08/ud08ej/","title":"Ejercicios","text":""},{"location":"ud08/ud08ej/#ejercicios-herencia","title":"Ejercicios Herencia","text":""},{"location":"ud08/ud08ej/#ejercicio01","title":"Ejercicio01","text":"<p>Dise\u00f1ar una jerarqu\u00eda de clases para modelizar las aulas de un centro de estudios.</p> <p>De un <code>Aula</code> se conoce el <code>c\u00f3digo</code> (num\u00e9rico), la <code>longitud</code> y la <code>anchura</code>. Se desea un m\u00e9todo que devuelva la capacidad del aula sabiendo que esta se calcula a partir de la superficie a raz\u00f3n de 1 alumnos por cada 1.4 metros cuadrados de superficie.</p> <p>Adem\u00e1s de las aulas, digamos normales, existen aulas de inform\u00e1tica y aulas de m\u00fasica. En las aulas de m\u00fasica se necesita conocer si tienen o no piano. De las aulas de inform\u00e1tica se conoce el n\u00famero de ordenadores y su capacidad no se calcula en funci\u00f3n de la superficie, sino a raz\u00f3n de dos alumnos por ordenador.</p> <p>Implementar el m\u00e9todo <code>toString</code> de cada una de las clases dise\u00f1adas para que devuelva:</p> <ul> <li> <p>En las aulas normales, el <code>c\u00f3digo</code> y la <code>superficie</code> y la <code>capacidad</code>.</p> </li> <li> <p>En las aulas de m\u00fasica e inform\u00e1tica el texto ir\u00e1 precedido por \"Aula de m\u00fasica\" o \"Aula de inform\u00e1tica\", seg\u00fan corresponda.</p> </li> </ul>"},{"location":"ud08/ud08ej/#ejercicio02","title":"Ejercicio02","text":"<p>Un sal\u00f3n de VideoJuegos dispone de ordenadores en los que los clientes pueden jugar. Adem\u00e1s de jugar en el establecimiento, la empresa alquila y vende juegos.</p> <p>2.1. Dise\u00f1ar la clase <code>Juego</code> siguiendo las siguientes especificaciones: </p> <ul> <li>Atributos protected: <code>titulo</code> (String), <code>fabricante</code> (String), <code>a\u00f1o</code> (int).</li> <li>Constructor <code>public Juego(String t, String f, int a)</code>.</li> <li>Consultores de todos los atributos.</li> <li><code>public String toString()</code>, que devuelve un String con los datos del Juego.</li> <li><code>public boolean equals(Object o)</code>: Dos juegos son iguales si tienen el mismo t\u00edtulo, fabricante y a\u00f1o.</li> <li><code>public int compareTo(Object o)</code>: Un juego es menor que otro si su t\u00edtulo es menor. A igual t\u00edtulo, si su fabricante es menor. A igual t\u00edtulo y fabricante, si su a\u00f1o es menor.</li> </ul> <p>2.2. Dise\u00f1ar las clases <code>JuegoEnAlquiler</code> y <code>JuegoEnVenta</code> (y otras si se considera oportuno), sabiendo que, adem\u00e1s de los atributos descritos anteriormente, tienen.</p> <ul> <li><code>precio</code>.</li> <li><code>n\u00ba de copias disponibles</code>.</li> <li><code>JuegoEnAlquiler</code>.</li> <li>tiene un atributo que indica el n\u00famero de d\u00edas que se alquila. (Por el precio indicado, hay juegos que se alquilan por un d\u00eda, otros por 2, etc...).</li> <li>Constructor que recibe todos sus datos.</li> <li>tiene un m\u00e9todo <code>alquilar</code> que decrementa el n\u00famero de copias disponibles.</li> <li>tiene un m\u00e9todo <code>devolver</code> que incrementa el n\u00famero de copias disponibles.</li> <li> <p><code>toString()</code> devuelve todos los datos del <code>JuegoEnAlquiler</code>.</p> </li> <li> <p><code>JuegoEnVenta</code></p> </li> <li><code>Constructor</code> que recibe todos sus datos.</li> <li>tiene un m\u00e9todo <code>vender</code>, que decrementa el n\u00famero de copias disponibles.</li> <li><code>toString()</code> devuelve todos los datos del <code>JuegoEnVenta</code>.</li> </ul>"},{"location":"ud08/ud08ej/#ejercicio03","title":"Ejercicio03","text":"<p>La Fabrica Nacional de Moneda y Timbre quiere almacenar cierta informaci\u00f3n t\u00e9cnica del dinero (billetes y monedas) que emite. En concreto, le interesa:</p> <ul> <li><code>Valor</code>: Valor de la moneda o billete, en euros. (<code>double</code>).</li> <li><code>A\u00f1o de emisi\u00f3n</code>: A\u00f1o en que fue emitida la moneda o billete. (<code>int</code>).</li> <li>De las monedas, </li> <li><code>Di\u00e1metro</code>: Di\u00e1metro de la moneda, en mil\u00edmetros. (<code>double</code>).</li> <li><code>Peso</code>: Peso de la moneda, en gramos (<code>double</code>).</li> <li>De los billetes.</li> <li><code>Altura del billete</code>, en mm (<code>double</code>).</li> <li><code>Anchura del billete</code>, en mm (<code>double</code>).</li> </ul> <p>a) Dise\u00f1ar la clase abstracta <code>Dinero</code> y sus subclases <code>Moneda</code> y <code>Billete</code>, desarrollando:</p> <ul> <li>Constructores que reciban los datos necesarios para inicializar los atributos de la clase correspondiente.</li> <li><code>equals</code>: Dos monedas o billetes son iguales si tienen el mismo a\u00f1o de emisi\u00f3n y valor.</li> <li><code>compareTo</code>: Es menor (mayor) el de menor (mayor) a\u00f1o, a igual a\u00f1o es menor (mayor) el de menor (mayor) valor.</li> <li><code>toString</code>: Que muestre todos los datos del billete o moneda. Los billetes ir\u00e1n precedidos por el texto \"BILLETE\" y las monedas por el texto \"MONEDA\".</li> </ul> <p>b) Dise\u00f1ar la clase <code>TestDinero</code> para probar las clases desarrolladas: Crear objetos de las clases <code>Moneda</code> y <code>Billete</code> y mostrarlos por pantalla.</p>"},{"location":"ud08/ud08ej/#ejercicio04","title":"Ejercicio04","text":"<p>Un centro comercial quiere mostrar cierta informaci\u00f3n sobre los televisores que vende. Los televisores pueden ser de dos tipos: de tubo o LCD. En concreto, de cada televisor le interesa mostrar:</p> <ul> <li>Marca (<code>String</code>).</li> <li>Modelo (<code>String</code>).</li> <li>Precio en euros.</li> <li>Pulgadas de la pantalla (<code>double</code>).</li> <li>Resoluci\u00f3n: La resoluci\u00f3n se mide de forma distinta en los televisores de tubo que en los televisores LCD.</li> <li>En los TV de tubo se mide en lineas.</li> <li>En los TV LCD se mide pixels horizontales x pixels verticales.</li> </ul> <p>a) Dise\u00f1ar la clase <code>Televisor</code> con los atributos y m\u00e9todos comunes a los dos tipos de televisores y sus subclases <code>TVTubo</code> y <code>TVLCD</code> con los atributos y m\u00e9todos que sea necesario:</p> <ul> <li>Constructor de cada clase que permita inicializar todos los datos de la clase.</li> <li><code>equals</code>: Dos televisiones son iguales si son de la misma marca y modelo.</li> <li><code>compareTo</code>: Se considera menor (mayor) la de menor (mayor) marca. A igual marca, menor (mayor) la de menor (mayor) modelo.</li> <li><code>public String resulucion()</code>: Devuelve un texto con la resoluci\u00f3n del televisor, como por ejemplo \"420 lineas\" o \"800 x 600 pixels\" dependiendo del tipo de televisor.</li> <li><code>public String toString()</code>: Devuelve un texto con la marca, modelo, precio, pulgadas y resoluci\u00f3n.</li> </ul> <p>b) Dise\u00f1ar la clase <code>TestTV</code> para probar las clases dise\u00f1adas. Crear algunos objetos de las clases <code>TVTubo</code> y <code>TVLCD</code> y mostrarlos por pantalla.</p>"},{"location":"ud08/ud08ej/#ejercicio05","title":"Ejercicio05","text":"<p>De cada pareja de afirmaciones indica cual es la verdaderas:</p> <p>\u200b   a) Se dice que instanciamos una clase cuando creamos objetos de dicha clase.</p> <p>\u200b   b) Se dice que instanciamos una clase cuando creamos una subclase de dicha clase.</p> <p>\u200b   c) Si una clase es abstracta no se puede instanciar.</p> <p>\u200b   d) Si una clase es abstracta no se puede heredar de ella.</p> <p>\u200b   e) Una clase abstracta tiene que tener m\u00e9todos abstractos.</p> <p>\u200b   f) Una clase puede ser abstracta y no tener m\u00e9todos abstractos.</p> <p>\u200b   g) Si una clase tiene m\u00e9todos abstractos tiene que ser abstracta.</p> <p>\u200b   h) Una clase puede tener m\u00e9todos abstractos y no ser abstracta.</p> <p>\u200b   i) Si una clase es abstracta sus subclases no pueden ser abstractas.</p> <p>\u200b   j) Una clase abstracta puede tener subclases que tambi\u00e9n sean abstractas.</p> <p>\u200b   k) Si un m\u00e9todo es abstracto en una clase, tiene que ser no abstracto en la subclase, o bien, la subclase tiene que ser tambi\u00e9n abstracta.</p> <p>\u200b   l) Si un m\u00e9todo es abstracto en una clase, no puede ser abstracto en las subclases.</p> <p>\u200b   m) Si un m\u00e9todo se define final se tiene que reescribir en las subclases.</p> <p>\u200b   n) Si un m\u00e9todo se define final no se puede reescribir en las subclases.</p> <p>\u200b   o) Una clase puede tener un m\u00e9todo final y no ser una clase final.</p> <p>\u200b   p) Si una clase tiene un m\u00e9todo final tiene que ser una clase final.</p> <p>\u200b   q) Si una clase se define final no se pueden definir subclases de ella.</p> <p>\u200b   r) Si una clase se define final no se puede instanciar.</p> <p>\u200b   s) Un m\u00e9todo definido final y abstract resultar\u00eda in\u00fatil, puesto que nunca se podr\u00eda implementar en las subclases.</p> <p>\u200b   t) Un m\u00e9todo definido final y abstract podr\u00eda resultar \u00fatil.</p> <p>\u200b   u) Una clase definida final y abstract resultar\u00eda in\u00fatil, puesto que no se podr\u00eda instanciar ni heredar de ella.</p> <p>\u200b   v) Una clase definida final y abstract podr\u00eda resultar \u00fatil.</p>"},{"location":"ud08/ud08ej/#ejercicio06","title":"Ejercicio06","text":"<p>Dada las siguientes definiciones de clases:</p> Java<pre><code>public class Persona {\n    private String nombre;\n    private int edad;\n\n    public Persona (){\n        this.nombre = \"\";\n        this.edad = 0;\n    }\n\n    public Persona(String n, int e){\n        this.nombre = n;\n        this.edad = e;\n    }\n\n    public String toString(){\n        return \"Nombre: \" + nombre + \"Edad \" + edad;\n    }\n\n    public final String getNombre (){\n        return nombre;\n    }\n\n    public final int getEdad(){\n        return edad;\n    }\n}\n</code></pre> Java<pre><code>class Estudiante extends Persona {\n    private double creditos;\n\n    public Estudiante(String n, int e, double c){\n        super(n,e);\n        this.creditos = c;\n    }\n\n    public String toString(){\n        return super.toString() + \"\\nCreditos: \"+ creditos;\n    }\n}\n</code></pre> Java<pre><code>class Empleado extends Persona {\n    private double salario;\n\n    public Empleado(String n, int e, double s){\n        super(n,e);\n        this.salario = s;\n    }\n\n    public String toString(){\n        return \"Nombre: \"+ this.nombre +\n        \"\\nSalario: \"+ this.salario;\n    }\n}\n</code></pre> Java<pre><code>class Test{\n    public static void main(String[] args) {\n        Estudiante e = new Estudiante(\"pepe\",18,100);\n        System.out.println(e.toString());\n    }\n}\n</code></pre> <p>Responde a las siguientes cuestiones justificando las respuestas. </p> <p>\u200b   a) \u00bfEs necesario el uso de <code>this</code> en el constructor de la clase <code>Estudiante</code>?</p> <p>\u200b   b) \u00bfEs necesario el uso de <code>super</code> en el m\u00e9todo <code>toString</code> de la clase <code>Estudiante</code>?</p> <p>\u200b   c) Si quit\u00e1semos el constructor de la clase <code>Estudiante</code> \u00bfdar\u00eda un error de compilaci\u00f3n?</p> <p>\u200b   d) En el m\u00e9todo <code>toString</code> de la clase <code>Empleado</code> \u00bfpor qu\u00e9 es incorrecto el acceso que se hace al atributo <code>nombre</code>? \u00bfC\u00f3mo se tendr\u00eda que definir <code>nombre</code> en la clase <code>Persona</code> para evitar el error?</p> <p>\u200b   e) \u00bfQu\u00e9 consecuencia tiene que algunos m\u00e9todos de la clase <code>Persona</code> se hayan definido <code>final</code>?</p> <p>\u200b   f) Si el m\u00e9todo <code>toString</code> no se hubiera definido en ninguna de las tres clases \u00bfdar\u00eda error el <code>sout</code> del m\u00e9todo <code>main</code>?</p>"},{"location":"ud08/ud08ej/#ejercicios-polimorfismo","title":"Ejercicios Polimorfismo","text":""},{"location":"ud08/ud08ej/#ejercicio07","title":"Ejercicio07","text":"<p>Dada la siguiente jerarqu\u00eda de clases:</p> Java<pre><code>public interface Montador{\n    void montar(String x);\n    void desmontar(String x);\n}\n\npublic class Obrero{\n    public Obrero(){System.out.println(\"Se crea Obrero\");}\n    public void saludar(){System.out.println(\"Hola, soy Obrero\");}\n    ...\n}\n\npublic class Carpintero extends Obrero implements Montador {\n    public Carpintero(){System.out.println(\"Se crea Carpintero\");}\n    public void montar(String x) {System.out.println(\"Montando \" + x);}\n    public void desmontar(String x) {System.out.println(\"Desmontando \" + x);}\n    public void clavar() {...}\n}\n\npublic class Alba\u00f1il extends Obrero {\n    public Alba\u00f1il() {\n        super();\n        System.out.println(\"Se crea Alba\u00f1il\");\n    }\n    public void levantarMuro(){ \n        System.out.println(\"Levantando muro \u2026\");\n    }\n}\n</code></pre> <p>Indicar qu\u00e9 l\u00edneas del siguiente fragmento de programa producir\u00e1n errores de compilaci\u00f3n,</p> Java<pre><code>public static void main(String[] args){\n    Montador m1 = new Carpintero();\n    Montador m2 = new Alba\u00f1il();\n    Obrero o1 = new Carpintero();\n    Obrero o2 = new Alba\u00f1il();\n    o1.montar(\"Mesa\");\n    o2.levantarMuro();\n    m1.saludar();\n    m1.montar(\"Silla\");\n    ((Alba\u00f1il)o2).levantarMuro();\n    ((Alba\u00f1il)o1).levantarMuro();\n}\n</code></pre> <p>Una vez eliminadas las l\u00edneas con error, indicar cu\u00e1l ser\u00eda la salida por pantalla del programa.</p> <p>\u00bfSer\u00eda correcta la instrucci\u00f3n siguiente?</p> Java<pre><code>    Alba\u00f1il a = new Alba\u00f1il();\n    System.out.println(a.toString());import os\n</code></pre>"},{"location":"ud08/ud08ej/#ejercicio08","title":"Ejercicio08","text":"<p>Las clases siguientes implementan una jerarqu\u00eda de herencia</p> Java<pre><code>class Base {\n    String metodo1() {return \"Base.metodo1()\";}\n    String metodo2(String s) {return \"Base.metodo1(\" + s + \")\";}\n}\n\npublic interface TipoI{\n    String metodoIn2(String s);\n    String metodoIn3();\n}\n\nclass Derivada extends Base implements TipoI{\n    public String metodoIn2(String s) {return \"Derivada.metodoIn2()\";}\n    public String metodoIn3() {return \"Derivada.metodoIn3()\";}\n    String metodo1() {return \"Derivada.metodo1()\";}\n}\n\nclass Derivada2 extends Derivada{\n    String metodo2 (String s) {return \"Derivada2.metodo2(\" + s + \")\";}\n    String metodo4() {return \"Derivada2.metodo4()\";}\n}\n</code></pre> <p>Sea la clase <code>CuestionHerencia</code> que usa las anteriores:</p> Java<pre><code>public class CuestionHerencia{\n    public static void main (String a[]){\n        String tmp;\n        Derivada derivada;\n        Derivada2 derivada2;\n        Base base;\n\n        derivada2 = new Derivada2(); \n        base = derivada2;\n        tmp = derivada2.metodo1(); \n        System.out.println(\"1) \"+tmp);\n        tmp = derivada2.metodoIn2(\"EDA!!\"); \n        System.out.println(\"2) \"+tmp);\n        tmp = base.metodo1();\n        System.out.println(\"3) \"+tmp);\n        tmp = base.metodo2(\"EDA!!\"); \n        System.out.println(\"4) \"+tmp);\n        tmp = derivada2.metodoIn3();\n        System.out.println(\"5) \"+tmp);\n        tmp = derivada2.metodo4();\n        System.out.println(\"6) \"+tmp);\n        tmp = base.metodo3();\n        System.out.println(\"7) \"+tmp);\n        derivada = new Derivada();\n        derivada2 = new Derivada2();\n        base = new Base();\n        Distinta ref = new Distinta();\n        tmp = ref.prueba(derivada2); \n        System.out.println(\"8) \"+tmp);\n        tmp = ref.prueba(derivada); \n        System.out.println(\"9) \"+tmp);\n        tmp = ref.prueba(base); \n        System.out.println(\"10) \"+tmp); \n    }\n}\n</code></pre> <p>\u200b   a) Se\u00f1alar los errores existentes.</p> <p>\u200b   b) Una vez corregido el programa, escribir la salida por pantalla resultado de su ejecuci\u00f3n.</p>"},{"location":"ud08/ud08ej/#ejercicio09","title":"Ejercicio09","text":"<p>Supermercado: Pr\u00e1ctica con interfaces y polimorfismo.</p> <p>Supermercado. Creaci\u00f3n de Interfaces </p> <p>Sup\u00f3n que debe crear distintas clases Java para describir los productos que vende un supermercado. </p> <p>Para unificar el c\u00f3digo de los distintos programadores del equipo debes crear las siguientes Interfaces Java para describir algunas caracter\u00edsticas de los productos. </p> <p>Interfaz EsLiquido. Esta interfaz indica que los objetos creados a partir de la clase ser\u00e1n l\u00edquidos, y tendr\u00e1 los siguientes m\u00e9todos: </p> Java<pre><code>public void setVolumen(double v); \npublic double getVolumen(); \npublic void setTipoEnvase(String env); \npublic String getTipoEnvase();\n</code></pre> <p>Interfaz EsAlimento. Esta interfaz indica que los objetos creados a partir de la clase ser\u00e1n alimentos, y tendr\u00e1 los siguientes m\u00e9todos: </p> Java<pre><code>public void setCaducidad(LocalDate fc); \npublic LocalDate getCaducidad(); \npublic int getCalorias();\n</code></pre> <p>Interfaz ConDescuento. Esta interfaz indicar\u00e1 que el producto tiene descuento e incluir\u00e1 los siguientes m\u00e9todos: </p> Java<pre><code>public void setDescuento(double des); \npublic double getDescuento(); \npublic double getPrecioDescuento();\n</code></pre> <p>Creaci\u00f3n de clases de productos. Se pide que programes las siguientes clases de productos, implementando las interfaces que sean necesarias.</p> <p>Clase Detergente. Define una botella de detergente (debes tener en cuenta que este producto puede tener descuento).</p> <p>Sus propiedades principales ser\u00e1n: <code>marca</code> (String) y <code>precio</code> (double).</p> <p>Incluye otras propiedades seg\u00fan sea necesario a la hora de implementar las interfaces. </p> <ul> <li>Constructor: programa un constructor que reciba como par\u00e1metros una marca y un precio. </li> <li>M\u00e9todos set y get: programa m\u00e9todos set y get para la marca y el precio.</li> <li>M\u00e9todos de las interfaces: programa los m\u00e9todos de las interfaces. </li> <li>M\u00e9todo <code>toString</code>: programa el m\u00e9todo toString con todas las caracter\u00edsticas del producto. </li> </ul> <p>Clase Cereales. Define el producto caja de cereales (este producto no tiene descuentos).</p> <p>Las propiedades del producto ser\u00e1n <code>marca</code>, <code>precio</code> y <code>tipo</code> de cereal (String).</p> <ul> <li>Programa un constructor que reciba como par\u00e1metros las tres propiedades anteriores. </li> <li>Programa los m\u00e9todos set y get para dichas propiedades. </li> <li>Programa los m\u00e9todos de las interfaces implementadas (si es necesario a\u00f1ade m\u00e1s propiedades a la clase).</li> </ul> <p>A tener en cuenta!</p> <p>Las calor\u00edas ser\u00e1n las siguientes: 5 si el cereal es espelta, 8 si es ma\u00edz, 12 si es trigo, y 15 en los dem\u00e1s casos.</p> <ul> <li>Programa el m\u00e9todo <code>toString</code> para devolver una cadena con todas las caracter\u00edsticas del producto.</li> </ul> <p>Clase Vino. Esta clase describir\u00e1 el producto botella de vino (este producto es susceptible de tener descuento).</p> <p>El producto tendr\u00e1 como propiedades la marca, el tipo de vino, los grados de alcohol y el precio.</p> <ul> <li>Programa al igual que los productos anteriores un constructor con estas cuatro propiedades como par\u00e1metros.</li> <li>Programa tambi\u00e9n los m\u00e9todos set, get, toString y los m\u00e9todos de las interfaces. A\u00f1ada nuevas propiedades si es necesario. </li> </ul> <p>A tener en cuenta!</p> <p>Las calor\u00edas se calcular\u00e1n multiplicando por 10 la graduaci\u00f3n alcoh\u00f3lica.</p> <p>Programa de prueba. Realiza un programa de prueba d\u00f3nde crees varios productos de cada clase. Haz un ejemplo de polimorfismo creando un ArrayList de productos alimenticios y calculando la suma de sus calor\u00edas.</p>"},{"location":"ud08/ud08ej/#ejercicio10","title":"Ejercicio10","text":"<p>Realizar una aplicaci\u00f3n para la gesti\u00f3n de la informaci\u00f3n de las personas vinculadas a una <code>Facultad</code>, que se pueden clasificar en tres tipos: estudiantes, profesores y personal de servicio. A continuaci\u00f3n, se detalla qu\u00e9 tipo de informaci\u00f3n debe gestionar esta aplicaci\u00f3n:</p> <ul> <li>Por cada <code>Persona</code>, se debe conocer, al menos, su <code>nombre</code> y <code>apellidos</code>, su <code>n\u00famero de identificaci\u00f3n</code> y su <code>estado civil</code>.</li> <li>Con respecto a los <code>Empleados</code>, sean del tipo que sean, hay que saber su <code>a\u00f1o de incorporaci\u00f3n</code> a la facultad y qu\u00e9 <code>n\u00famero de despacho</code> tienen asignado.</li> <li>En cuanto a los <code>Estudiantes</code>, se requiere almacenar el <code>curso</code> en el que est\u00e1n matriculados.</li> <li>Por lo que se refiere a los <code>Profesores</code>, es necesario gestionar a qu\u00e9 <code>departamento</code> pertenecen (<code>lenguajes</code>, <code>matem\u00e1ticas</code>, <code>arquitectura</code>, ...).</li> <li>Sobre el <code>Personal de servicio</code>, hay que conocer a qu\u00e9 <code>secci\u00f3n</code> est\u00e1n asignados (<code>biblioteca</code>, <code>decanato</code>, <code>secretar\u00eda</code>, ...).</li> </ul> <p>El ejercicio consiste, en primer lugar, en definir la jerarqu\u00eda de clases de esta aplicaci\u00f3n. A continuaci\u00f3n, debe programar las clases definidas en las que, adem\u00e1s de los constructores, hay que desarrollar los m\u00e9todos correspondientes a las siguientes acciones:</p> <ul> <li>Cambio del estado civil de una persona.</li> <li>Reasignaci\u00f3n de despacho a un empleado.</li> <li>Matriculaci\u00f3n de un estudiante en un nuevo curso.</li> <li>Cambio de departamento de un profesor.</li> <li>Traslado de secci\u00f3n de un empleado del personal de servicio.</li> <li>Imprimir toda la informaci\u00f3n de cada tipo de individuo.</li> </ul> <p>En el m\u00e9todo <code>main</code> crear un array de <code>personas</code>. Crear diferentes instancias de las subclases e insertarlas en el array. Probar los diferentes m\u00e9todos desarrollados.</p>"},{"location":"ud08/ud08ej/#ejercicio11","title":"Ejercicio11","text":"<p>Crea una clase <code>Empleado</code> y una subclase <code>Encargado</code>. Los encargados reciben un 10% m\u00e1s de sueldo base que un empleado normal. Implementa dichas clases en el paquete objetos y sobrescribe el m\u00e9todo <code>getSueldo()</code> para ambas clases.</p>"},{"location":"ud08/ud08ej/#ejercicio12","title":"Ejercicio12","text":"<p>Crear la clase <code>Dado</code>, la cual desciende de la clase <code>Sorteo</code>. La clase <code>Dado</code>, en la llamada <code>lanzar()</code> mostrar\u00e1 un n\u00famero aleatorio del 1 al 6. Crear la clase <code>Moneda</code>, la cual desciende de la clase <code>Sorteo</code>. Esta clase en la llamada al m\u00e9todo <code>lanzar()</code> mostrar\u00e1 las palabras cara o cruz. Realizar una clase con un m\u00e9todo <code>main</code> que compruebe todo lo realizado.</p>"},{"location":"ud08/ud08ej/#ejercicio13","title":"Ejercicio13","text":"<p>Realiza una clase <code>Huevo</code> con un atributo <code>tama\u00f1o</code> (<code>S</code>, <code>M</code>, <code>L</code>, <code>XL</code>) con el m\u00e9todo <code>toString</code>. La clase <code>Huevo</code> est\u00e1 compuesta por dos clases internas, una <code>Clara</code> y otra <code>Yema</code>. Ambas clases tienen un atributo <code>color</code> y el m\u00e9todo <code>toString</code>. Realiza un m\u00e9todo <code>main</code> en el que se cree un objeto de tipo <code>Huevo</code>, <code>Clara</code> y <code>Yema</code>, se le asigne valor a sus atributos y se muestren los valores.</p>"},{"location":"ud08/ud08ej/#ejercicios-lionel","title":"Ejercicios Lionel","text":""},{"location":"ud08/ud08ej/#ejercicio14-astros","title":"Ejercicio14 - Astros","text":"<p>Define una jerarqu\u00eda de clases que permita almacenar datos sobre los planetas y sat\u00e9lites (lunas) que forman parte del sistema solar.</p> <p>Algunos atributos que necesitaremos almacenar son: </p> <ul> <li>Masa del cuerpo.</li> <li>Di\u00e1metro medio.</li> <li>Per\u00edodo de rotaci\u00f3n sobre su propio eje.</li> <li>Per\u00edodo de traslaci\u00f3n alrededor del cuerpo que orbitan.</li> <li>Distancia media a ese cuerpo.</li> <li>etc.</li> </ul> <p>Define las clases necesarias conteniendo: </p> <ul> <li>Constructores. </li> <li>M\u00e9todos para recuperar y almacenas atributos.</li> <li>M\u00e9todo para mostrar la informaci\u00f3n del objeto. </li> </ul> <p>Define un m\u00e9todo, que dado un objeto del sistema solar (planeta o sat\u00e9lite), imprima toda la informaci\u00f3n que se dispone sobre el mismo (adem\u00e1s de su lista de sat\u00e9lites si los tuviera).</p> <p>El diagrama UML ser\u00eda:</p> <p></p> <p>Una posible soluci\u00f3n ser\u00eda crear una lista de objetos, insertar los planetas y sat\u00e9lites (directamente mediante c\u00f3digo o solicit\u00e1ndolos por pantalla) y luego mostrar un peque\u00f1o men\u00fa que permita al usuario imprimir la informaci\u00f3n del astro que elija.</p>"},{"location":"ud08/ud08ej/#ejercicio15-mascotas","title":"Ejercicio15 - Mascotas","text":"<p>Implementa una clase llamada Inventario que utilizaremos para almacenar referencias a todos los animales existentes en una tienda de mascotas. </p> <p>Esta clase debe cumplir con los siguientes requisitos: </p> <ul> <li>En la tienda existir\u00e1n 4 tipos de animales: perros, gatos, loros y canarios. </li> <li>Los animales deben almacenarse en un <code>ArrayList</code> privado dentro de la clase Inventario. </li> <li>La clase debe permitir realizar las siguientes acciones:<ul> <li>Mostrar la lista de animales (solo tipo y nombre, 1 l\u00ednea por animal).</li> <li>Mostrar todos los datos de un animal concreto.</li> <li>Mostrar todos los datos de todos los animales.</li> <li>Insertar animales en el inventario. </li> <li>Eliminar animales del inventario. </li> <li>Vaciar el inventario. </li> </ul> </li> </ul> <p>Implementa las dem\u00e1s clases necesarias para usar la clase <code>Inventario</code>.</p> <p>El diagrama UML ser\u00eda:</p> <p></p>"},{"location":"ud08/ud08ej/#ejercicio16-banco","title":"Ejercicio16 - Banco","text":"<p>Vamos a hacer una aplicaci\u00f3n que simule el funcionamiento de un banco.</p> <p>Crea una clase CuentaBancaria con los atributos: iban y saldo. Implementa m\u00e9todos para:</p> <ul> <li>Consultar los atributos. </li> <li>Ingresar dinero.</li> <li>Retirar dinero.</li> <li>Traspasar dinero de una cuenta a otra.</li> </ul> <p>Para los tres \u00faltimos m\u00e9todos puede utilizarse internamente un m\u00e9todo privado m\u00e1s general llamado a\u00f1adir(...) que a\u00f1ada una cantidad (positiva o negativa) al saldo.</p> <p>Tambi\u00e9n habr\u00e1 un atributo com\u00fan a todas las instancias llamado interesAnualBasico, que en principio puede ser constante.</p> <p>La clase tiene que ser abstracta y debe tener un m\u00e9todo calcularIntereses() que se dejar\u00e1 sin implementar.</p> <p>Tambi\u00e9n puede ser \u00fatil implementar un m\u00e9todo para mostrar los datos de la cuenta.</p> <p>De esta clase heredar\u00e1n dos subclases: CuentaCorriente y CuentaAhorro. La diferencia entre ambas ser\u00e1 la manera de calcular los intereses:</p> <ul> <li>A la primera se le incrementar\u00e1 el saldo teniendo en cuenta el inter\u00e9s anual b\u00e1sico.</li> <li>La segunda tendr\u00e1 una constante de clase llamada saldoMinimo. Si no se llega a este saldo el inter\u00e9s ser\u00e1 la mitad del inter\u00e9s b\u00e1sico. Si se supera el saldo m\u00ednimo el inter\u00e9s aplicado ser\u00e1 el doble del inter\u00e9s anual b\u00e1sico.</li> </ul> <p>Implementa una clase principal con funci\u00f3n main para probar el funcionamiento de las tres clases: Crea varias cuentas bancarias de distintos tipos, pueden estar en un ArrayList si lo deseas; prueba a realizar ingresos, retiradas y transferencias; calcula los intereses y mu\u00e9stralos por pantalla; etc.</p> <p>El diagrama UML ser\u00eda:</p> <p></p>"},{"location":"ud08/ud08ej/#ejercicio17-empresa-y-empleados","title":"Ejercicio17 - Empresa y empleados","text":"<p>Vamos a implementar dos clases que permitan gestionar datos de empresas y sus empleados.</p> <p>Los empleados tienen las siguientes caracter\u00edsticas:</p> <ul> <li>Un empleado tiene nombre, DNI, sueldo bruto (mensual), edad, tel\u00e9fono y direcci\u00f3n.</li> <li>El nombre y DNI de un empleado no pueden variar.</li> <li>Es obligatorio que todos los empleados tengan al menos definido su nombre, DNI y el sueldo bruto. Los dem\u00e1s datos no son obligatorios.</li> <li>Ser\u00e1 necesario un m\u00e9todo para imprimir por pantalla la informaci\u00f3n de un empleado.</li> <li>Ser\u00e1 necesario un m\u00e9todo para calcular el sueldo neto de un empleado. El sueldo neto se calcula descontando del sueldo bruto un porcentaje que depende del IRPF. El porcentaje del IRPF depende del sueldo bruto anual del empleado (sueldo bruto x 12 pagas).(*)</li> </ul> Sueldo bruto anual IRPF Inferior a 12.000 \u20ac 20% De 12.000 a 25.000 \u20ac 30% M\u00e1s de 25.000 \u20ac 40% <p>Por ejemplo, un empleado con un sueldo bruto anual de 17.000 \u20ac tendr\u00e1 un 30% de IRPF. Para calcular su sueldo neto mensual se descontar\u00e1 un 30% a su sueldo bruto mensual.</p> <p>Las empresas tienen las siguientes caracter\u00edsticas:</p> <ul> <li>Una empresa tiene nombre y CIF (datos que no pueden variar), adem\u00e1s de tel\u00e9fono, direcci\u00f3n y empleados. Cuando se crea una nueva empresa esta carece de empleados.</li> <li>Ser\u00e1n necesarios m\u00e9todos para:</li> <li>A\u00f1adir y eliminar empleados a la empresa.</li> <li>Mostrar por pantalla la informaci\u00f3n de todos los empleados.</li> <li>Mostrar por pantalla el DNI, sueldo bruto y neto de todos los empleados.</li> <li>Calcular la suma total de sueldos brutos de todos los empleados.</li> <li>Calcular la suma total de sueldos netos de todos los empleados.</li> </ul> <p>Implementa las clases Empleado y Empresa con los atributos oportunos, un constructor, los getters/setters oportunos y los m\u00e9todos indicados. Puedes a\u00f1adir m\u00e1s m\u00e9todos si lo ves necesario. Estas clases no deben realizar ning\u00fan tipo de entrada por teclado.</p> <p>Implementa tambi\u00e9n una clase Programa con una funci\u00f3n main para realizar pruebas: Crear una o varias empresas, crear empleados, a\u00f1adir y eliminar empleados a las empresas, listar todos los empleados, mostrar el total de sueldos brutos y netos, etc.</p> <p>(*)</p> <p>El IRPF realmente es m\u00e1s complejo pero se ha simplificado para no complicar demasiado este ejercicio.</p>"},{"location":"ud08/ud08ej/#ejercicio18-vehiculos","title":"Ejercicio18 - Veh\u00edculos","text":"<p>Aconsejable</p> <p>Realizar el dise\u00f1o UML antes de empezar a programar.</p> <p>Debes crear varias clases para un software de una empresa de transporte. Implementa la jerarqu\u00eda de clases necesaria para cumplir los siguientes criterios:</p> <ul> <li>Los veh\u00edculos de la empresa de transporte pueden ser terrestres, acu\u00e1ticos y a\u00e9reos. Los veh\u00edculos terrestres pueden ser coches y motos. Los veh\u00edculos acu\u00e1ticos pueden ser barcos y submarinos. Los veh\u00edculos a\u00e9reos pueden ser aviones y helic\u00f3pteros.</li> <li>Todos los veh\u00edculos tienen matr\u00edcula y modelo (datos que no pueden cambiar). La matr\u00edcula de los coches terrestres deben estar formadas por 4 n\u00fameros y 3 letras. La de los veh\u00edculos acu\u00e1ticos por entre 3 y 10 letras. La de los veh\u00edculos a\u00e9reos por 4 letras y 6 n\u00fameros.</li> <li>Los veh\u00edculos terrestres tienen un n\u00famero de ruedas (dato que no puede cambiar).</li> <li>Los veh\u00edculos acu\u00e1ticos tienen eslora (dato que no puede cambiar).</li> <li>Los veh\u00edculos a\u00e9reos tienen un n\u00famero de asientos (dato que no puede cambiar).</li> <li>Los coches pueden tener aire acondicionado o no tenerlo.</li> <li>Las motos tienen un color.</li> <li>Los barcos pueden tener motor o no tenerlo.</li> <li>Los submarinos tienen una profundidad m\u00e1xima.</li> <li>Los aviones tienen un tiempo m\u00e1ximo de vuelo.</li> <li>Los helic\u00f3pteros tienen un n\u00famero de h\u00e9lices.</li> <li>No se permiten veh\u00edculos gen\u00e9ricos, es decir, no se deben poder instanciar objetos que sean veh\u00edculos sin m\u00e1s. Pero debe ser posible instanciar veh\u00edculos terrestres, acu\u00e1ticos o a\u00e9reos gen\u00e9ricos (es decir, que no sean coches, motos, barcos, submarinos, aviones o helic\u00f3pteros).</li> <li>El dise\u00f1o debe obligar a que todas las clases de veh\u00edculos tengan un m\u00e9todo imprimir() que imprima por pantalla la informaci\u00f3n del veh\u00edculo en una sola l\u00ednea.</li> </ul> <p>Implementa todas las clases necesarias con: atributos, constructor con par\u00e1metros, getters/setters y el m\u00e9todo imprimir. Utiliza abstracci\u00f3n y herencia de la forma m\u00e1s apropiada.</p> <p>Implementa tambi\u00e9n una clase Programa para hacer algunas pruebas: Instancia varios veh\u00edculos de todo tipo (coches, motos, barcos, submarinos, aviones y helic\u00f3pteros) as\u00ed como veh\u00edculos genericos (terrestres, acu\u00e1ticos y a\u00e9reos). Crea un ArrayList y a\u00f1ade todos los veh\u00edculos. Recorre la lista y llama al m\u00e9todo imprimir de todos los veh\u00edculos.</p>"},{"location":"ud08/ud08ej/#ejercicio19-figuras","title":"Ejercicio19 - Figuras","text":"<p>Implementa una interface llamada iFigura2D que declare los m\u00e9todos:</p> <ul> <li><code>double perimetro()</code>: Para devolver el per\u00edmetro de la figura.</li> <li><code>double area()</code>: Para devolver el \u00e1rea de la figura.</li> <li><code>void escalar(double escala)</code>: Para escalar la figura (aumentar o disminuir su tama\u00f1o). Solo hay que multiplicar los atributos de la figura por la escala (&gt; 0).</li> <li><code>void imprimir()</code>: Para mostrar la informaci\u00f3n de la figura (atributos, per\u00edmetro y \u00e1rea) en una sola l\u00ednea.</li> </ul> <p>Existen 4 tipos de figuras.</p> <ul> <li>Cuadrado: Sus cuatro lados son iguales.</li> <li>Rect\u00e1ngulo: Tiene ancho y alto.</li> <li>Tri\u00e1ngulo: Tiene ancho y alto.</li> <li>C\u00edrculo: Tiene radio.</li> </ul> <p>Crea las 4 clases de figuras de modo que implementen la interface iFigura2D. Define sus m\u00e9todos.</p> <p>Crea una clase ProgramaFiguras con un main en el que realizar las siguientes pruebas:</p> <p>\u200b   a) Crea un ArrayList figuras.</p> <p>\u200b   b) A\u00f1ade figuras de varios tipos.</p> <p>\u200b   c) Muestra la informaci\u00f3n de todas las figuras.</p> <p>\u200b   d) Escala todas las figuras con escala = 2.</p> <p>\u200b   e) Muestra de nuevo la informaci\u00f3n de todas las figuras.</p> <p>\u200b   f) Escala todas las figuras con escala = 0.1.</p> <p>\u200b   g) Muestra de nuevo la informaci\u00f3n de todas las figuras.</p>"},{"location":"ud09/ud0901/","title":"9.1 Introducci\u00f3n","text":"<p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos.</p> <p>Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.</p> <p>Las bases de datos relacionales permiten organizar los datos en tablas y esas tablas y datos se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>Una base de datos relacional se puede definir de una manera simple como aquella que presenta la informaci\u00f3n en tablas con filas y columnas.</p> <p>Una tabla es una serie de filas y columnas , en la que cada fila es un registro y cada columna es un campo. Un campo representa un dato de los elementos almacenados en la tabla (NSS, nombre, etc.). Cada registro representa un elemento de la tabla (el equipo Real Madrid, el equipo Real Murcia, etc.)</p> <p>No se permite que pueda aparecer dos o m\u00e1s veces el mismo registro, por lo que uno o m\u00e1s campos de la tabla forman lo que se conoce como clave primaria (atributo que se elige como identificador en una tabla, de manera que no haya dos registros iguales, sino que se diferencien al menos en esa clave. Por ejemplo, en el caso de una tabla que guarda datos de personas, el n\u00famero de la seguridad social, podr\u00eda elegirse como clave primaria, pues sabemos que aunque haya dos personas llamadas, por ejemplo, Juan P\u00e9rez P\u00e9rez, estamos seguros de que su n\u00famero de seguridad social ser\u00e1 distinto).</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS) , gestiona el modo en que los datos se almacenan, mantienen y recuperan.</p> <p>En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p> <p>Tradicionalmente, la programaci\u00f3n de bases de datos ha sido como una Torre de Babel: gran cantidad de productos de bases de datos en el mercado, y cada uno \u201chablando\u201d en su lenguaje privado con las aplicaciones.</p> <p>Java, mediante JDBC ( Java Database Connectivity, API que permite la ejecuci\u00f3n de operaciones sobre bases de datos desde el lenguaje de programaci\u00f3n Java, independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se accede), permite simplificar el acceso a base de datos , proporcionando un lenguaje mediante el cual las aplicaciones pueden comunicarse con motores de bases de datos. Sun desarroll\u00f3 este API para el acceso a bases de datos, con tres objetivos principales en mente:</p> <ul> <li>Ser un API con soporte de SQL: poder construir sentencias SQL e insertarlas dentro de llamadas al API de Java,</li> <li>Aprovechar la experiencia de los APIs de bases de datos existentes,</li> <li>Ser sencillo.</li> </ul>"},{"location":"ud09/ud0901/#conexion-a-las-bbdd-conectores","title":"Conexi\u00f3n a las BBDD: conectores","text":"<p>Dejemos de momento de lado el desfase Objeto-Relacional y centr\u00e9monos ahora en el acceso a Base de Datos Relacionales desde los lenguajes de programaci\u00f3n. Lo razonaremos en general y lo aplicaremos a Java.</p> <p>Desde la d\u00e9cada de los 80 que existen a pleno rendimiento las bases de datos relacionales. Casi todos los Sistemas Gestores de Bases de Datos (excepto los m\u00e1s peque\u00f1os como Access o Base de LibreOffice) utilizan la arquitectura cliente-servidor. Esto significa que hay un ordenador central donde est\u00e1 instalado el Sistema Gestor de Bases de Datos Relacional que act\u00faa como servidor, y habr\u00e1 muchos clientes que se conectar\u00e1n al servidor haciendo peticiones sobre la Base de Datos.</p> <p>Los Sistemas Gestores de Bases de Datos inicialmente dispon\u00edan de lenguajes de programaci\u00f3n propios para poder hacer los accesos desde los clientes. Era muy consistente, pero a base de ser muy poco operativo:</p> <ul> <li>La empresa desarrolladora del SGBD deb\u00edan mantener un lenguaje de programaci\u00f3n, que resultaba necesariamente muy costoso, si no quer\u00edan que quedara desfasado.</li> <li>Las empresas usuarias del SGBD, que se conectaban como clientes, se encontraban muy ligadas al servidor para tener que utilizar el lenguaje de programaci\u00f3n para acceder al servidor, lo que no siempre se ajustaba a sus necesidades. Adem\u00e1s, el plantearse cambiar de servidor, significaba que hab\u00eda que rehacer todos los programas, y por tanto una tarea de much\u00edsima envergadura.</li> </ul> <p>Para poder ser m\u00e1s operativos, hab\u00eda que desvincular los lenguajes de programaci\u00f3n de los Sistemas Gestores de Bases de Datos utilizando unos est\u00e1ndares de conexi\u00f3n.</p>"},{"location":"ud09/ud0902/","title":"9.2 JDBC","text":"<p>Java puede conectarse con distintos SGBD y en diferentes sistemas operativos. Independientemente del m\u00e9todo en que se almacenen los datos debe existir siempre un mediador entre la aplicaci\u00f3n y el sistema de base de datos y en Java esa funci\u00f3n la realiza JDBC. </p> <p>A tener en cuenta</p> <p>Para la conexi\u00f3n a las bases de datos utilizaremos la API est\u00e1ndar de JAVA denominada JDBC (Java Data Base Connectivity).</p> <p>JDBC es un API incluido dentro del lenguaje Java para el acceso a bases de datos. Consiste en un conjunto de clases e interfaces escritas en Java que ofrecen un completo API para la programaci\u00f3n con bases de datos, por lo tanto es la \u00fanica soluci\u00f3n 100% Java que permite el acceso a bases de datos.</p> <p>JDBC es una especificaci\u00f3n formada por una colecci\u00f3n de interfaces y clases abstractas, que todos los fabricantes de drivers deben implementar si quieren realizar una implementaci\u00f3n de su driver 100% Java y compatible con JDBC (JDBC-compliant driver). Debido a que JDBC est\u00e1 escrito completamente en Java tambi\u00e9n posee la ventaja de ser independiente de la plataforma. </p> <p>A tener en cuenta</p> <p>No ser\u00e1 necesario escribir un programa para cada tipo de base de datos, una misma aplicaci\u00f3n escrita utilizando JDBC podr\u00e1 manejar bases de datos Oracle, Sybase, SQL Server, etc.</p> <p></p> <p>Adem\u00e1s podr\u00e1 ejecutarse en cualquier sistema operativo que posea una M\u00e1quina Virtual de Java, es decir, ser\u00e1n aplicaciones completamente independientes de la plataforma. Otras APIS que se suelen utilizar bastante para el acceso a bases de datos son DAO (Data Access Objects) y RDO (Remote Data Objects), y ADO (ActiveX Data Objects), pero el problema que ofrecen estas soluciones es que s\u00f3lo son para plataformas Windows.</p> <p>JDBC tiene sus clases en el paquete java.sql y otras extensiones en el paquete javax.sql.</p> <p></p>"},{"location":"ud09/ud0902/#funciones-del-jdbc","title":"Funciones del JDBC","text":"<p>B\u00e1sicamente el API JDBC hace posible la realizaci\u00f3n de las siguientes tareas:</p> <ul> <li>Establecer una conexi\u00f3n con una base de datos.</li> <li>Enviar sentencias SQL.</li> <li>Manipular datos.</li> <li>Procesar los resultados de la ejecuci\u00f3n de las sentencias.</li> </ul>"},{"location":"ud09/ud0902/#drivers-jdbc","title":"Drivers JDBC","text":"<p>Los drivers nos permiten conectarnos con una base de datos determinada. Existen cuatro tipos de drivers JDBC, cada tipo presenta una filosof\u00eda de trabajo diferente. A continuaci\u00f3n se pasa a comentar cada uno de los drivers:</p> <ul> <li>JDBC-ODBC bridge plus ODBC driver (tipo 1): permite al programador acceder a fuentes de  datos ODBC existentes mediante JDBC. El JDBC-ODBC Bridge (puente JDBC-ODBC) implementa operaciones JDBC traduci\u00e9ndolas a operaciones ODBC, se encuentra dentro del paquete sun.jdbc.odbc y contiene librer\u00edas nativas para acceder a ODBC.</li> </ul> <p>\u200b   Al ser usuario de ODBC depende de las dll de ODBC y eso limita la cantidad de plataformas en donde se puede ejecutar la aplicaci\u00f3n.</p> <ul> <li>Native-API partly-Java driver (tipo 2): son similares a los drivers de tipo1, en tanto en cuanto  tambi\u00e9n necesitan una configuraci\u00f3n en la m\u00e1quina cliente. Este tipo de driver convierte llamadas JDBC a llamadas de Oracle, Sybase, Informix, DB2 u otros SGBD. Tampoco se pueden utilizar dentro de applets al poseer c\u00f3digo nativo.</li> <li>JDBC-Net pure Java driver (tipo 3): Estos controladores est\u00e1n escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicaci\u00f3n servidora utilizan las funciones nativas del sistema de gesti\u00f3n de base de datos mediante el uso de una biblioteca JDBC en el servidor. La ventaja de esta opci\u00f3n es la portabilidad.</li> <li>JDBC de Java cliente (tipo 4): Estos controladores est\u00e1n escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicaci\u00f3n servidora utilizan las funciones nativas del sistema de gesti\u00f3n de base de datos sin necesidad de bibliotecas. La ventaja de esta opci\u00f3n es la portabilidad. Son como los drivers de tipo 3 pero sin la figura del intermediario y tampoco requieren ninguna configuraci\u00f3n en la m\u00e1quina cliente. Los drivers de tipo 4 se pueden utilizar para servidores Web de tama\u00f1o peque\u00f1o y medio, as\u00ed como para intranets.</li> </ul>"},{"location":"ud09/ud0902/#instalacion-controlador-mysql","title":"Instalaci\u00f3n controlador MySql","text":"<p>1) El primer paso es descargar desde https://www.mysql.com/products/connector/ el conector apropiado.</p> <p></p> <p>2) Elegir Sistema Operativo y versi\u00f3n:</p> <p></p> <p>3) Haz clic en Donwload y selecciona la opci\u00f3n: No thanks, just start download</p> <p></p> <p>4) Ejecuta el fichero deb (en el caso de Ubuntu) descargado:</p> <p></p> <p>5) Ahora deberemos a\u00f1adir la librer\u00eda JDBC a nuestro proyecto. Para ello copia el archivo <code>mysql-connector-java-8.3.0.jar</code> (en Ubuntu se encuentra en la ruta  <code>/usr/share/java</code>) en a Referenced Libraries de VS Code:</p> <p></p>"},{"location":"ud09/ud0902/#carga-del-controlador-jdbc-y-conexion-con-la-bd","title":"Carga del controlador JDBC y conexi\u00f3n con la BD","text":"<p>El primer paso para conectarnos a una base de datos mediante JDBC es cargar el controlador apropiado. Estos controladores se distribuyen en un archivo <code>.jar</code> que provee el fabricante del SGBD y deben estar accesibles por la aplicaci\u00f3n.</p> <p>Para cargar el controlador se usan las siguientes sentencias:</p> Java<pre><code>import java.sql.*;\npublic class ConnectToMySql {\n  public static void main(String[] args) {\n    try {\n      // Dependiendo de a qu\u00e9 tipo de SGBD queramos conectar cargaremos un controlador u otro\n      // Intentar cargar el driver de MySQL\n      Class&lt;?&gt; c = Class.forName(\"com.mysql.jdbc.Driver\");\n      System.out.println(\"Cargado \" + c.getName());\n\n      //Definir la url de conexi\u00f3n y los par\u00e1metros de usuario y contrase\u00f1a\n      String host = \"jdbc:mysql://localhost:3306/prueba\";\n      String username = \"prueba\";\n      String password = \"1234\";\n      Connection con = DriverManager.getConnection(host, username, password);\n\n      System.out.println(\"Conexi\u00f3n completada\");\n      con.close();\n    } catch (ClassNotFoundException cnfe) {\n      System.out.println(cnfe.getMessage());\n    } catch (SQLException ex) {\n      System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n    }\n  }\n}\n</code></pre> <p>Observamos las siguientes cuestiones:</p> <ul> <li>Como ya hemos comentado alguna vez, la sentencia <code>Class.forName()</code> no ser\u00eda necesaria en muchas aplicaciones. Pero nos asegura que hemos cargado el driver, y por tanto el <code>DriverManager</code> la sabr\u00e1 manejar</li> <li>El <code>DriverManager</code> es capaz de encontrar el driver adecuado a trav\u00e9s de la url proporcionada (sobre todo si el driver est\u00e1 cargado en memoria), y es quien nos proporciona el objeto <code>Connection</code> por medio del m\u00e9todo <code>getConnection()</code>. Hay otra manera de obtener el <code>Connection</code> por medio del objeto <code>Driver</code>, como veremos m\u00e1s adelante, pero tambi\u00e9n ser\u00e1 pasando indirectamente por <code>DriverManager</code>.</li> <li>Si no se encuentra la clase del driver (por no tenerlo en las librer\u00edas del proyecto, o haber escrito mal su nombre) se producir\u00e1 la excepci\u00f3n <code>ClassNotFoundException</code>. Es conveniente tratarla con <code>try ... catch</code>.</li> <li>Si no se puede establecer la conexi\u00f3n por alguna raz\u00f3n se producir\u00e1 la excepci\u00f3n <code>SQLException</code>. Al igual que en el caso anterior, es conveniente tratarla con <code>try ... catch</code>.</li> <li>El objeto <code>Connection</code> mantendr\u00e1 una conexi\u00f3n con la Base de Datos desde el momento de la creaci\u00f3n hasta el momento de cerrarla con <code>close()</code>. Es muy importante cerrar la conexi\u00f3n, no s\u00f3lo para liberar la memoria de nuestro ordenador (que al cerrar la aplicaci\u00f3n liberar\u00eda), sino sobre todo para cerrar la sesi\u00f3n abierta en el Servidor de Bases de Datos.</li> </ul> <p>Una manera de conectar alternativa a las anteriores es utilizando el objeto <code>Driver</code>. La clase <code>java.sql.Driver</code> pertenece a la API JDBC, pero no es instanciable, y tan s\u00f3lo es una interfaz, para que las clases <code>Driver</code> de los contenedores hereden de ella e implementen la manera exacta de acceder al SGBD correspondiente. Como no es instanciable (no podemos hacer new Driver()) la manera de crearlo es a trav\u00e9s del m\u00e9todo <code>getDriver()</code> del <code>DriverManager</code>, que seleccionar\u00e1 el driver adecuado a partir de la url. Ya s\u00f3lo quedar\u00e1n definir algunas propiedades, como el usuario y la contrase\u00f1a, y obtener el <code>Connection</code> por medio del m\u00e9todo <code>connect()</code></p> <p>La manera de conectar a trav\u00e9s de un objeto <code>Driver</code> es m\u00e1s larga, pero m\u00e1s completa ya que se podr\u00edan especificar m\u00e1s cosas. Y quiz\u00e1s ayude a entender el montaje de los controladores de los diferentes SGBD en Java.</p> Java<pre><code>import java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class ConnectToMySqlDriver {\n\n  public static void main(String[] args)  {\n    String url=\"jdbc:mysql://localhost:3306/prueba\";\n    String username = \"prueba\";\n    String password = \"1234\";\n\n    try{\n       Driver driver = DriverManager.getDriver(url);\n\n       Properties properties = new Properties();\n       properties.setProperty(\"user\", username);\n       properties.setProperty(\"password\", password);\n\n       Connection con = driver.connect(url, properties);\n       System.out.println(\"Conexi\u00f3n completada a trav\u00e9s de Driver\");\n       con.close();\n     } catch (SQLException ex) {\n       System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n     }\n  }\n}\n</code></pre>"},{"location":"ud09/ud0902/#carga-del-controlador-y-de-la-conexion-mediante-el-patron-singleton","title":"Carga del controlador y de la conexi\u00f3n mediante el patr\u00f3n Singleton","text":"<p>Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase. Su intenci\u00f3n consiste en garantizar que una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella. El patr\u00f3n <code>Singleton</code> se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna. Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado. Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, \u2026) o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n (en java no hay variables globales) El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:</p> <ul> <li>La propia clase es responsable de crear la \u00fanica instancia.</li> <li>Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.</li> <li>Declara el constructor de clase como privado para que no sea instanciable directamente.</li> </ul> Java<pre><code>/**\n @see https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con\n Patron Singleton\n ================\n Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase.\n Su intenci\u00f3n consiste en garantizar que una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella.\n El patr\u00f3n Singleton se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna.\n Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado.\n Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, ...) o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n.\n El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:\n  - La propia clase es responsable de crear la \u00fanica instancia.\n  - Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.\n  - Declara el constructor de clase como privado (no es instanciable directamente).\n */\npublic class DatabaseConnection {\n  private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase\n  private static java.sql.Connection con;\n\n  private DatabaseConnection() {\n    // El Constructor es privado!!\n  }\n\n  public static DatabaseConnection getInstance(){\n    //Si no hay ninguna instancia...\n    if(dbInstance==null){\n      dbInstance= new DatabaseConnection();\n    }\n      return dbInstance;\n  }\n\n  public static java.sql.Connection getConnection(){\n    if(con==null){\n      try {\n        String host = \"jdbc:mysql://localhost:3306/prueba\";\n        String username = \"prueba\";\n        String password = \"1234\";\n        con = java.sql.DriverManager.getConnection( host, username, password );\n        System.out.println(\"Conexi\u00f3n realizada\");\n      } catch (java.sql.SQLException ex) {\n        System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n      }\n    }\n    return con;\n  }\n}\n</code></pre> <p>En el caso de BlueJ, se a\u00f1aden las librer\u00edas desde Herramientas -&gt; Preferencias -&gt; Librer\u00edas</p> <p></p> <p>Creamos una nueva clase <code>DatabaseConnection</code> en BlueJ:</p> <p></p> <p>Vamos a crear una nueva clase <code>Test</code> para probar la conexi\u00f3n:</p> Java<pre><code>import java.sql.*;\npublic class Test {\n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection();\n    public Test(){\n        //De momento no hace nada\n    }\n}\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"ud09/ud0903/","title":"9.3 Acceso a BBDD","text":"<p>En este apartado se ofrece una introducci\u00f3n a los aspectos fundamentales del acceso a bases de datos mediante c\u00f3digo Java. En los siguientes apartados se explicar\u00e1n algunos aspectos en mayor detalle, sobre todo los relacionados con las clases Statement y ResultSet.</p>"},{"location":"ud09/ud0903/#cargar-el-driver","title":"Cargar el Driver","text":"<p>En un proyecto Java que realice conexiones a bases de datos es necesario, antes que nada, utilizar <code>Class.forname(\u2026).newInstance()</code> para cargar din\u00e1micamente el Driver que vamos a utilizar. Esto solo es necesario hacerlo una vez en nuestro programa. Puede lanzar excepciones por lo que es necesario utilizar un bloque try-catch.</p> Java<pre><code>try {\n    Class.forName(\"com.mysql.cj.jdbc.Driver\").newInstance();        \n} catch (Exception e) {\n    // manejamos el error\n}\n</code></pre> <p>Hay que tener en cuenta que las clases y m\u00e9todos utilizados para conectarse a una base de datos (explicados m\u00e1s adelante) funcionan con todos los drivers disponibles para Java (JDBC es solo uno, hay muchos m\u00e1s). Esto es posible ya que el est\u00e1ndar de Java solo los define como interfaces (interface) y cada librer\u00eda driver los implementa (define las clases y su c\u00f3digo). Por ello es necesario utilizar <code>Class.forName(\u2026)</code> para indicarle a Java qu\u00e9 driver vamos a utilizar.</p> <p></p> <p>Este nivel de asbtracci\u00f3n facilita el desarrollo de proyectos ya que si necesit\u00e1ramos utilizar otro sistema de base de datos (que no fuera MySQL) solo necesitar\u00edamos cambiar la l\u00ednea de c\u00f3digo que carga el driver y poco m\u00e1s. Si cada sistema de base de datos necesitara que utiliz\u00e1ramos distintas clases y m\u00e9todos todo ser\u00eda mucho m\u00e1s complicado.</p> <p>Las cuatro clases fundamentales que toda aplicaci\u00f3n Java necesita para conectarse a una base de datos y ejecutar sentencias son: <code>DriverManager</code>, <code>Connection</code>, <code>Statement</code> y <code>ResultSet</code>. </p> <p></p>"},{"location":"ud09/ud0903/#clase-drivermanager","title":"Clase <code>DriverManager</code>","text":"<p>Paso 1: Establecer conexi\u00f3n con la BBDD</p> Java<pre><code>/* Para MySQL:\n     jdbc  --&gt; driver\n     mysql --&gt; protocolo driver\n     localhost:3306/gestionPedidos --&gt; detalles de la conexi\u00f3n\n*/\njdbc:mysql://localhost:3306/gestionPedidos\n\njdbc:odbc:DSN_gestionPedidos                  // para SQL Server\n\njdbc:oracle:juan@servidor:3306:gestionPedidos // para Oracle\n</code></pre> <p>Vamos a necesitar informaci\u00f3n adicional como son los datos de usuario y contrase\u00f1a.</p> <p>La clase java.sql.DriverManager es la capa gestora del driver JDBC. Se encarga de manejar el Driver apropiado y permite crear conexiones con una base de datos mediante el m\u00e9todo est\u00e1tico <code>getConnection()</code> que tiene dos variantes:</p> <p>\u200b   - <code>DriveManager.getConnection(String url)</code></p> <p>\u200b   - <code>DriveManager.getConnection(String url, String user, String password)</code></p> <p>Este m\u00e9todo intentar\u00e1 establecer una conexi\u00f3n con la base de datos seg\u00fan la URL indicada. Opcionalmente se le puede pasar el usuario y contrase\u00f1a como argumento (tambi\u00e9n se puede indicar en la propia URL). Si la conexi\u00f3n es satisfactoria devolver\u00e1 un objeto Connection.</p> <p>Ejemplo de conexi\u00f3n a la base de datos prueba en localhost:</p> Java<pre><code>String url = \"jdbc:mysql://localhost:3306/prueba\";\nConnection conn = DriverManager.getConnection(url,\"root\",\"\");\n</code></pre> <p>Este m\u00e9todo puede lanzar dos tipos de excepciones (que habr\u00e1 que manejar con un try-catch):</p> <ul> <li>SQLException: la conexi\u00f3n no ha podido producirse. Puede ser por multitud de motivos como una URL mal formada, un error en la red, host o puerto incorrecto, base de datos no existente, usuario y contrase\u00f1a no v\u00e1lidos, etc.</li> <li>SQLTimeOutException: se ha superado el LoginTiemout sin recibir respuesta del servidor.</li> </ul>"},{"location":"ud09/ud0903/#clase-connection","title":"Clase <code>Connection</code>","text":"<p>Paso 2. Crear un objeto Statement</p> <p>Un objeto java.sql.Connection representa una sesi\u00f3n de conexi\u00f3n con una base de datos. Una aplicaci\u00f3n puede tener tantas conexiones como necesite, ya sea con una o varias bases de datos.</p> <p>El m\u00e9todo m\u00e1s relevante es <code>createStatement()</code> que devuelve un objeto Statement asociado a dicha conexi\u00f3n que permite ejecutar sentencias SQL. El m\u00e9todo createStatement() puede lanzar excepciones de tipo SQLException.</p> Java<pre><code>Statement st = conn.createStatement();\n</code></pre> <p>Cuando ya no la necesitemos es aconsejable cerrar la conexi\u00f3n con <code>close()</code> para liberar recursos:</p> Java<pre><code>conn.close();\n</code></pre>"},{"location":"ud09/ud0903/#clase-statement","title":"Clase <code>Statement</code>","text":"<p>Paso 3. Ejecutar sentencia SQL</p> <p>Un objeto java.sql.Statement permite ejecutar sentencias SQL en la base de datos a trav\u00e9s de la conexi\u00f3n con la que se cre\u00f3 el Statement (ver apartado anterior). Los tres m\u00e9todos m\u00e1s comunes de ejecuci\u00f3n de sentencias SQL son <code>executeQuery(\u2026)</code>, <code>executeUpdate(\u2026)</code> y <code>execute(\u2026)</code>. Pueden lanzar excepciones de tipo SQLException y SQLTimeoutException.</p> <ul> <li><code>ResultSet executeQuery(String sql)</code>: ejecuta la sentencia sql indicada (de tipo SELECT). Devuelve un objeto ResultSet con los datos proporcionados por el servidor.  </li> </ul> Java<pre><code>ResultSet rs = st.executeQuery(\"SELECT * FROM vendedores\");\n</code></pre> <ul> <li><code>int executeUpdate(String sql)</code>: ejecuta la sentencia sql indicada (de tipo DML como por ejemplo INSERT, UPDATE o DELETE).  Devuelve un el n\u00famero de registros que han sido insertados, modificados o eliminados.</li> </ul> Java<pre><code>int nr = st.executeUpdate (\"INSERT INTO vendedores VALUES (1,'Pedro Gil', '2017-04-11', 15000);\")\n</code></pre> <p>Cuando ya no lo necesitemos es aconsejable cerrar el statement con <code>close()</code> para liberar recursos:</p> <p><code>java st.close();</code></p> <p>Revisa con cuidado el siguiente ejemplo</p> <p>Podr\u00edamos decir que este resultset es una especie de tabla virtual que se almacena en memoria con la informaci\u00f3n en su interior.</p>"},{"location":"ud09/ud0903/#clase-resultset","title":"Clase <code>ResultSet</code>","text":"<p>Paso 4. Leer el resultset</p> <p>Un objeto java.sql.ResultSet contiene un conjunto de resultados (datos) obtenidos tras ejecutar una sentencia SQL, normalmente de tipo SELECT. Es una estructura de datos en forma de tabla con registros (filas) que podemos recorrer para acceder a la informaci\u00f3n de sus campos (columnas).</p> <p>ResultSet utiliza internamente un cursor que apunta al registro actual sobre el que podemos operar. Inicialmente dicho cursor est\u00e1 situado antes de la primera fila y disponemos de varios m\u00e9todos para desplazar el cursor. El m\u00e1s com\u00fan es <code>next()</code>:</p> <ul> <li><code>boolean next()</code>: mueve el cursor al siguiente registro. Devuelve true si fue posible y false en caso contrario (si ya llegamos al final de la tabla).</li> </ul> <p>Algunos de los m\u00e9todos para obtener los datos del registro actual son:</p> <ul> <li><code>String getString(String columnLabel)</code>: devuelve un dato String de la columna indicada por su nombre. </li> </ul> <p>Por ejemplo: </p> Java<pre><code>rs.getString(\"nombre\");\n</code></pre> <ul> <li><code>String getString(int columnIndex)</code>: devuelve un dato String de la columna indicada por su nombre (la primera columna es la 1, no la cero). </li> </ul> <p>Por ejemplo: </p> Java<pre><code>rs.getString(2);\n</code></pre> <p>Existen m\u00e9todos an\u00e1logos a los anteriores para obtener valores de tipo int, long, float, double, boolean, Date, Time, Array, etc. Pueden consultarse todos en la documentaci\u00f3n oficial de Java.</p> <ul> <li><code>int getInt(String columnLabel)</code></li> <li><code>int getInt(int columnIndex)</code></li> <li><code>double getDouble(String columnLabel)</code></li> <li><code>double getDouble(int columnIndex)</code></li> <li><code>boolean getBoolean(String columnLabel)</code></li> <li><code>boolean getBoolean(int columnIndex)</code></li> <li><code>Date getDate(String columnLabel)</code></li> <li><code>Date getDate(int columnIndex)</code></li> <li>etc.</li> </ul> <p>M\u00e1s adelante veremos c\u00f3mo se realiza la modificaci\u00f3n e inserci\u00f3n de datos.</p> <p>Todos estos m\u00e9todos pueden lanzar una SQLException.</p> <p>Veamos un ejemplo de c\u00f3mo recorrer un ResultSet llamado rs y mostrarlo por pantalla:</p> Java<pre><code>while(rs.next()) {\n    int id = rs.getInt(\"id\");\n    String nombre = rs.getString(\"nombre\");\n    Date fecha = rs.getDate(\"fecha_ingreso\");\n    float salario = rs.getFloat(\"salario\");\n    System.out.println(id + \" \" + nombre + \" \" + fecha + \" \" + salario);\n}\n</code></pre>"},{"location":"ud09/ud0904/","title":"9.4 Navegabilidad y concurrencia","text":"<p>Cuando invocamos a createStatement() sin argumentos, como hemos visto anteriormente, al ejecutar sentencias SQL obtendremos un ResultSet por defecto en el que el cursor solo puede moverse hacia adelante y los datos son de solo lectura. A veces esto no es suficiente y necesitamos mayor funcionalidad.</p> <p>Por ello el m\u00e9todo createStatement() est\u00e1 sobrecargado (existen varias versiones de dicho m\u00e9todo) lo cual nos permite invocarlo con argumentos en los que podemos especificar el funcionamiento.</p> <ul> <li><code>Statement createStatement (int resultSetType, int resultSetConcurrency)</code>: devuelve un objeto Statement cuyos objetos ResultSet ser\u00e1n del tipo y concurrencia especificados. Los valores v\u00e1lidos son constantes definidas en ResultSet.</li> </ul> <p>El argumento resultSetType indica el tipo de ResultSet:</p> <ul> <li><code>ResultSet.TYPE_FORWARD_ONLY</code>: ResultSet por defecto, forward-only y no-actualizable.</li> <li>Solo permite movimiento hacia delante con next().</li> <li>Sus datos NO se actualizan. Es decir, no reflejar\u00e1 cambios producidos en la base de datos. Contiene una instant\u00e1nea del momento en el que se realiz\u00f3 la consulta.</li> <li><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>: ResultSet desplazable y no actualizable.</li> <li>Permite libertad de movimiento del cursor con otros m\u00e9todos como first(), previous(), last(), etc. adem\u00e1s de next().</li> <li>Sus datos NO se actualizan, como en el caso anterior.</li> <li><code>ResultSet.TYPE_SCROLL_SENSITIVE</code>: ResultSet desplazable y actualizable.</li> <li>Permite libertad de movimientos del cursor, como en el caso anterior.</li> <li>Sus datos S\u00cd se actualizan. Es decir, mientras el ResultSet est\u00e9 abierto se actualizar\u00e1 autom\u00e1ticamente con los cambios producidos en la base de datos. Esto puede suceder incluso mientras se est\u00e1 recorriendo el ResultSet, lo cual puede ser conveniente o contraproducente seg\u00fan el caso.</li> </ul> <p>El argumento resultSet.Concurrency indica la concurrencia del ResultSet:</p> <ul> <li> <p>ResultSet.CONCUR_READ_ONLY: solo lectura. Es el valor por defecto.</p> </li> <li> <p>ResultSet.CONCUR_UPDATABLE: permite modificar los datos almacenados en el ResultSet para luego aplicar los cambios sobre la base de datos (m\u00e1s adelante se ver\u00e1 c\u00f3mo).</p> </li> </ul> <p>A tener en cuenta</p> <p>El ResultSet por defecto que se obtiene con createStatement() sin argumentos es el mismo que con createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY).</p>"},{"location":"ud09/ud0905/","title":"9.5 Consultas (Query)","text":""},{"location":"ud09/ud0905/#navegacion-de-un-resultset","title":"Navegaci\u00f3n de un <code>ResultSet</code>","text":"<p>Como ya se ha visto, en un objeto ResultSet se encuentran los resultados de la ejecuci\u00f3n de una sentencia SQL. Por lo tanto, un objeto ResultSet contiene las filas que satisfacen las condiciones de una sentencia SQL, y ofrece m\u00e9todos de navegaci\u00f3n por los registros como next() que desplaza el cursos al siguiente registro del ResultSet.</p> <p>Adem\u00e1s de este m\u00e9todo de desplazamiento b\u00e1sico, existen otros de desplazamiento libre que podremos utilizar siempre y cuando el ResultSet sea de tipo ResultSet.TYPE_SCROLL_INSENSITIVE o ResultSet.TYPE_SCROLL_SENSITIVE como se ha dicho antes.</p> <p>Algunos de estos m\u00e9todos son:</p> <ul> <li><code>void beforeFirst()</code>: mueve el cursor antes de la primera fila.</li> <li><code>boolean first()</code>: mueve el cursor a la primera fila.</li> <li><code>boolean next()</code>: mueve el cursor a la siguiente fila. Permitido en todos los tipos de ResultSet.</li> <li><code>boolean previous()</code>: mueve el cursor a la fila anterior.</li> <li><code>boolean last()</code>: mueve el cursor a la \u00faltima fila.</li> <li><code>void afterLast()</code>: mover el cursor despu\u00e9s de la \u00faltima fila.</li> <li><code>boolean absolute(int row)</code>: posiciona el cursor en el n\u00famero de registro indicado. Hay que tener en cuenta que el primer registro es el 1, no el cero. Por ejemplo absolute(7) desplazar\u00e1 el cursor al s\u00e9ptimo registro. Si  valor es negativo se posiciona en el n\u00famero de registro indicado pero empezando a contar desde el final (el \u00faltimo es el -1). Por ejemplo si tiene 10 registros y llamamos absolute(-2) se desplazar\u00e1 al registro n.\u00ba 9.</li> <li><code>boolean relative(int registros)</code>: desplaza el cursor un n\u00famero relativo de registros, que puede ser positivo o negativo. Por ejemplo si el cursor esr\u00e1 en el registro 5 y llamamos a relative(10) se desplazar\u00e1 al registro 15. Si luego llamamos a relative(-4) se desplazar\u00e1 al registro 11.</li> </ul> <p>Los m\u00e9todos que devuelven un tipo boolean devolver\u00e1n true si ha sido posible mover el cursor a un registro v\u00e1lido, y false en caso contrario, por ejemplo si no tiene ning\u00fan registro o hemos saltado a un n\u00famero de registro que no existe.</p> <p>Todos estos m\u00e9todos pueden producir una excepci\u00f3n de tipo SQLException.</p> <p>Tambi\u00e9n existen otros m\u00e9todos relacionados con la posici\u00f3n del cursor.</p> <ul> <li><code>int getRow()</code>: devuelve el n\u00famero de registro actual. Cero si no hay registro actual.</li> <li><code>boolean isBeforeFirst()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 antes del primer registro.</li> <li><code>boolean isFirst()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 en el primer registro.</li> <li><code>boolean isLast()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 en el \u00faltimo registro.</li> <li><code>boolean isAfterLast()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 despu\u00e9s del \u00faltimo registro.</li> </ul>"},{"location":"ud09/ud0905/#obteniendo-datos-del-resultset","title":"Obteniendo datos del <code>ResultSet</code>","text":"<p>Los m\u00e9todos getXXX() ofrecen los medios para recuperar los valores de las columnas (campos) de la fila (registro) actual del ResultSet. No es necesario que las columnas sean obtenidas utilizando un orden determinado.</p> <p>Para designar una columna podemos utilizar su nombre o bien su n\u00famero (empezando por 1).</p> <p>Por ejemplo si la segunda columna de un objeto ResultSet se llama t\u00edtulo y almacena datos de tipo String, se podr\u00e1 recuperar su valor de las dos formas siguientes:</p> Java<pre><code>// rs es un objeto ResultSet\nString valor = rs.getString(2);\nString valor = rs.getString(\"titulo\");\n</code></pre> <p>Es importante tener en cuenta que las columnas se numeran de izquierda a derecha y que la primera es la n\u00famero 1, no la cero. Tambi\u00e9n que las columnas no son case sensitive, es decir, no distinguen entre may\u00fasculas y min\u00fasculas.</p> <p>A tener en cuenta</p> <p>La informaci\u00f3n referente a las columnas de un ResultSet se puede obtener llamando al m\u00e9todo getMetaData() que devolver\u00e1 un objeto ResultSetMetaData que contendr\u00e1 el n\u00famero, tipo y propiedades de las columnas del ResultSet.</p> <p>Si conocemos el nombre de una columna, pero no su \u00edndice, el m\u00e9todo findColumn() puede ser utilizado para obtener el n\u00famero de columna, pas\u00e1ndole como argumento un objeto String que sea el nombre de la columna correspondiente, este m\u00e9todo nos devolver\u00e1 un entero que ser\u00e1 el \u00edndice correspondiente a la columna.</p>"},{"location":"ud09/ud0905/#tipos-de-datos-y-conversiones","title":"Tipos de datos y conversiones","text":"<p>Cuando se lanza un m\u00e9todo getXXX() determinado sobre un objeto ResultSet para obtener el valor de un campo del registro actual, el driver JDBC convierte el dato que se quiere recuperar al tipo Java especificado y entonces devuelve un valor Java adecuado. Por ejemplo si utilizamos el m\u00e9todo getString() y el tipo del dato en la base de datos es VARCHAR, el driver JDBC convertir\u00e1 el dato VARCHAR de tipo SQL a un objeto String de Java.</p> <p>Algo parecido sucede con otros tipos de datos SQL como por ejemplo DATE. Podremos acceder a \u00e9l tanto con getDate() como con getString(). La diferencia es que el primero devolver\u00e1 un objeto Java de tipo Date y el segundo devolver\u00e1 un String.</p> <p>Siempre que sea posible el driver JDBC convertir\u00e1 el tipo de dato almacenado en la base de datos al tipo solicitado por el m\u00e9todo getXXX(), pero hay conversiones que no se pueden realizar y lanzar\u00e1n una excepci\u00f3n, como por ejemplo si intentamos hacer un getInt() sobre un campo que no contiene un valor num\u00e9rico.</p>"},{"location":"ud09/ud0905/#sentencias-que-no-devuelven-datos","title":"Sentencias que no devuelven datos","text":"<p>Las ejecutamos con el m\u00e9todo <code>executeUpdate</code>. Ser\u00e1n todas las sentencias SQL excepto el SELECT, que es la de consulta. Es decir, nos servir\u00e1 para las siguientes sentencias:</p> <ul> <li>Sentencias que cambian las estructuras internas de la BD donde se guardan los datos (instrucciones conocidas con las siglas DDL, del ingl\u00e9s Data Definition Language), como por ejemplo <code>CREATE TABLE</code>, <code>CREATE VIEW</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, \u2026,</li> <li>Sentencias para otorgar permisos a los usuarios existentes o crear otros nuevos (subgrupo de instrucciones conocidas como DCL o Data Control Language), como por ejemplo <code>GRANT</code>.</li> <li>Y tambi\u00e9n las sentencias para modificar los datos guardados utilizando las instrucciones <code>INSERT</code>, <code>UPDATE</code> y <code>DELETE</code>.</li> </ul> <p>Aunque se trata de sentencias muy dispares, desde el punto de vista de la comunicaci\u00f3n con el SGBD se comportan de manera muy similar, siguiendo el siguiente patr\u00f3n:</p> <ol> <li>Instanciaci\u00f3n del <code>Statement</code> a partir de una conexi\u00f3n activa.</li> <li>Ejecuci\u00f3n de una sentencia SQL pasada por par\u00e1metro al m\u00e9todo <code>executeUpdate</code>.</li> <li>Cierre del objeto <code>Statement</code> instanciado.</li> </ol> <p>Miremos este ejemplo, en el que vamos a crear una tabla muy sencilla en la Base de Datos MySql/network.</p> <p>Nota</p> <p>En este enlace ten\u00e9is la clase DatabaseConnection.</p> Java<pre><code>import java.sql.Connection; \nimport java.sql.DriverManager; \nimport java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class Test {\n  static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n  public Test(){ \n      //De momento no hace nada \n  }\n\n  public void createTable() throws SQLException{ \n      Statement st = con.createStatement(); \n      st.executeUpdate(\"CREATE TABLE T1 (c1 varchar(50))\"); \n      st.close(); \n  }\n}\n</code></pre>"},{"location":"ud09/ud0905/#sentencias-que-devuelven-datos","title":"Sentencias que devuelven datos","text":"<p>Las ejecutamos con el m\u00e9todo <code>executeQuery</code>. Servir\u00e1 para la sentencia SELECT, que es la de consulta. Los datos que nos devuelva esta sentencia las tendremos que guardar en un objeto de la clase <code>java.sql.ResultSet</code>, es decir conjunto de resultado. Por lo tanto, la ejecuci\u00f3n de las consultas tendr\u00e1 un forma similar a la siguiente:</p> Java<pre><code>ResultSet rs = st.executeQuery(sentenciaSQL);\n</code></pre> <p>El objeto <code>ResultSet</code> contiene el resultado de la consulta organizado por filas, por lo que en cada momento se puede consultar una fila. Para ir visitando todas las filas de una a una, iremos llamando el m\u00e9todo <code>next()</code> del objeto <code>ResultSet</code>, ya que cada vez que se ejecute <code>next</code> avanzar\u00e1 a la siguiente fila. Inmediatamente despu\u00e9s de una ejecuci\u00f3n, el <code>ResultSet</code> se encuentra posicionado justo antes de la primera fila, por lo tanto para acceder a la primera fila ser\u00e1 necesario ejecutar <code>next</code> una vez. Cuando las filas se acaban, el m\u00e9todo <code>next</code> devolver\u00e1 falso.</p> <p>Desde cada fila se podr\u00e1 acceder al valor de sus columnas con ayuda de varios m\u00e9todos <code>get</code> disponibles seg\u00fan el tipo de datos a devolver y pasando por par\u00e1metro el n\u00famero de columna que deseamos obtener. El nombre de los m\u00e9todos comienza por <code>get</code> seguido del nombre del tipo de datos. As\u00ed, si queremos recuperar la segunda columna, sabiendo que es un dato de tipo <code>String</code> habr\u00e1 que ejecutar:</p> Java<pre><code>rs.getInt(1);\n</code></pre> <p>Las columnas se empiezan a contar a partir del valor 1 (no cero). La mayor parte de los SGDB soportan la posibilidad de pasar por par\u00e1metro el nombre de la columna, pero no todos, as\u00ed que normalmente se opta por el par\u00e1metro num\u00e9rico.</p> <p>Por ejemplo MySql s\u00ed que deja acceder por nombre, por tanto, suponiendo que el campo 1 se llama id, tambi\u00e9n se puede hacer:</p> Java<pre><code>rs.getInt(\"id\");\n</code></pre> <p>En este ejemplo accedemos a la tabla usuarios y mostramos todos sus registros</p> Java<pre><code>public void getAllUsers() throws SQLException{ \n    Statement st = con.createStaemnt(); \n    ResultSet rs = st.executeQuery(\"SELECT FROM usuarios\"); \n    while (rs.next()){ \n        System.out.print(rs.getInt(1) + \"\\t\"); \n        system.out.print(rs.getString(2) + \"\\t\"); \n        system.out.println(rs.getString(3)); \n    }\n    //Siempre se debe cerrar lodo lo Muerto \n    st.close(); \n    rs.close(); \n}\n</code></pre>"},{"location":"ud09/ud0905/#asegurar-la-liberacion-de-recursos","title":"Asegurar la liberaci\u00f3n de recursos","text":"<p>Las instancias de <code>Connection</code> y las de <code>Statement</code> guardan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras contin\u00faan activas mantienen en el SGBD una sesi\u00f3n abierta, que supondr\u00e1 un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. Es importante cerrar estos objetos para liberar recursos tanto del cliente como del servidor.</p> <p>Si en un mismo m\u00e9todo debemos cerrar un objeto <code>Statement</code> y el <code>Connection</code> a partir del cual la hemos creado, se deber\u00e1 cerrar primero el <code>Statement</code> y despu\u00e9s el <code>Connection</code>. Si lo hacemos al rev\u00e9s, cuando intentamos cerrar el <code>Statement</code> nos saltar\u00e1 una excepci\u00f3n de tipo <code>SQLException</code>, ya que el cierre de la conexi\u00f3n le habr\u00eda dejado inaccesible.</p> <p>Adem\u00e1s de respetar el orden, asegurar la liberaci\u00f3n de los recursos situando las operaciones de cierre dentro de un bloque <code>finally</code>. De este modo, aunque se produzcan errores, no se dejar\u00e1n de ejecutar las instrucciones de cierre.</p> <p>Hay que tener en cuenta todav\u00eda un detalle m\u00e1s cuando sea necesario realizar el cierre de varios objetos a la vez. En este caso, aunque las situamos una tras otra, todas las instrucciones de cierre dentro del bloque <code>finally</code>, no ser\u00eda suficiente garant\u00eda para asegurar la ejecuci\u00f3n de todos los cierres, ya que, si mientras se produce el cierre de un los objetos se lanza una excepci\u00f3n, los objetos invocados en una posici\u00f3n posterior a la del que se ha producido el error no se cerrar\u00e1n.</p> <p>La soluci\u00f3n de este problema pasa por evitar el lanzamiento de cualquier excepci\u00f3n durante el proceso de cierre. Una posible forma es encapsular cada cierre entre sentencias <code>try-catch</code> dentro del <code>finally</code>.</p> Aqu\u00ed ten\u00e9is un ejemplo Java<pre><code>private void getAllUsers() {\n    Statement st = null;\n    ResultSet rs = null; \n\n    try { \n        st = con.createStatement(); \n        rs = st.executeQuery(\"SELECT * FROM usuarios\"); \n\n        while (rs.next()){ \n            System.out.print(rs.getInt(1) + \"\\t\"); \n            system.out.print(rs.getString(2) + \"\\t\"); \n            System.out.println(rs.getString(3)); \n        }\n    } catch(SQLException e){ \n        System.out.println \"Se ha producido un error al leer los usuarios. Mensaje: \" + e.getMessage());\n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierto\n            if (st != null) {\n                st.close();\n            }\n        } catch (java.sql.SQLException ex){ \n            System.out.printIn(\"Se ha producido un error: \" + ex.getMessage()); \n        }\n        try{ \n            //Siempre se debe cerrar todo lo abierto \n            if (rs != null) {\n                rs.close();\n            }\n        } catch (java.sql.SQLException ex){ \n            System.out.printIn(\"Se ha producido un error: \" + ex.getMessage()); \n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0906/","title":"9.6 Modificaci\u00f3n (update)","text":"<p>Para poder modificar los datos que contiene un ResultSet necesitamos un ResultSet de tipo modificable. Para ello debemos utilizar la constante <code>ResultSet.CONCUR_UPDATABLE</code> al llamar al m\u00e9todo <code>createStatement()</code> como se ha visto antes.</p> <p>Para modificar los valores de un registro existente se utilizan una serie de m\u00e9todos <code>updateXXX()</code> de ResultSet. Las XXX indican el tipo del dato y hay tantos distintos como sucede con los m\u00e9todos getXXX() de este mismo interfaz: updateString(), updateInt(), updateDouble(), updateDate(), etc.</p> <p>La diferencia es que los m\u00e9todos <code>updateXXX()</code> necesitan dos argumentos:</p> <ul> <li>La columna que deseamos actualizar (por su nombre o por su n\u00famero de columna).</li> <li>El valor que queremos almacenar en dicha columna (del tipo que sea).</li> </ul> <p>Por ejemplo para modificar el campo \u2018edad\u2019 almacenando el entero 28 habr\u00eda que llamar al siguiente m\u00e9todo, suponiendo que rs es un objeto ResultSet:</p> Java<pre><code>rs.updateInt(\"edad\", 28);\n</code></pre> <p>Tambi\u00e9n podr\u00eda hacerse de la siguiente manera, suponiendo que la columna edad es la segunda:</p> Java<pre><code>rs.updateInt(2, 28);\n</code></pre> <p>Los m\u00e9todos updateXXX() no devuelven ning\u00fan valor (son de tipo void). Si se produce alg\u00fan error se lanzar\u00e1 una SQLException.</p> <p>Posteriormente hay que llamar a updateRow() para que los cambios realizados se apliquen sobre la base de datos. El Driver JDBC se encargar\u00e1 de ejecutar las sentencias SQL necesarias. Esta es una caracter\u00edstica muy potente ya que nos facilita enormemente la tarea de modificar los datos de una base de datos. Este m\u00e9todo devuelve void.</p> <p>En resumen, el proceso para realizar la modificaci\u00f3n de una fila de un ResultSet es el siguiente:</p> <ol> <li>Desplazamos el cursor al registro que queremos modificar.</li> <li>Llamamos a todos los m\u00e9todos updateXXX(...) que necesitemos.</li> <li>Llamamos a <code>updateRow()</code> para que los cambios se apliquen a la base de datos.</li> </ol> <p>Es importante entender que hay que llamar a updateRow() antes de desplazar el cursor. Si desplazamos el cursor antes de llamar a updateRow(), se perder\u00e1n los cambios.</p> <p>Si queremos cancelar las modificaciones de un registro del ResultSet podemos llamar a <code>cancelRowUpdates()</code>, que cancela todas las modificaciones realizadas sobre el registro actual.</p> <p>Si ya hemos llamado a updateRow() el m\u00e9todo cancelRowUpdates() no tendr\u00e1 ning\u00fan efecto.</p> <p>El siguiente c\u00f3digo de ejemplo muestra c\u00f3mo modificar el campo \u2018direcci\u00f3n\u2019 del \u00faltimo registro de un ResultSet que contiene el resultado de una SELECT sobre la tabla de clientes. Supondremos que conn es un objeto Connection previamente creado:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = st.executeQuery(sql);\n// Vamos al \u00faltimo registro, lo modificamos y actualizamos la base de datos\nrs.last();\nrs.updateString(\"direccion\", \"C/ Pepe Ciges, 3\");\nrs.updateRow();\n</code></pre>"},{"location":"ud09/ud0907/","title":"9.7 Inserci\u00f3n (insert)","text":"<p>Para insertar nuevos registros necesitaremos utilizar, al menos, estos dos m\u00e9todos:</p> <ul> <li><code>void moveToInsertRow()</code>: desplaza el cursor al registro de inserci\u00f3n. Es un registro especial utilizado para insertar nuevos registros en el ResultSet. Posteriormente tendremos que llamar a los m\u00e9todos updateXXX() ya conocidos para establecer los valores del registro de inserci\u00f3n. Para finalizar hay que llamar a insertRow().</li> <li><code>void insertRow()</code>: inserta el registro de inserci\u00f3n en el ResultSet, pasando a ser un registro normal m\u00e1s, y tambi\u00e9n lo inserta en la base de datos.</li> </ul> <p>El siguiente c\u00f3digo inserta un nuevo registro en la tabla clientes. Supondremos que conn es un objeto Connection previamente creado:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = st.executeQuery(sql);\n// Creamos un nuevo registro y lo insertamos\nrs.moveToInsertRow();\nrs.updateString(2,\"Killy Lopez\");\nrs.updateString(3,\"Wall Street 3674\");\nrs.insertRow();\n</code></pre> <p>Los campos cuyo valor no se haya establecido con updateXXX() tendr\u00e1n un valor NULL. Si en la base de datos dicho campo no est\u00e1 configurado para admitir nulos se producir\u00e1 una SQLException.</p> <p>Tras insertar nuestro nuevo registro en el objeto ResultSet podremos volver a la anterior posici\u00f3n en la que se encontraba el cursor (antes de invocar moveToInsertRow() ) llamando al m\u00e9todo <code>moveToCurrentRow()</code>. Este m\u00e9todo s\u00f3lo se puede utilizar en combinaci\u00f3n con moveToInsertRow().</p> Ejemplo 1 Java<pre><code>public void insertUser(){ \n    Statement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES ('Carlos', 'S\u00e1nchez')\";\n    try { \n        st = con.createStatement(); \n        st.executeUpdate(sql); \n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierta \n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> Ejemplo 2: m\u00e9todo pas\u00e1ndole nombre y apellidos Java<pre><code>public void insertUser(String nombre, String apellidos){ \n    Statement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES ('\" + nombre + \"', '\" + apellidos + \"')\";\n    try { \n        st = con.createStatement(); \n        st.executeUpdate(sql); \n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierta \n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0908/","title":"9.8 Borrado (delete)","text":"<p>Para eliminar un registro solo hay que desplazar el cursor al registro deseado y llamar al m\u00e9todo:</p> <ul> <li><code>void deleteRow()</code>: elimina el registro actual del ResultSet y tambi\u00e9n de la base de datos.</li> </ul> <p>El siguiente c\u00f3digo borra el tercer registro de la tabla <code>clientes</code>:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = stmt.executeQuery(sql);\n// Desplazamos el cursor al tercer registro\nrs.absolute(3)\nrs.deleteRow();\n</code></pre>"},{"location":"ud09/ud0909/","title":"9.9 Sentencias predefinidas","text":"<p>Para solucionar el problema de crear sentencias sql complejas, se utiliza <code>PreparedStatement</code>.</p> <p>JDBC dispone de un objeto derivado del <code>Statement</code> que se llama <code>PreparedStatement</code>, al que se le pasa la sentencia SQL en el momento de crearlo, no en el momento de ejecutar la sentencia (como pasaba con <code>Statement</code>). Y adem\u00e1s esta sentencia puede admitir par\u00e1metros, lo que nos puede ir muy bien en determinadas ocasiones.</p> <p>De cualquier modo, <code>PreparedStatement</code> presenta ventajas sobre su antecesor <code>Statement</code> cuando nos toque trabajar con sentencias que se hayan de ejecutar varias veces. La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda al SGBD ser\u00e1 compilada antes de ser ejecutada.</p> <ul> <li>Utilizando un objeto <code>Statement</code>, cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda <code>executeUpdate</code> o bien v\u00eda <code>executeQuery</code>, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres.</li> <li>En cambio, al <code>PreparedStament</code> la sentencia nunca var\u00eda y por lo tanto se puede compilar y guardar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarse. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n.</li> </ul> <p>En algunos sistemas gestores, adem\u00e1s, usar <code>PreparedStatements</code> puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema guarde las respuestas en la memoria cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida.</p> <p>La principal diferencia de los objetos <code>PreparedStatement</code> en relaci\u00f3n a los <code>Statement</code>, es que en los primeros se les pasa la sentencia SQL predefinida en el momento de crearlo. Como la sentencia queda predefinida, ni los m\u00e9todos <code>executeUpdate</code> ni <code>executeQuery</code> requerir\u00e1n ning\u00fan par\u00e1metro. Es decir, justo al rev\u00e9s que en el <code>Statement</code>.</p> <p>Los par\u00e1metros de la sentencia se marcar\u00e1n con el s\u00edmbolo de interrogaci\u00f3n (?) Y se identificar\u00e1n por la posici\u00f3n que ocupan en la sentencia, empezando a contar desde la izquierda a partir del n\u00famero 1. El valor de los par\u00e1metros se asignar\u00e1 utilizando el m\u00e9todo espec\u00edfico, de acuerdo con el tipo de datos a asignar. El nombre empezar\u00e1 por <code>set</code> y continuar\u00e1 con el nombre del tipo de datos (ejemplos: <code>setString</code>, <code>setInt</code>, <code>setLong</code>, <code>setBoolean</code> \u2026). Todos estos m\u00e9todos siguen la misma sintaxis:</p> Java<pre><code>setXXXX(&lt;posici\u00f3nEnLaSentenciaSQL&gt;, &lt;valor&gt;);\n</code></pre> <p>Este es el mismo m\u00e9todo para insertar un usuario pero usando <code>PreparedStatement</code>:</p> Java<pre><code>public void insertUserPrepared(String nombre, String apellidos){ \n    PreparedStatement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES (?, ?)\";\n\n    try { \n        st = con.preparedStatement(sql); \n        st.setString(1, nombre);\n        st.setString(2, apellidos);\n        st.executeUpdate(sql); \n\n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n\n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierto\n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Fijaos que ahora, adem\u00e1s, la sentencia sql es mucho m\u00e1s f\u00e1cil de escribir.</p>"},{"location":"ud09/ud0910/","title":"9.10 Trabajar con Sqlite","text":"<p>Para poder trabajar en casa, vamos a utilizar Sqlite que es un una base de datos sencilla que se guarda en un \u00fanico archivo en disco.</p> <p>Lo primero es instalar SQLite, en Ubuntu:</p> Bash<pre><code>sudo apt install sqlite3\n</code></pre> <p>Si quer\u00e9is hacerlo en Windows, pod\u00e9is seguir las instrucciones en http://www.sqlitetutorial.net/download-install-sqlite/.</p> <p>Para poder trabajar en Java, hemos de descargar el conector, desde http://www.sqlitetutorial.net/sqlite-java/sqlite-jdbc-driver/.</p> <p>Lo primero que hemos de hacer es crear una base de datos, desde la l\u00ednea de comandos. Para ello nos situamos en el directorio del proyecto y la creamos en el directorio <code>bd</code> mediante el siguiente comando:</p> Bash<pre><code>cd directorio-del-proyecto\n# directorio-del-proyecto: src/sources\nmkdir bd\ncd bd\nsqlite network.bd\n</code></pre>"},{"location":"ud09/ud0910/#instalar-sqlitestudio","title":"Instalar SQLiteStudio","text":"<p>Desde estos enlaces:</p> <p>\u200b   https://sqlitestudio.pl/ (Ubuntu) y</p> <p>\u200b   https://github.com/pawelsalawa/sqlitestudio/releases (otras plataformas),</p> <p>podemos instalar una aplicaci\u00f3n gr\u00e1fica para trabajar (m\u00e1s f\u00e1cilmente) con SQLite.</p> <p></p> <p>Mediante estos comandos creamos una base de datos en disco llamada prudb.bd.</p> <p>Ahora podemos crear las tablas mediante VSCode, a\u00f1adiendo una nueva <code>DataBaseConnection</code>, al igual que hicimos con MySql (previamente hemos de crear el <code>Driver Definition</code>).</p> SQL<pre><code>CREATE TABLE usuarios (\n id INTEGER PRIMARY KEY AUTOINCREMENT,\n  nombre VARCHAR(50) NOT NULL,\n  apellidos VARCHAR(255) NOT NULL\n);\n\n\nCREATE TABLE posts (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  texto VARCHAR(255) NOT NULL,\n  likes INTEGER NOT NULL,\n  fecha timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  id_usuario INTEGER NOT NULL,\n  FOREIGN KEY (id_usuario) REFERENCES usuarios(id)\n);\n\n\nCREATE TABLE comentarios (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  texto VARCHAR(255) NOT NULL,\n  fecha timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  id_usuario INTEGER  NOT NULL,\n  id_post INTEGER  NOT NULL,\n  FOREIGN KEY (id_usuario) REFERENCES usuarios(id),\n  FOREIGN KEY (id_post) REFERENCES posts(id)\n);\n</code></pre> <p>Y vamos a a\u00f1adir el .jar que hemos descargado al Build path.</p> <p>As\u00ed que elegimos el jar desde Build Path -&gt; Libraries -&gt; Add External JARs.</p> <p></p> <p>Y ahora modificamos <code>DatabaseConnection</code>:</p> Java<pre><code> String host = \"jdbc:sqlite:src/main/resources/network\";\n con = java.sql.DriverManager.getConnection( host);\n</code></pre> <p>Y hacemos una prueba para ver si funciona:</p> Java<pre><code>import java.sql.SQLException; \n\npublic class Main { \n\n      public static void main(String[] args) { \n          // TODO Aute-generated mettod stub \n          Test t = new Test(); \n          t.insertUser(); \n\n          try {\n              t.getellUsers(); \n          } catch (SQLException sqle) { \n              System.out.println(sqle.getMessage()); \n          }\n          t.closeConnection(); \n      }\n}\n</code></pre> <p>Y este debe ser el resultado:</p> Bash<pre><code>Conexi\u00f3n realizada\n1   Janet   Espinosa\n</code></pre>"},{"location":"ud09/ud0910/#ejemplos","title":"Ejemplos","text":"<p>Vamos a crear una peque\u00f1a base de datos para Empleados en Sqlite:</p> Num Nombre Departamento Edad Sueldo 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 <p>Primero creamos un nuevo Proyecto en VSCode llamado <code>EmpleadosBD</code> y le a\u00f1adimos la librer\u00eda sqlite al build path.</p> <p>Creamos tambi\u00e9n la base de datos mediante la l\u00ednea de comandos:</p> Bash<pre><code>cd directorio-del-proyecto\nmkdir bd\ncd bd\nsqlite empleados.bd\n</code></pre> <p>Copiamos el archivo <code>DatabaseConnection.java</code> del anterior proyecto y modificamos la cadena de conexi\u00f3n:</p> Java<pre><code>String host = \"jdbc:sqlite:./bd/empleados.bd\";\ncon = java.sql.DriverManager.getConnection( host);\n</code></pre>"},{"location":"ud09/ud0910/#crear-tabla","title":"Crear tabla","text":"<p>Creamos una clase <code>CreateTable</code> para poder crear la tabla:</p> Java<pre><code>import java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class CreateTable {\n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n    public static vold main(String[] args) { \n        Statement st = null; \n        String sql = \"CREATE TABLE empleados ( \" + \n                     \" num INTEGER PRIMARY KEY, \" + \n                     \" nombre VARCHAR(255), \" +\n                     \" departamento INTEGER, \" + \n                     \" edad INTEGER, \" + \n                     \" sueldo REAL);\"; \n        try { \n            st = con.createStatement(); \n            st.executeUpdate(sql); \n        } catch (sQLException ex) { \n            system.out.println(\"Error \" + ex.getMessage()); \n        } finally {\n            try {\n                if (st != null &amp;&amp; !st.isClosed()) {\n                    st.close(); \n                }\n            } catch (SQLException ex) { \n                system.out.println (\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n            }\n            try {\n                if (con != null &amp;&amp; !con.isClosed()) {\n                    con.close(); \n                }\n            } catch (SQLException ex) { \n                system.out.println (\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0910/#insertar-datos","title":"Insertar datos","text":"<p>Y creamos otra para insertar datos. Esta vez lo haremos con <code>PreparedStatement</code>:</p> Java<pre><code>import java.sql.PreparedStatement; \nimport java.sql.SQLException; \n\npublic class InsertData { \n  static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      PreparedStatement st = null;\n      String sql = \"INSERT INTO empleados (num, nombre, departamento, edad, sueldo) VALUES (?, ?, ?, ?, ?)\"; \n      try { \n          st = con.prepareStatement(sql); \n          st.setlnt(1, 1); \n          st.setString(2, \"Andreu\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 32); \n          st.setDouble(5, 1000.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 2); \n          st.setString(2, \"Bernat\"); \n          st.setlnt(3, 20); \n          st.setlnt(4, 28); \n          st.setDouble(5, 1200.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 3); \n          st.setString(2, \"Claudia\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 26);\n          st.setDouble(5, 1400.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 4); \n          st.setString(2, \"Dami\u00e1n\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 40); \n          st.setDouble(5, 1300.0); \n          st.executeUpdate(); \n\n      } catch (SQLException ex) { \n          System.out.println(\"Error \" + ex.getMessage()); \n\n      } finally { \n          try { \n              if (st != null &amp;&amp; !st.isClosed()) { \n                  st.close(); \n              } \n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\"); \n          } \n\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) { \n                  con.close(); \n              } \n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar Connection por alguna raz\u00f3n\"); \n          } \n      }\n  }\n}\n</code></pre> <p>Esta es la versi\u00f3n con <code>Statement</code>:</p> Java<pre><code>import java.sql.Statement; \nimport java.sql.SQLException; \n\npublic class InsertDataStatement { \n  static java.sql.Connection con = Databaseconnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      Statement st = null; \n      String sql = \"\"; \n\n      try { \n          st = con.createStatement();\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALUES (5, 'Arturo', 10, 32, 1088.8)\"; \n          st.executeUpdate(sql); \n\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALSES (6, 'Juan', 28, 28, 1280.8)\";\n          st.executeUpdate(sql); \n\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALUES (2, 'Mart\u00edn', 10, 26, 1488.8)\"; \n          st.executeUpdate(sql); \n\n      } catch (SQLEXCeptiOn ex) {\n          System.ont.println(\"Error: \"+ ex.getMesSege());\n\n      } finally {\n          try { \n              if (st != null &amp;&amp; !st.isClosed()) {\n                  st.close(); \n              }\n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) {\n                  con.close(); \n              }\n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n      }\n  }\n}\n</code></pre>"},{"location":"ud09/ud0910/#consultar-datos","title":"Consultar datos","text":"<p>Creamos una clase <code>getAllEmpleados</code> que nos devuelva todos los empleados:</p> Java<pre><code>import java.sql.Resultset; \nimport java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class getAllEmpleados { \n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n    public static void main(String[] args) { \n        Statement st = null; \n        Resultset rs = null; \n\n        try {\n            st = con.createStatement(); \n            rs = st.executeQuery(\"SELECT * FROM empleados\"); \n            System.out.println(\"N\u00fam. \\tNombre \\tDep \\tEdad \\tSueldo\"); \n            System.out.println(\"------------------------------------------\");\n            while (rs.next()){ \n                System.out.print(rs.getInt(1) + \"\\t\"); \n                system.out.print(rs.getString(2) + \"\\t\"); \n                system.out.print(rs.getInt(3) + \"\\t\"); \n                system.out.print(rs.getInt(4) + \"\\t\"); \n                System.out.println(rs.getDouble(5)); \n\n        } catch(SQLException e) { \n                System.out.println(\"Se ha producido un error al leer los usuarios \" + e.getMessage());           \n\n        } finally { \n            try { \n                //Siempre se debe cerrar todo lo abierto \n                if (st != null) {\n                    st.close(); \n                }\n            } catch (java.sql.SQLException ex){\n                System.out.println(\"Se ha producido un error: \" + ex.getMessage()); \n            }\n            try { \n                //Siempre se debe cerrar todo lo abierto \n                if (rs != null) {\n                    rs.close(); \n                }\n            } catch (java.sql.SQLException ex){\n                System.out.println(\"Se ha producido un error: \" + ex.getMessage()); \n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0910/#modificar-datos","title":"Modificar datos","text":"<p>Ahora modificamos los datos. Simplemente aumentamos el sueldo un 5% y modificamos el departamento del empleado 3, poni\u00e9ndole el departamento 3.</p> Java<pre><code>import java.sql.Statement; \nimport java.sql.SQLException; \n\npublic class ModifyData { \n  static java.sql.Connection con = Databaseconnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      Statement st = null; \n      String sql = \"\";\n      try {\n          st = con.createStatement(); \n          sql = \"UPDATE EMPLEADOS SET sueldo = sueldo * 1.05\";\n          st.executeUpdate(sql);\n\n          sql = \"UPDATE EMPLEADOS SET departamento = 20 WHERE num = 3\";\n          st.executeUpdate(sql); \n\n      } catch (SQLException ex) { \n          system.out.printlnr(\"Error \"+ ex.getMessage());\n\n      } finally { \n          try { \n              if (st != null &amp;&amp; !st.isClosed()) { \n                  st.close(); \n              } \n          } catch (SQLException ex) { \n              system.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) { \n                  con.close(); \n              } \n          } catch (SQLException ex) { \n              system.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n      }\n  }\n}\n</code></pre>"},{"location":"ud09/ud0911/","title":"9.11 Repository pattern","text":"<p>Descarga</p> <p>Descarga la base de datos desde aqu\u00ed.</p> <p>En este apartado vamos a aprender a a\u00f1adir a un proyecto orientado a objetos la persistencia en base de datos, sin usar ninguna tecnolog\u00eda como Hibernate.</p> <p>Partimos de una aplicaci\u00f3n en la que los usuarios pueden escribir Posts y comentar Posts hechos por otros usuarios. Por lo que existen tres entidades: Users, Posts y Comments. En la siguiente imagen se muestran estas entidades representadas en una base de datos:</p> <p></p> <p>En programaci\u00f3n existen una serie de est\u00e1ndares denominados Patrones de Dise\u00f1o que debes conocer para poder programar seg\u00fan estos patrones y no reinventar la rueda.</p> <p>Nota</p> <p>Nosotros vamos a implementar \u201cRepository Pattern\u201d porque tambi\u00e9n os va a servir para cualquier aplicaci\u00f3n tanto web, m\u00f3vil o de escritorio.</p> <p>Seg\u00fan la documentaci\u00f3n de Android.</p> <p>The repository pattern is a design pattern that isolates the data layer from the rest of the app. The data layer refers to the part of your app, separate from the UI, that handles the app\u2019s data and business logic, exposing consistent APIs for the rest of your app to access this data.</p>"},{"location":"ud09/ud0911/#database-connection","title":"Database Connection","text":"<p>Esta es la misma clase del apartado anterior:</p> Java<pre><code>/*\n * @see &lt;a href=\"https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con\"&gt;Stackoverflow Singleton&lt;/a&gt;\n * Patron Singleton\n * ================\n * Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase. Su intenci\u00f3n consiste en garantizar que\n * una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella.\n * El patr\u00f3n Singleton se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna.\n * Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado.\n * Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes\n * para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, ...)\n * o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n.\n * El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:\n * - La propia clase es responsable de crear la \u00fanica instancia.\n * - Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.\n * - Declara el constructor de clase como privado para que no sea instanciable directamente.\n */\npublic class DatabaseConnection\n{\n    private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase\n    private static java.sql.Connection con;\n\n    private DatabaseConnection() {\n        // El Constructor es privado!!\n    }\n\n    public static DatabaseConnection getInstance(){\n        //Si no hay ninguna instancia...\n        if(dbInstance==null){\n            dbInstance= new DatabaseConnection();\n        }\n        return dbInstance;\n    }\n\n    public  static java.sql.Connection getConnection(){\n\n        if(con==null){\n            try {\n                String host = \"jdbc:sqlite:src/main/resources/network\";\n                con = java.sql.DriverManager.getConnection( host );\n                System.out.println(\"Conexi\u00f3n realizada\");\n            } catch (java.sql.SQLException ex) {\n                System.out.println(\"Se ha producido un error al conectar: \" + ex.getMessage());\n            }\n        }\n\n        return con;\n    }\n}\n</code></pre>"},{"location":"ud09/ud0911/#interfaz-irepository","title":"Interfaz IRepository","text":"<p>Vamos a empezar creando la interfaz <code>IRepository</code> que han de implementar todas las clases que accedan a datos.</p> Java<pre><code>import java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\npublic interface IRepository&lt;T&gt; {\n    List&lt;T&gt; findAll() throws SQLException;\n    T findById(int id) throws SQLException;\n    void save(T entity)  throws SQLException;\n    void delete(T entity) throws SQLException ;\n    T bdToEntity(ResultSet rs) throws SQLException ;\n}\n</code></pre> <p>Fijaos en la notaci\u00f3n <code>&lt;T&gt;</code>. Esto indica que vamos a usar tipos gen\u00e9ricos. Puede ser cualquier clase de java.</p> <ul> <li><code>findAll()</code> va a recuperar datos de la base de datos y va a crear una lista de objetos <code>T</code>, donde <code>T</code>ser\u00e1 usuario, post o comentario.</li> <li><code>findById(int id)</code> va a recuperar el objeto <code>T</code> con dicho <code>id</code></li> <li><code>save(T entity)</code> va a guardar el objeto <code>T</code> en la base de datos</li> <li><code>deleteById(User user)</code> va a borrar el objeto <code>user</code> en la base de datos</li> <li><code>bdToEntity(Resulset s)</code> va a encargarse de convertir un registro de la base de datos en una clase de tipo <code>T</code>, por ejemplo un usuario, un post o un comentario.</li> </ul>"},{"location":"ud09/ud0911/#socialnetworkservice","title":"SocialNetworkService","text":"<p>Un servicio es un tipo de clase que gestiona recursos que se usan en cualquier parte de la aplicaci\u00f3n. Es este caso estamos definiendo el recurso <code>java.sql.Connection</code>:</p> Java<pre><code>public class SocialNetworkService {\n\n    static  final java.sql.Connection connection = DatabaseConnection.getInstance().getConnection();\n    public static java.sql.Connection getConnection(){\n        return connection;\n    }\n}\n</code></pre> <p>M\u00e1s adelante lo usaremos en le m\u00e9todo <code>main</code></p>"},{"location":"ud09/ud0911/#user","title":"User","text":"<p>Esta es la clase que va a almacenar los datos de la base de datos. Es una clase <code>POJO (Plain Old Java Object)</code></p> Java<pre><code>import java.util.ArrayList;\n\npublic class User\n{\n    private int id;\n    private String name;\n    private String lastName;\n\n    public User()\n    {\n        this.name = \"\";\n        this.lastName = \"\";\n        this.id = -1;\n    }\n    public User(int id, String name, String lastName){\n        this.id = id;\n        this.name = name;\n        this.lastName = lastName;\n    }\n    public User(String name, String lastName)\n    {\n        this(-1, name, lastName);\n    }\n    public int getId(){\n        return id;\n    }\n    public void setId(int id){\n        this.id = id;\n    }\n    public String getName(){\n        return name;\n    }\n    public void setName(String name){\n        this.name = name;\n    }\n    public String getLastName(){\n        return lastName;\n    }\n    public void setLastName(String lastName){\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString(){\n        return \"ID: \" + id + \" Name: \" + name + \" Lastname: \" + lastName;\n    }\n\n}\n</code></pre>"},{"location":"ud09/ud0911/#userrepositoryimpl","title":"UserRepositoryImpl","text":"<p>Esta clase va a ser la que realice el mapeo entre la base de datos y los objetos del modelo de datos de tal forma que va a corregir el llamado desfase objeto-relacional. B\u00e1sicamente consiste en convertir los registros de la base de datos en objetos y almacenar en la base de datos los objetos de mi modelo.</p> Java<pre><code>import java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UserRepositoryImpl implements IRepository&lt;User&gt; {\n    private java.sql.Connection con;\n    public UserRepositoryImpl(){\n        this.con = SocialNetworkService.getConnection();\n    }\n\n    /**\n     * Se encarga de mapear um registro de la base de datos para converirlo en un objeto User\n     * @param rs\n     * @return Un objeto User\n     * @throws SQLException\n     */\n    public User bdToEntity(ResultSet rs) throws SQLException {\n        return new User(rs.getInt(\"id\"), rs.getString(\"name\"), rs.getString(\"lastName\"));\n    }\n\n    /**\n     * Consulta todos los registros de la tabla users\n     * @return Una lista de objetos User\n     * @throws SQLException\n     */\n    public List&lt;User&gt; findAll() throws SQLException {\n\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n\n        Statement st = this.con.createStatement();\n        //Ejecutar la consulta, guardando los datos devueltos en un Resulset\n        ResultSet rs = st.executeQuery(\"SELECT * FROM users ORDER BY lastName, name\");\n\n        while(rs.next()){\n            //Mapeamos el registro de la BD en un User\n            User u =  bdToEntity(rs);\n            //A\u00f1adir el User al conjunto de users\n            users.add(u);\n        }\n        return users;\n    }\n    //De momento estos tres m\u00e9todos no hacen nada pero hacen falta para poder probar findAll\n    public User findById(int id) throws SQLException {\n        return new User();\n    }\n   public void save(User user) throws SQLException{\n\n    }\n\n    public void delete(User user) throws SQLException {\n\n    }\n}\n</code></pre> <p>Para que pueda compilar esta clase es necesario que est\u00e9n implementados (aunque no hagan nada) todos los m\u00e9todos de la interfaz <code>IRepository</code> por eso el cuerpo del m\u00e9todo no hace nada.</p>"},{"location":"ud09/ud0911/#socialnetwork","title":"SocialNetwork","text":"<p>Esta clase va a contener el m\u00e9todo <code>main</code>. De momento vamos a probar que podemos listar los usuarios de la aplicaci\u00f3n.</p> Java<pre><code>import java.sql.SQLException;\nimport java.util.List;\n\npublic class SocialNetwork {\n\n    public static void main(String[] args) throws SQLException {\n\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        List&lt;User&gt; userList = userRepository.findAll();\n        for (User u : userList){\n            System.out.println(u);\n        }\n    }\n}\n</code></pre> <p>Y la salida:</p> Bash<pre><code>ID: 4 Name: Janet Lastname: Espinosa\nID: 6 Name: Maria Lastname: Gallardo\nID: 3 Name: Andr\u00e9s Lastname: Garc\u00eda\nID: 8 Name: Alberto Lastname: Gracia\nID: 14 Name: Juan Lastname: Imedio\nID: 13 Name: Juan Lastname: Marqu\u00e9s\nID: 18 Name: Pedro Lastname: Mart\u00ednez\nID: 12 Name: Juan Lastname: Mar\u00eda\nID: 23 Name: Juan Pedro Lastname: Pascal\nID: 5 Name: Pepe Lastname: Ponz\n</code></pre>"},{"location":"ud09/ud0911/#userrepositoryimpl-ii","title":"UserRepositoryImpl II","text":"<p>Ya podemos finalizar <code>UserRepositoryImpl</code> con los m\u00e9todos que faltan.</p> Java<pre><code>/**\n * Busca un usuario por id en la tabla users\n * @param id\n * @return El objeto User o null si no existe\n * @throws SQLException\n */\n\npublic User findById(int id) throws SQLException {\n    PreparedStatement st = con.prepareStatement(\"SELECT * FROM users WHERE id = ? \");\n    st.setInt(1, id);\n\n    ResultSet rs = st.executeQuery();\n    User u = null;\n    //Si la consulta devuelve alg\u00fan resultado ...\n    if (rs.next()){\n        // ... lo mapeamos a un objeto Usuario\n        u = bdToEntity(rs);\n    }\n    //Devolvemos el Usuario ya mapeado\n    return u;\n}\n</code></pre> <p>Devolvemos el <code>User</code> si existe en la tabla users</p> Java<pre><code>/**\n     * Guarda el usuario User en la base de datos, insertando si id es distinto de -1 o actualizando aqu\u00e9l\n     * registro con dicho id\n     * @param user\n     * @throws SQLException\n     */\npublic void save(User user) throws SQLException{\n    if (user.getId() == -1){\n        ResultSet rs;\n        PreparedStatement st = null;\n        String query = \"INSERT INTO users (name, lastName) VALUES (?, ?)\";\n        //Fij\u00e1os en Statement.RETURN_GENERATED_KEYS. Permite recuperar el campo ID autogenerado por MySql\n        st = con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);\n\n        st.setString(1, user.getName());\n        st.setString(2, user.getLastName());\n\n        st.executeUpdate();\n\n        //Recuperar el id autogenerado\n        rs = st.getGeneratedKeys();\n        //Este ResultSet solo puede contener un registro: el ID autogenerado\n\n        if (rs.next()){\n            //Ahora ya sabemos cu\u00e1l es el nuevo id del Usuario\n            user.setId(rs.getInt(1));\n            System.out.println(\"Autogenerated ID:  \" + user.getId());\n        }\n    }else{\n        PreparedStatement st = con.prepareStatement(\"UPDATE users SET name = ?, lastName = ? WHERE id = ?\");\n        st.setString(1, user.getName());\n        st.setString(2, user.getLastName());\n        st.setInt(3, user.getId());\n\n        st.executeUpdate();\n    }\n\n}\n</code></pre> <p>En esta caso estamos convirtiendo objetos <code>User</code> en registros de la base de datos users.</p> Java<pre><code>/**\n * Elimina de la base de datos el usuario user\n * @param user\n * @throws SQLException\n */\npublic void delete(User user) throws SQLException {\n    PreparedStatement st = con.prepareStatement(\"DELETE FROM users WHERE id = ?\");\n    st.setInt(1, user.getId());\n    st.executeUpdate();\n    st.close();\n}\n</code></pre> <p>Y por \u00faltimo, borramos un objeto de su correspondiente usuario en la base de datos.</p> <p>Nota:</p> <p>Estos ser\u00edan los componentes necesarios para implementar el patr\u00f3n repositorio.</p> <p>Resumiendo: - tenemos la interfaz <code>IRepository</code> - tenemos n clases <code>POJO</code> - por cada clase <code>POJO</code> creamos una clase <code>nombreDeClaseRepositoryImpl</code> que implemente la interfaz <code>IRepository</code> - Tambi\u00e9n creamos la clase <code>nombreDeClaseController</code> que se va a encargar de gestionar el interfaz de usuario</p>"},{"location":"ud09/ud0911/#usercontroller","title":"UserController","text":"<p>Por \u00faltimo vamos a implementar una clase llamada <code>UserController</code> que nos va a servir como User Interface UI para nuestra aplicaci\u00f3n. Esta clase ya no forma parte del patr\u00f3n repositorio y pasar\u00eda a forma parte m\u00e1s bien del patr\u00f3n Model View Controller (MVC) pues esta clase se encarga de la parte Controller (y en este caso, tambi\u00e9n View)</p> Java<pre><code>import java.sql.SQLException;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class UserController {\n\n    /**\n     * Imprime por pantalla todos los usuarios\n     * @throws SQLException\n     */\n    public static void prinAllUsers() throws SQLException {\n\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        List&lt;User&gt; users = userRepository.findAll();\n        for (User user : users){\n            System.out.println(user);\n        }\n\n    }\n    /**\n     * Muestra una interfaz  de usuario para a\u00f1adir un usuario\n     * @throws SQLException\n     */\n    public static void addUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Name: \");\n        String name = sc.nextLine();\n        System.out.print(\"Lastname: \");\n        String lastName = sc.nextLine();\n        User user = new User(name, lastName);\n        userRepository.save(user);\n    }\n\n    /**\n     * Muestra la UI para modificar un usuario\n     * @throws SQLException\n     */\n    public static void modifyUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        prinAllUsers();\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Enter User id to modify: \");\n        int userId = sc.nextInt();\n        sc.nextLine();\n        System.out.print(\"New name: \");\n        String name = sc.nextLine();\n        System.out.print(\"New lastname: \");\n        String lastName = sc.nextLine();\n        userRepository.save(new User(userId, name, lastName));\n    }\n\n    /**\n     * Muestra la UI para borrar un usuario.\n     * @throws SQLException\n     */\n    public static void deleteUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        prinAllUsers();\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter user id to delete: \");\n        User user = userRepository.findById(sc.nextInt());\n        userRepository.delete(user);\n    }\n}\n</code></pre> <p>En los m\u00e9todos <code>addUser</code>, <code>updateUser</code> y <code>deleteUser</code> se piden datos por pantalla y se llama al m\u00e9todo del repositorio correspondiente: <code>userRepository.save</code> o <code>userRepository.delete</code></p>"},{"location":"ud09/ud0911/#posts","title":"Posts","text":"<p>Crea las clases necesarias para poder trabajar con la entidad <code>Post</code>. Como ayuda, ten en cuenta que esta entidad tiene un objeto de la clase <code>User</code> que deber\u00e1s recuperar mediante <code>new UserRepositoryImpl().findById(rs.getInt(\"userId\"))</code></p> <p>Lo m\u00e1s complicado ser\u00e1 la parte <code>1</code> en <code>User</code> ya que debe tener un m\u00e9todo que fije los <code>Post</code> de dicho usuario.</p> <p>En principio ser\u00eda tan f\u00e1cil como hacer en el m\u00e9todo <code>bdToEntity</code> de <code>UserRepositoryImpl</code></p> <p><code>java PostRepositoryImpl repository = new PostRepositoryImpl(); user.setPosts(repository.findByUser(user));</code> </p> <p>Pero esto provoca un error en tiempo de ejecuci\u00f3n <code>StackOverflow</code> debido a que entra en un bucle infinito ya que el m\u00e9todo <code>bdToEntity</code> llama a <code>findByUser</code> que a su vez llama a <code>bdToEntity</code> y as\u00ed hasta el infinito.</p> <p>La soluci\u00f3n es guardar los elementos en cach\u00e9: cada vez que convierto una entidad a objeto la guardo en esta cach\u00e9. Cuando debo mapear alg\u00fan registro primero miro en cach\u00e9 y devuelvo la entidad o mapeo si no existe la entidad.</p> <p>Creamos una variable de instancia en cada Repositorio. Por ejemplo para UserRepositoryImpl</p> Java<pre><code>private Set&lt;User&gt; usersCached = new HashSet&lt;&gt;();\n</code></pre> <p>Creamos un m\u00e9todo para comprobar si est\u00e1 en cach\u00e9:</p> Java<pre><code>private User getUserCached(int i){\n    for(User user : usersCached){\n        if (user.getId() == i) \n            return user;\n    }\n    return null;\n}\n</code></pre> <p>Que usamos en <code>bdToEntity</code></p> Java<pre><code>public User bdToEntity(ResultSet rs) throws SQLException {\n    User user = getUserCached(rs.getInt(\"id\"));\n    if (user == null) {\n        user = new User(rs.getInt(\"id\"), rs.getString(\"name\"), rs.getString(\"lastName\"));\n        usersCached.add(user);\n        PostRepositoryImpl repository = new PostRepositoryImpl();\n        user.setPosts(repository.findByUser(user));\n    }\n    return user;\n}\n</code></pre> <p>Nota:</p> <p>No cre\u00e1is que en la pr\u00e1ctica es tan complicado. Para eso est\u00e1n los frameworks ORM (Object Relational Mapping) que nos facilitan mucho la vida y ellos mismos ya tratan todo el tema de cach\u00e9s, repositorios, CRUD, etc. Este apartado es simplemente para que cre\u00e9is desde cero un mini framework.</p> <p>Seguramente en la empresa utilizar\u00e9is Hibernate, Spring Boot, Doctrine, \u2026</p> <p>Comments</p> <p>Ahora ya puedes implementar la gesti\u00f3n del los comentarios.</p>"},{"location":"ud09/ud0912/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li>https://www.youtube.com/playlist?list=PLNjWMbvTJAIjLRW2qyuc4DEgFVW5YFRSR</li> <li>https://www.youtube.com/playlist?list=PLaxZkGlLWHGUWZxuadN3J7KKaICRlhz5-</li> </ul>"},{"location":"ud09/ud0913/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>FXDocs</li> <li>https://openjfx.io/openjfx-docs/</li> </ul>"},{"location":"ud09/ud09ej/","title":"Ejercicios","text":"<p>Ejercicio 1</p> <p>...</p> <p>Ejercicio 2 : completo</p> <p>Veamos un ejemplo completo de conexi\u00f3n y acceso a una base de datos utilizando todos los elementos mencionados en este apartado.</p> Java<pre><code>try {\n  // Cargamos la clase que implementa el Driver\n  Class.forName(\"com.mysql.cj.jdbc.Driver\").newInstance();\n\n  // Creamos una nueva conexi\u00f3n a la base de datos 'prueba'\n  String url = \"jdbc:mysql://localhost:3306/prueba?serverTimezone=UTC\";\n\n  Connection conn = DriverManager.getConnection(url,\"root\",\"\");\n\n  // Obtenemos un Statement de la conexi\u00f3n\n  Statement st = conn.createStatement();\n\n  // Ejecutamos una consulta SELECT para obtener la tabla vendedores\n  String sql = \"SELECT * FROM vendedores\";\n\n  ResultSet rs = st.executeQuery(sql);\n\n  // Recorremos todo el ResultSet y mostramos sus datos\n\n  while(rs.next()) {\n    int id        = rs.getInt(\"id\");\n    String nombre = rs.getString(\"nombre\");\n    Date fecha    = rs.getDate(\"fecha_ingreso\");\n    float salario = rs.getFloat(\"salario\");\n    System.out.println(id + \" \" + nombre + \" \" + fecha + \" \" + salario);\n  }\n  // Cerramos el statement y la conexi\u00f3n\n  st.close();\n  conn.close();\n\n} catch (SQLException e) {\n    e.printStackTrace();\n\n} catch (Exception e) {\n    e.printStackTrace();\n}\n</code></pre> <p>Ejercicio 3</p> <p>Crea una aplicaci\u00f3n que nos permita gestionar la base de datos network. </p> <p>Debe tener un men\u00fa desde el que se puedan gestionar (Create, Read, Update, Delete) usuarios, posts y comentarios.</p>"}]}