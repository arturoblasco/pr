{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":""},{"location":"#indice-de-unidades","title":"\u00cdndice de unidades","text":"unidad UD 00 Conocimientos previos UD 01 Elementos de un programa inform\u00e1tico UD 02 Utilizaci\u00f3n de objetos y clases UD 03 Estructuras de control y excepciones UD 04 Estructuras de datos Arrays y matrices. Recursividad UD 05 Desarrollo de clases UD 06 Lectura y escritura de informaci\u00f3n UD 07 Colecciones UD 08 Composici\u00f3n, Herencia y Polimorfismo UD 09 Acceso a bases de datos UD 10 Interfaz gr\u00e1fica <p>Licencia</p> <p> Este material est\u00e1 bajo una Licencia Creative Commons Atribuci\u00f3n-Compartir-Igual 4.0 Internacional. Derivado a partir de material de David Mart\u00ednez Pe\u00f1a (https://github.com/martinezpenya).</p>"},{"location":"default/","title":"UD 10 Interfaz gr\u00e1fica","text":""},{"location":"ud06/ud0601/","title":"6.1 Streams (flujos)","text":"<p>Los programas Java realizan las operaciones de entrada y salida a trav\u00e9s de lo que se denominan streams (traducido, flujos**). </p> <p>Un stream es una abstracci\u00f3n de todo aquello que produzca o consuma informaci\u00f3n. Podemos ver a este stream como una entidad l\u00f3gica que, por otra parte, se encontrar\u00e1 vinculado con un dispositivo f\u00edsico. La eficacia de esta forma de implementaci\u00f3n radica en que las operaciones de entrada y salida que el programador necesita manejar son las mismas independientemente del dispositivo con el que estemos actuando. Ser\u00e1 Java quien se encargue de manejar el dispositivo concreto, ya se trate del teclado, el monitor, un sistema de ficheros o un socket de red, etc., liberando a nuestro c\u00f3digo de tener que saber con qui\u00e9n est\u00e1 interactuando.</p>"},{"location":"ud06/ud0601/#clasificacion-de-los-streams","title":"Clasificaci\u00f3n de los Streams","text":"<p>En Java los streams se materializan en un conjunto de clases y subclases, contenidas en el paquete <code>java.io</code>. Todas las clases para manejar streams parten, de cuatro clases abstractas: </p> <ul> <li><code>InputStream</code></li> <li><code>OutputStream</code></li> <li><code>Reader</code></li> <li><code>Writer</code></li> </ul> Streams Orientados a car\u00e1cter Orientados a bytes Para lectura Reader InputStream Para escritura Writer OutputStream"},{"location":"ud06/ud0601/#streams-orientados-a-byte-byte-streams","title":"Streams orientados a byte (byte streams)","text":"<p>Proporcionan un medio adecuado para el manejo de entradas y salidas de bytes y su uso l\u00f3gicamente est\u00e1 orientado a la lectura y escritura de datos binarios. El tratamiento del flujo de bytes viene gobernado por dos clases abstractas que son <code>InputStream</code> y <code>OutputStream</code>. </p> <p>Cada una de estas clases abstractas tiene varias subclases concretas que controlan las diferencias entre los distintos dispositivos de I/O que se pueden utilizar. As\u00ed mismo, estas dos clases son las que definen los m\u00e9todos que sus subclases tendr\u00e1n implementados y, de entre todas, destacan las operaciones <code>read()</code> y <code>write()</code> que leen y escriben bytes de datos respectivamente.</p> <p></p>"},{"location":"ud06/ud0601/#streams-orientados-a-caracter-character-streams","title":"Streams orientados a car\u00e1cter (character streams)","text":"<p>Proporciona un medio conveniente para el manejo de entradas y salidas de caracteres. Dichos flujos usan codificaci\u00f3n Unicode y, por tanto, se pueden internacionalizar. </p> <p>Observaci\u00f3n</p> <p>Este es un modo que Java nos proporciona para manejar caracteres, pero al nivel m\u00e1s bajo todas las operaciones de I/O son orientadas a byte. Al igual que el anterior, el flujo de caracteres tambi\u00e9n viene gobernado por dos clases abstractas: <code>Reader</code> y <code>Writer</code>. Dichas clases manejan flujos de caracteres Unicode; y tambi\u00e9n de ellas derivan subclases concretas que implementan los m\u00e9todos definidos en ellas siendo los m\u00e1s destacados los m\u00e9todos <code>read()</code> y <code>write()</code> que, en este caso, leen y escriben caracteres de datos respectivamente.</p> <p></p> <p>Como hemos comentado, tanto en <code>Reader</code> como en <code>InputStream</code> encontramos un m\u00e9todo <code>read()</code>, en concreto public int read(). Observar la diferencia entre estos dos m\u00e9todos nos ayudar\u00e1 a comprender la diferencia entre los flujos orientados a byte y los orientados a car\u00e1cter. </p> m\u00e9todo devuelve <code>int InputStream.read()</code> valor entre 0 y 255 <code>int Reader.read()</code> valor entre 0 y 65535 <p>A pesar de llamarse igual, <code>InputStream.read()</code> devuelve el siguiente byte de datos le\u00eddo del stream. El valor que devuelve est\u00e1 entre 0 y 255 (\u00f3 -1 si se ha llegado al final del stream). <code>Reader.read()</code>, sin embargo, devuelve un valor entre 0 y 65535 (\u00f3 -1 si se ha llegado al final del stream), correspondiente al siguiente car\u00e1cter simple le\u00eddo del stream.</p>"},{"location":"ud06/ud0601/#stream-estandar","title":"Stream est\u00e1ndar","text":"<p>Existen una serie de stream de uso com\u00fan a los cuales se denomina stream est\u00e1ndar. El sistema se encarga de crear estos stream autom\u00e1ticamente. </p> <ul> <li><code>System.in</code></li> <li>Instancia de la clase <code>InputStream</code>: flujo de bytes de entrada.</li> <li>M\u00e9todos:<ul> <li><code>read()</code> permite leer un byte de la entrada como entero.</li> <li><code>skip(n)</code> ignora <code>n</code> bytes de la entrada.</li> <li><code>available()</code> n\u00famero de bytes disponibles para leer en la entrada.</li> </ul> </li> <li><code>System.out</code></li> <li>Instancia de la clase <code>PrintStream</code>: flujo de bytes de salida.</li> <li>M\u00e9todos:<ul> <li>para impresi\u00f3n de datos: <code>print()</code>, <code>println()</code>.</li> <li><code>flush()</code> vac\u00eda el buffer de salida escribiendo su contenido.</li> </ul> </li> <li><code>System.err</code></li> <li>Funcionamiento similar a <code>System.out</code>.</li> <li>Se utiliza para enviar mensajes de error (por ejemplo a un fichero de log o a la consola).</li> </ul> <p>Observaci\u00f3n</p> <p>Por defecto, <code>System.in</code>, <code>System.out</code> y <code>System.err</code> se encuentran asociados a la consola (teclado y pantalla), pero es posible redirigirlos a otras fuentes o destinos, como por ejemplo a un fichero.</p>"},{"location":"ud06/ud0601/#utilizacion-de-streams","title":"Utilizaci\u00f3n de Streams","text":"<p>Para utilizar un stream hay que seguir una serie de pasos:</p> <ul> <li> <p>Lectura:</p> </li> <li> <p>Abrir el stream asociado a una fuente de datos (creaci\u00f3n del objeto stream):</p> <ul> <li> <p>Teclado.</p> </li> <li> <p>Fichero.</p> </li> <li> <p>Socket remoto.</p> </li> </ul> </li> <li> <p>Mientras existan datos disponibles:</p> <ul> <li>Leer datos.</li> </ul> </li> <li> <p>Cerrar el stream (m\u00e9todo <code>close</code>).</p> </li> <li> <p>Escritura:</p> </li> <li> <p>Abrir el stream asociado a una fuente de datos (creaci\u00f3n del objeto stream):</p> <ul> <li> <p>Pantalla.</p> </li> <li> <p>Fichero.</p> </li> <li> <p>Socket local.</p> </li> </ul> </li> <li> <p>Mientras existan datos disponibles:</p> <ul> <li>Escribir datos.</li> </ul> </li> <li> <p>Cerrar el stream (m\u00e9todo <code>close</code>).</p> </li> </ul> <p>Nota</p> <ul> <li>Los streams est\u00e1ndar ya se encarga el sistema de abrirlos y cerrarlos.</li> <li>Un fallo en cualquier punto del proceso produce una <code>IOException</code>.</li> </ul>"},{"location":"ud06/ud0601/#las-clases-inputstream-y-outputstream","title":"Las clases <code>InputStream</code> y <code>OutputStream</code>","text":"<p>Como hemos dicho anteriormente, proporcionan m\u00e9todos para leer y escribir, respectivamente, un byte de informaci\u00f3n, a trav\u00e9s de sus m\u00e9todos <code>read()</code> y <code>write()</code>.</p> clase m\u00e9todos descripci\u00f3n <code>InputStream</code> <code>int read()</code> Lee un byte de informaci\u00f3n y lo devuelve como un entero cuyo valor estar\u00e1 entre 0 y 255.Si se detecta el final de los datos de entrada devuelve -1. <code>OutputStream</code> <code>write (int b)</code> Escribe un byte de informaci\u00f3n en el stream. El par\u00e1metro es entero, pero si su valor es superior a 255 se escriben los 8 bits de menos peso (los m\u00e1s a la derecha)."},{"location":"ud06/ud0601/#las-clases-reader-y-writer","title":"Las clases <code>Reader</code> y <code>Writer</code>","text":"<p>Permiten, respectivamente, leer y escribir un car\u00e1cter en el stream.</p> clase m\u00e9todos descripci\u00f3n <code>Reader</code> <code>int read()</code> Lee un car\u00e1cter unicode de informaci\u00f3n y lo devuelve como un entero cuyo valor estar\u00e1 entre 0 y 65565.Si se detecta el final de los datos de entrada devuelve -1. <code>Writer</code> <code>write (int c)</code> Escribe un car\u00e1cter unicode en el stream. El par\u00e1metro es entero y corresponder\u00e1 al c\u00f3digo Unicode del car\u00e1cter que se escribe."},{"location":"ud06/ud0601/#las-clases-inputstreamreader-y-outputstreamwriter","title":"Las clases <code>InputStreamReader</code> y <code>OutputStreamWriter</code>","text":"<p>Son clases que act\u00faan de puente entre streams orientados a bytes y streams orientados a car\u00e1cter. Podemos, por ejemplo, crear un <code>InputStreamReader</code> asociado a un <code>InputStream</code> y leer caracteres del <code>InputStream</code> asociado, a trav\u00e9s del <code>InputStreamReader</code>.</p> clase m\u00e9todos descripci\u00f3n <code>InputStreamReader</code> <code>InputStreamReader(inputStream)</code> <code>int read()</code> Constructor: El objeto se crea a partir de un <code>InputStream</code> (orientado a byte). Leer\u00e1 informaci\u00f3n del <code>inputStream</code> asociado y la devolver\u00e1 en forma de caracteres. Se puede indicar el charset a utilizar.Lee un car\u00e1cter del <code>InputStream</code> asociado. <code>OutputStreamWriter</code> <code>OutputStreamWriter(outputStream)</code><code>write(int c)</code> Constructor: Crea el objeto asoci\u00e1ndolo a un <code>outputStream</code>, en el que escribir\u00e1 bytes. Se puede indicar el charset a utilizar.Escribe el car\u00e1cter indicado en el <code>OutputStream</code> asociado."},{"location":"ud06/ud0601/#buffering","title":"Buffering","text":"<p>Las clases <code>BufferedReader</code>, <code>BufferedWritter</code>, <code>BufferedInputStream</code> y <code>BufferedOutputStream</code> permiten realizar buffering.</p> <p>Situadas \"por delante\" de un stream acumulan las operaciones de lectura y escritura en una memoria o buffer y cuando hay suficiente informaci\u00f3n las operaciones se realizan finalmente sobre el dispositivo f\u00edsico.</p> <p>Mantienen las mismas operaciones de lectura y escritura que sus clases padre pero, como hemos dicho, reducen el n\u00famero de accesos al dispositivo f\u00edsico por el uso de buffers.</p> clase m\u00e9todos descripci\u00f3n <code>BufferedReader</code> <code>BufferedWriter</code> <code>String readLine()</code><code>void write(String s)</code><code>void newLine()</code> Adem\u00e1s de los m\u00e9todos heredados, encontramos otros que permiten leer Strings completos, escribir una l\u00ednea completa de texto y hacer saltos de l\u00ednea. <code>BufferedInputStream</code> <code>BufferedOutputStream</code> Mantienen las mismas operaciones de lectura y escritura que sus clases padre pero, como hemos dicho, reducen el n\u00famero de accesos al dispositivo f\u00edsico por el uso de buffers."},{"location":"ud06/ud0601/#datainputstream-y-dataoutputstream","title":"<code>DataInputStream</code> y <code>DataOutputStream</code>","text":"<p>Realizan una transformaci\u00f3n de la informaci\u00f3n antes de ser escrita o despu\u00e9s de ser le\u00edda. Los bytes le\u00eddos o escritos se interpretan como datos correspondientes a los tipos primitivos de Java.</p> clase m\u00e9todos descripci\u00f3n <code>DataInputStream</code><code>DataOutputStream</code> <code>read()</code>,<code>readInt()</code>, <code>readDouble()</code>, <code>readUTF()</code><code>write()</code>,<code>writeInt()</code>,<code>writeDouble()</code>,<code>writeUTF()</code> \u2026 Que permiten leer y escribir informaci\u00f3n correspondiente a los distintos tipos de datos de Java."},{"location":"ud06/ud0601/#printwriter","title":"<code>PrintWriter</code>","text":"clase m\u00e9todos descripci\u00f3n <code>PrintWriter</code> <code>print()</code> <code>println()</code> Esta clase (a la que pertenece <code>System.out</code>) tiene los m\u00e9todos <code>print</code> y <code>println</code>, que escriben en el stream de salida datos binarios representados en forma de cadenas de caracteres."},{"location":"ud06/ud0601/#combinacion-de-streams","title":"Combinaci\u00f3n de Streams","text":"<p>En muchas ocasiones, una sola clase de las vistas no nos da la funcionalidad necesaria para poder hacer la tarea que se requiere. En tales casos es necesario combinar (anidar) varios Streams de manera que unos act\u00faan como origen de informaci\u00f3n de los otros, o unos escriben sobre los otros.</p> <p>En este caso tendr\u00edamos que combinar tres clases:</p> Java<pre><code>BufferedReader b = new BufferedReader(new InputStreamReader(System.in));\n</code></pre> Ejemplo: est\u00e1ndar de entrada <p>Veamos un ejemplo en el que se lee por teclado hasta pulsar la tecla de retorno, en ese momento el programa acabar\u00e1 imprimiendo por la salida est\u00e1ndar la cadena le\u00edda. Para ir construyendo la cadena con los caracteres le\u00eddos podr\u00edamos usar la clase <code>StringBuffer</code> o la <code>StringBuilder</code>. La clase <code>StringBuffer</code> permite almacenar cadenas que cambiar\u00e1n en la ejecuci\u00f3n del programa. <code>StringBuilder</code> es similar, pero no es s\u00edncrona. De este modo, para la mayor\u00eda de las aplicaciones, donde se ejecuta un solo hilo, supone una mejora de rendimiento sobre <code>StringBuffer</code>. El proceso de lectura ha de estar en un bloque <code>try..catch</code>. Java<pre><code>package UD06.P1_Flujos;\n\nimport java.io.IOException;\n\npublic class P1_1_FlujoEstandarEntrada {\n\n  public static void main(String[] args) {\n    // Cadena donde iremos almacenando los caracteres que se escriban\n    StringBuilder str = new StringBuilder();\n    char c;\n    // Por si ocurre una excepci\u00f3n ponemos el bloque try-cath\n    try {\n       // Mientras la entrada de terclado no sea Intro\n       while ((c = (char) System.in.read()) != '\\n') {\n          // A\u00f1adir el character le\u00eddo a la cadena str\n          str.append(c);\n       }\n    } catch (IOException ex) {\n       System.out.println(\"ERROR: \" + ex.getMessage());\n    }\n    // Escribir la cadena que se ha ido tecleando\n    System.out.println(\"Cadena introducida: \" + str);\n  }\n}\n</code></pre></p> Ejemplo: est\u00e1ndar de salida <p>En el siguiente ejemplo se pide introducir texto hasta que se introduzca una l\u00ednea con el texto \"salir\". Dicho texto se almacenar\u00e1 en un fichero <code>salida.txt</code>. El proceso debe de estar en un bloque <code>try..catch</code>. Java<pre><code>package UD06.P1_Flujos;\n\nimport java.io.BufferedReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class P1_2_FlujoEstandarSalida {\n\n  public static void main(String[] args) {\n    try {\n      PrintWriter out = new PrintWriter(new FileWriter(\"salida.txt\", true));\n      BufferedReader br = new BufferedReader(\n                                new InputStreamReader(System.in));\n      String s;\n      while (!(s = br.readLine()).equals(\"salir\")) {\n         out.println(s);\n      }\n      out.close();\n    } catch (IOException ex) {\n      System.out.println(\"Error: \" + ex.getMessage());\n    }\n  }\n}\n</code></pre></p>"},{"location":"ud06/ud0602/","title":"6.2 Ficheros","text":"<p>En ocasiones necesitamos que los datos que introduce el usuario o que produce un programa persistan cuando \u00e9ste finaliza; es decir, que se conserven cuando el programa termina su ejecuci\u00f3n. Para ello es necesario el uso de una base de datos o de ficheros, que permitan guardar los datos en un almacenamiento secundario como un pendrive, disco duro, DVD, etc.</p> <p>Abordaremos distintos aspectos relacionados con el almacenamiento en ficheros: </p> <ul> <li>Introducci\u00f3n a conceptos b\u00e1sicos como los de registro y campo.</li> <li>Clasificaci\u00f3n de los ficheros seg\u00fan el contenido y forma de acceso.</li> <li>Operaciones b\u00e1sicas con ficheros de distinto tipo.</li> </ul>"},{"location":"ud06/ud0602/#registros-y-campos","title":"Registros y campos","text":"<p>Llamamos campo a un dato en particular almacenado en una base de datos o fichero. Un campo puede ser el nombre de un cliente, la fecha de nacimiento de un alumno, el n\u00famero de tel\u00e9fono de un comercio. Los campos pueden ser de distintos tipos: alfanum\u00e9ricos, num\u00e9ricos, fechas, etc.</p> <p>La agrupaci\u00f3n de uno o m\u00e1s campos forman un registro. Un registro de alumno podr\u00eda consistir, por ejemplo, de los siguientes campos:</p> Text Only<pre><code>1. N\u00famero de expediente.\n2. Nombre y apellidos.\n3. Domicilio.\n</code></pre> <p>Un fichero puede estar formado por registros, lo cual dotar\u00eda al archivo de estructura. En un fichero de alumnos tendr\u00edamos un registro por cada alumno. Los campos del registro ser\u00edan cada uno de los datos que se almacena del alumno: n\u00ba expediente, nombre, etc \u2026</p> <p>En Java no existen espec\u00edficamente los conceptos de campo y registro. Lo m\u00e1s similar que conocemos son las clases (similares a un registro) y, dentro de las clases, los atributos (similares a campos). </p> <p>Tampoco en Java los ficheros est\u00e1n formados por registros. Java considera los archivos simplemente como flujos secuenciales de bytes. Cuando se abre un fichero se asocia a \u00e9l un flujo (stream) a trav\u00e9s del cual se lee o escribe en el fichero.</p> <p>Ejemplo de fichero:</p> <p><code>txt 65255 Jos\u00e9 Mateo Ruiz C/ Paz, \u2026 56488 \u00c1ngela Lopez Villa Av. Blas.. 24645 Armando Garc\u00eda Ledesma C/ Tuej \u2026</code></p> <p>Ejemplo de registro en el fichero anterior:</p> <p><code>txt 24645 Armando Garc\u00eda Ledesma C/ Tuej \u2026</code></p> <p>Ejemplo de campo en el registro anterior:</p> <p><code>txt Armando Garc\u00eda Ledesma</code></p>"},{"location":"ud06/ud0602/#ficheros-de-texto-vs-ficheros-binarios","title":"Ficheros de texto VS ficheros binarios","text":"<p>Desde un punto de vista a muy bajo nivel, un fichero es un conjunto de bits almacenados en memoria secundaria, accesibles a trav\u00e9s de una ruta y un nombre de archivo. </p> <p>Este punto de vista a bajo nivel es demasiado simple, pues cuando se recupera y trata la informaci\u00f3n que contiene el fichero, esos bits se agrupan en unidades mayores que las dotan de significado. As\u00ed, dependiendo de cu\u00e1l es el contenido del fichero (de c\u00f3mo se interpretan los bits que contiene el fichero), podemos distinguir dos tipos de ficheros:</p> <ul> <li>Ficheros de texto (o de caracteres).</li> <li>Ficheros binarios (o de bytes).</li> </ul> <p>Un fichero de texto est\u00e1 formado \u00fanicamente por caracteres. Los bits que contiene se interpretan atendiendo a una tabla de caracteres, ya sea ASCII o Unicode. Este tipo de ficheros se pueden abrir con un editor de texto plano y son, en general, legibles. Por ejemplo, los ficheros <code>.java</code> que contienen los programas que elaboramos, son ficheros de texto.</p> <p>Por otro lado, los ficheros binarios contienen secuencias de bytes que se agrupan para representar otro tipo de informaci\u00f3n: n\u00fameros, sonidos, im\u00e1genes, etc. Un fichero binario se puede abrir tambi\u00e9n con un editor de texto plano pero, en este caso, el contenido ser\u00e1 ininteligible. Existen muchos ejemplos de ficheros binarios: el archivo <code>.exe</code> que contiene la versi\u00f3n ejecutable de un programa es un fichero binario.</p> <p>Las operaciones de lectura/escritura que utilizamos al acceder desde un programa a un fichero de texto est\u00e1n orientadas al car\u00e1cter: leer o escribir un car\u00e1cter, una secuencia de caracteres, una l\u00ednea de texto, etc. En cambio las operaciones de lectura/escritura en ficheros binarios est\u00e1n orientadas a byte: se leen o escriben datos binarios, como enteros, bytes, double, etc.</p>"},{"location":"ud06/ud0602/#acceso-secuencial-vs-acceso-directo","title":"Acceso secuencial VS acceso directo","text":"<p>Existen dos maneras de acceder a la informaci\u00f3n que contiene un fichero:</p> <ul> <li>Acceso secuencial.</li> <li>Acceso directo (o aleatorio).</li> </ul> <p>Con acceso secuencial, para poder leer el byte que se encuentra en determinada posici\u00f3n del archivo es necesario leer, previamente, todos los bytes anteriores. Al escribir, los datos se sit\u00faan en el archivo uno a continuaci\u00f3n del otro, en el mismo orden en que se introducen. Es decir, la nueva informaci\u00f3n se coloca en el archivo a continuaci\u00f3n de la que ya existe. No es posible realizar modificaciones de los datos existentes, tan solo a\u00f1adir al final.</p> <p>Sin embargo, con el acceso directo, es posible acceder a determinada posici\u00f3n (direcci\u00f3n) del fichero de manera directa y, posteriormente, hacer la operaci\u00f3n de lectura o escritura deseada.</p> <p>No siempre es necesario realizar un acceso directo a un archivo. En muchas ocasiones el procesamiento que realizamos de sus datos consiste en la escritura o lectura de todo el archivo siguiendo el orden en que se encuentran. Para ello basta con un acceso secuencial.</p>"},{"location":"ud06/ud0602/#streams-para-trabajar-con-ficheros","title":"Streams para trabajar con ficheros","text":"<p>Para trabajar con ficheros disponemos de las siguientes clases:</p> Streams para ficheros Ficheros binarios Ficheros de texto Para lectura <code>FileInputStream</code> <code>FileReader</code> Para escritura <code>FileOutputStream</code> <code>FileWriter</code> <ul> <li><code>FileReader</code> permite leer de un fichero uno o varios caracteres.</li> <li><code>FileWriter</code> permite escribir en un fichero uno o varios caracteres o un String.</li> <li><code>FileInputStream</code> permite leer bytes de un fichero.</li> <li><code>FileOutputStream</code> permite escribir bytes de un fichero.</li> </ul> <p>Consulta</p> <p>Consulta en la documentaci\u00f3n los distintos constructores disponibles para estas clases.</p> Ejemplo: crear un fichero <p>En el siguiente ejemplo vemos c\u00f3mo crear un fichero de texto y escribir una frase en \u00e9l. Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\n\npublic class P2_1_CrearFichero {\n\n    public static void main(String[] args) {\n        FileWriter f = null;\n        try {\n            f = new FileWriter(\"texto.txt\");\n            f.write(\"Este texto se escribe en el fichero\\n\\r\");\n        } catch (IOException e) {\n            System.out.println(\"Problema al abrir o escribir \");\n        } finally {\n            if (f != null) {\n                try {\n                    f.close();\n                } catch (IOException e) {\n                    System.out.println(\"Problema al cerrar el fichero\");\n                }\n            }\n        }\n    }\n}\n</code></pre> La creaci\u00f3n del <code>FileWriter</code> puede provocar <code>IOException</code>, lo mismo que el m\u00e9todo <code>write</code>. Por ello las instrucciones se encuentran en un bloque <code>try-catch</code>. Al finalizar su uso, y tan pronto como sea posible, hay que cerrar los streams (<code>close</code>) .</p> Ejemplo: sobreescribir un fichero <p>Es muy importante tener en cuenta que cuando se crea un <code>FileWriter</code> o un <code>FileOutputStream</code> y se escribe en \u00e9l: - si el fichero no existe se crea. - si el fichero existe, su contenido se reemplaza por el nuevo. El contenido previo que tuviera el fichero se pierde.  Vamos a ver una serie de ejemplos que muestren c\u00f3mo leer y escribir secuencialmente sobre/en un fichero y tambi\u00e9n escribir en un fichero indicando que la informaci\u00f3n se a\u00f1ada a la que ya hay y no se reescriba el fichero. Para esto \u00faltimo usaremos el constructor de FileWriter que recibe dos par\u00e1metros; el primer par\u00e1metro es el nombre del fichero y el segundo par\u00e1metro, <code>append</code>, lo pasaremos con el valor true. El siguiente ejemplo muestra como a\u00f1adir una l\u00ednea al final de un fichero de texto. Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\n\npublic class P2_2_SobreescribirFichero {\n\n    public static void main(String[] args) {\n        try (FileWriter f = new FileWriter(\"texto.txt\", true);) {\n            f.write(\"Este texto se a\u00f1ade en el fichero\\n\\r\");\n\n        } catch (IOException e) {\n            System.out.println(\"Problema al abrir o escribir \");\n        }\n    }\n}\n</code></pre></p> <p>En este ejemplo se ha utilizado la nueva sintaxis disponible para los bloques try-catch: lo que se denomina <code>try with resource</code>. Esta sintaxis permite crear un objeto en la cabecera del bloque try. El objeto creado se cerrar\u00e1 autom\u00e1ticamente al finalizar. El objeto debe pertenecer al interface Closeable, es decir, debe tener m\u00e9todo close().</p>"},{"location":"ud06/ud0602/#lectura-y-escritura-de-informacion-estructurada","title":"Lectura y escritura de informaci\u00f3n estructurada","text":"<p>Si observamos la documentaci\u00f3n de las clases <code>FileInputStream</code> y <code>FileOutputStream</code> veremos que las operaciones de lectura y escritura son muy b\u00e1sicas y permiten \u00fanicamente leer o escribir uno o varios bytes. Es decir, son operaciones de muy bajo nivel. Si lo que queremos es escribir informaci\u00f3n binaria m\u00e1s compleja, como por ejemplo un dato de tipo <code>double</code>, <code>boolean</code> o <code>int</code>, tendr\u00edamos que hacerlo a trav\u00e9s de un stream que permitiese ese tipo de operaciones y asociarlo al <code>FileInputStream</code> o <code>FileOutputStream</code>. </p> <p>Podr\u00edamos, por ejemplo, asociar un <code>DataInputStream</code> a un <code>FileInputStream</code> para leer del fichero un dato de tipo <code>int</code>.</p> <p>En ejemplos posteriores se ilustrar\u00e1 c\u00f3mo asociar un stream a un <code>File\u2026Stream</code>.</p> Ejemplo: lectura de un fichero secuencial de texto <p>Leer un fichero de texto y mostrar el n\u00famero de vocales que contiene. Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\n\npublic class P2_3_LecturaSecuencialTexto {\n\n    final static String VOCALES = \"a\u00e1\u00e0e\u00e9\u00e9i\u00edo\u00f3\u00f2u\u00fa\u00fcA\u00c1\u00c0E\u00c9\u00c8I\u00cdO\u00d3\u00d2U\u00da\u00dc\";\n\n    public static void main(String[] args) {\n        try (FileReader f = new FileReader(new File(\"texto.txt\"));) {\n            int contadorVocales = 0;\n            int caracter;\n            while ((caracter = f.read()) != -1) {\n                char letra = (char) caracter;\n                if (VOCALES.indexOf(letra) != -1) {\n                    contadorVocales++;\n                }\n            }\n            System.out.println(\"Numero de vocales: \" + contadorVocales);\n        } catch (FileNotFoundException e) {\n            System.out.println(\"ERROR: Probrema al abrir el fichero\");\n        } catch (IOException e) {\n            System.out.println(\"ERROR: Problema al leer\");\n        }\n    }\n}\n</code></pre> Observa que: - Para leer el fichero de texto usamos un <code>InputReader</code>. - Al crear el stream (<code>InputReader</code>) es posible indicar un objeto de tipo <code>File</code>. - La operaci\u00f3n <code>read()</code> devuelve un entero. Para obtener el car\u00e1cter correspondiente tenemos que hacer una conversi\u00f3n expl\u00edcita de tipos. - La operaci\u00f3n <code>read()</code> devuelve -1 cuando no queda informaci\u00f3n que leer del stream. - La guarda del bucle <code>while</code> combina una asignaci\u00f3n con una comparaci\u00f3n. En primer lugar se realiza la asignaci\u00f3n y luego se compara car\u00e1cter con -1. - <code>FileNotFoundException</code> sucede cuando el fichero no se puede abrir (no existe, permiso denegado, etc), mientras que <code>IOException</code> se lanzar\u00e1 si falla la operaci\u00f3n <code>read().</code></p> Ejemplo: escritura de un fichero secuencial de texto <p>Dada una cadena escribirla en un fichero en orden inverso: Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\n\npublic class P2_4_EscrituraSecuencialTexto {\n\n    final static String CADENA = \"En un lugar de la mancha...\";\n\n    public static void main(String[] args) {\n        try (FileWriter f = new FileWriter(new File(\"texto.txt\"));) {\n            for (int i = CADENA.length() - 1; i &gt;= 0; i--) {\n                f.write(CADENA.charAt(i));\n            }\n            System.out.println(\"FIN\");\n        } catch (FileNotFoundException e) {\n            System.out.println(\"ERROR: Probrema al abrir el fichero\");\n        } catch (IOException e) {\n            System.out.println(\"ERROR: Problema al escribir\");\n        }\n    }\n}\n</code></pre> Observa que: - Para escribir el fichero de texto usamos un <code>FileWriter</code>. - Tal y como se ha creado el stream, el fichero (si ya existe) se sobreescribir\u00e1. - El manejo de excepciones es como el del caso previo.</p> Ejemplo: escritura de un fichero secuencial binario <p>Ya hemos visto que con <code>FileInputStream</code> y <code>FileOutputStream</code> se puede leer y escribir bytes de informaci\u00f3n de/a un archivo. Sin embargo esto puede no ser suficiente cuando la informaci\u00f3n que tenemos que leer o escribir es m\u00e1s compleja y los bytes se agrupan para representar distintos tipos de datos. Imaginemos por ejemplo que queremos guardar en un fichero \u201cjugadores.dat\u201d, el a\u00f1o de nacimiento y la estatura de cinco jugadores de baloncesto: Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\nimport java.util.Scanner;\n\npublic class P2_6_EscrituraSecuencialBinario {\n\n  public static void main(String[] args) {\n     Scanner tec = new Scanner(System.in);\n     try (DataOutputStream fs = new DataOutputStream(\n                                  new BufferedOutputStream(\n                                    new FileOutputStream(\"jugadores.dat\")));) {\n         for (int i = 1; i &lt;= 5; i++) {\n            //Pedimos datos al usuario\n            System.out.println(\" ---- Jugador \" + i + \" -----\");\n            System.out.print(\"Nombre: \");\n            String nombre = tec.nextLine();\n\n            System.out.print(\"Nacimiento: \");\n            int anyo = tec.nextInt();\n\n            System.out.print(\"Estatura: \");\n            double est = tec.nextDouble();\n            //Vaciar salto linea\n            tec.nextLine();\n\n            //Volcamos informaci\u00f3n al fichero\n            fs.writeUTF(nombre);\n            fs.writeInt(anyo);\n            fs.writeDouble(est);\n         }\n      } catch (FileNotFoundException e) {\n          System.out.println(\"ERROR: Probrema al abrir el fichero\");\n      } catch (IOException e) {\n          System.out.println(\"ERROR: Problema al leer o escribir\");\n      }\n  }\n}\n</code></pre> Observa que: - Para escribir informaci\u00f3n binaria usamos un <code>DataInputStream</code> asociado al stream. La clase tiene m\u00e9todos para escribir <code>int</code>, <code>byte</code>, <code>double</code>, <code>boolean</code>, etc. - Adem\u00e1s, como hemos hecho en ejemplos previos, usamos un buffer. F\u00edjate como en el constructor se enlazan unas clases con otras. - A pesar de que en Java los ficheros son secuencias de bytes, estamos dotando al fichero de cierta estructura: primero aparece el nombre, luego el a\u00f1o y finalmente la estatura. Cada uno de estos tres datos constituir\u00edan un registro de formado por tres campos. Para poder recuperar informaci\u00f3n de un fichero binario es necesario conocer c\u00f3mo se estructura \u00e9sta dentro del fichero.</p> Ejemplo: lectura de un fichero secuencial binario <p>Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\nimport java.util.Scanner;\n\npublic class P2_7_LecturaSecuencialBinario {\n\n  public static void main(String[] args) {\n     Scanner tec = new Scanner(System.in);\n     try (DataInputStream fe = new DataInputStream(\n                                new BufferedInputStream(\n                                 new FileInputStream(\"jugadores.dat\")));) {\n        while (true) {\n           //Leemos nombre\n           System.out.println(fe.readUTF());\n           //leemos y desechamos resto de datos\n           fe.readInt();\n           fe.readDouble();\n        }\n     } catch (EOFException e) {\n          //Se lanzar\u00e1 cuando se llegue al final del fichero\n     } catch (FileNotFoundException e) {\n          System.out.println(\"ERROR: Probrema al abrir el fichero\");\n     } catch (IOException e) {\n          System.out.println(\"ERROR: Problema al leer o escribir\");\n     }\n  }\n}\n</code></pre> Observa que: - A pesar de que necesitamos solamente el nombre de cada jugador, es necesario leer tambi\u00e9n el a\u00f1o y la estatura. No es posible acceder al nombre del segundo jugador sin leer previamente todos los datos del primer jugador.  - La lectura se hace a trav\u00e9s de un bucle infinito (<code>while (true)</code>), que finalizar\u00e1 cuando se llegue el final del fichero y al leer de nuevo se produzca la excepci\u00f3n <code>EOFException</code>.</p>"},{"location":"ud06/ud0602/#ficheros-con-buffering","title":"Ficheros con buffering","text":"<p>Cualquier operaci\u00f3n que implique acceder a memoria externa es muy costosa, por lo que es interesante intentar reducir al m\u00e1ximo las operaciones de lectura/escritura que realizamos sobre los ficheros, haciendo que cada operaci\u00f3n lea o escriba muchos caracteres. Adem\u00e1s, eso tambi\u00e9n permite operaciones de m\u00e1s alto nivel, como la de leer una l\u00ednea completa y devolverla en forma de cadena.</p> <p>En el libro Head First Java, describe los buffers de la siguiente forma: \"Si no hubiera buffers, ser\u00eda como comprar sin un carrito: deber\u00eda llevar los productos uno a uno hasta la caja. Los buffers te dan un lugar en el que dejar temporalmente las cosas hasta que est\u00e1 lleno. Por ello has de hacer menos viajes cuando usas el carrito.\"</p> <p>Las clases <code>BufferedReader</code>, <code>BufferedWritter</code>, <code>BufferedInputStream</code> y <code>BufferedOutputStream</code> permiten realizar buffering. Situadas \"por delante\" de un stream de fichero acumulan las operaciones de lectura y escritura y cuando hay suficiente informaci\u00f3n se llevan finalmente al fichero.</p> <p>Recuerda</p> <p>Recuerda la importancia de cerrar los flujos para asegurarte que se vac\u00eda el buffer.</p> Ejemplo: usando Buffers para leer y escribir de/en fichero <p>En el siguiente codigo se usan buffers para leer l\u00edneas de un fichero y escribirlas en otro convertidas a may\u00fasculas. Java<pre><code>package UD06.P2_Ficheros;\n\nimport java.io.*;\n\npublic class P2_5_Buffers {\n\n    final static String ENTRADA = \"texto.txt\";\n    final static String SALIDA = \"textoMayusculas.txt\";\n\n    public static void main(String[] args) {\n        try (BufferedReader fe = new BufferedReader(new FileReader(ENTRADA));\n             BufferedWriter fs = new BufferedWriter(new FileWriter(SALIDA))){\n            String linea;\n            while ((linea = fe.readLine()) != null) {\n                fs.write(linea.toUpperCase());\n                fs.newLine();\n            }\n            System.out.println(\"FIN\");\n        } catch (FileNotFoundException e) {\n            System.out.println(\"ERROR: Probrema al abrir el fichero\");\n        } catch (IOException e) {\n            System.out.println(\"ERROR: Problema al leer o escribir\");\n        }\n    }\n}\n</code></pre> Observa que: - Usamos buffers tanto para leer como para escribir. Esto permite minimizar los accesos a disco. - Los buffers quedan asociados a un <code>FileReader</code> y <code>FileWriter</code> respectivamente. Realizamos las operaciones de lectura/escritura sobre las clases <code>Buffered\u2026</code> y cuando es necesario la clase accede internamente al stream que maneja el fichero. - Es necesario escribir expl\u00edcitamente los saltos de l\u00ednea. Esto se hace mediante el m\u00e9todo <code>newLine()</code>. Este m\u00e9todo permite a\u00f1adir un salto de l\u00ednea sin preocuparnos de cu\u00e1l es el car\u00e1cter de salto de l\u00ednea. El salto de l\u00ednea es distinto en distintos sistemas: en unos es <code>\\n</code>, en otros <code>\\r</code>, en otros <code>\\n\\r</code>, \u2026  - <code>BufferedReader</code> dispone de un m\u00e9todo para leer l\u00edneas completas (<code>readLine()</code>). Cuando se llega al final del fichero este m\u00e9todo devuelve <code>null</code>. - F\u00edjate como en el bloque <code>try with resources</code> creamos varios objetos. Si la creaci\u00f3n de cualquiera de ellos falla, se cerrar\u00e1n todos los stream que se han abierto.</p>"},{"location":"ud06/ud0602/#try-vs-try-with-resources","title":"<code>try</code> VS <code>try with resources</code>","text":"<p>En ocasiones el propio IDE nos sugiere que usemos el bloque <code>try with resources</code> en lugar de un simple <code>try</code>, as\u00ed una sentencia como esta:</p> Java<pre><code>FileReader fr = new FileReader(path);\nBufferedReader br = new BufferedReader(fr);\ntry {\n    return br.readLine();\n} finally {\n    br.close();\n    fr.close();\n}\n</code></pre> <p>Acaba convertida en algo parecido a esta:</p> Java<pre><code>static String readFirstLineFromFile(String path) throws IOException {\n    try (FileReader fr = new FileReader(path);\n         BufferedReader br = new BufferedReader(fr)) {\n        return br.readLine();\n    }\n}   \n</code></pre> <p>.close ??</p> <p>La principal diferencia es que hasta Java 7 s\u00f3lo se pod\u00eda hacer como en la primera versi\u00f3n. Adem\u00e1s, en la segunda versi\u00f3n nos \"ahorramos\" tener que cerrar los recursos, puesto que lo realizar\u00e1 autom\u00e1ticamente en caso de que se produzca alg\u00fan error evitando as\u00ed el enmascaramiento de excepciones. Por tanto, sigue siendo necesario cerrar el stream por ejemplo al usar un Buffer para que se vac\u00ede totalmente en el fichero de destino.</p>"},{"location":"ud06/ud0603/","title":"6.3 Serializaci\u00f3n","text":"<p>Java facilita el almacenamiento y transmisi\u00f3n del estado de un objeto mediante un mecanismo conocido con el nombre de serializaci\u00f3n.</p> <p>La serializaci\u00f3n de un objeto consiste en generar una secuencia de bytes lista para su almacenamiento o transmisi\u00f3n. Despu\u00e9s, mediante la deserializaci\u00f3n, el estado original del objeto se puede reconstruir.</p> <p>Para que un objeto sea serializable, ha de implementar la interfaz <code>java.io.Serializable</code> (que lo \u00fanico que hace es marcar el objeto como serializable, sin que tengamos que implementar ning\u00fan m\u00e9todo).</p> Java<pre><code>import java.io.*;\n\npublic class Persona implements Serializable {\n\n    private String nombre;\n    transient private int edad; //No se guardar\u00e1 al serializar\n    private double salario;\n    private Persona tutor;\n[...]\n</code></pre> <p>Para que un objeto sea serializable, todas sus variables de instancia han de ser serializables.</p> <p>Todos los tipos primitivos en Java son serializables por defecto (igual que los arrays y otros muchos tipos est\u00e1ndar).</p> <p>Cuando queremos evitar que cualquier campo persista en un archivo, lo marcamos como transitorio (<code>transient</code>). No podemos marcar ning\u00fan m\u00e9todo transitorio, solo campos.</p> <p>Nota</p> <p>El fichero con los objetos serializados almacena los datos en un formato propio de Java, por lo que no se puede leer f\u00e1cilmente con un simple editor de texto (ni editar).</p> Ejemplo: serializaci\u00f3n <p>Java<pre><code>package UD06.P3_Serializacion;\n\nimport java.io.*;\n\npublic class Persona implements Serializable {\n\n  private String nombre;\n  transient private int edad; //No se guardar\u00e1 al serializar\n  private double salario;\n  private Persona tutor;\n\n  public Persona(String nom, double salari) {\n     this.nombre = nom;\n     this.salario = salari;\n     edad = 0;\n     tutor = null;\n  }\n\n  public String getNombre() {\n     return nombre;\n  }\n\n  public int getEdad() {\n     return edad;\n  }\n\n  public double getSalario() {\n     return salario;\n  }\n\n  public Persona getTutor() {\n     return tutor;\n  }\n\n  public void incrementaEdad() {\n     edad++;\n  }\n\n  public void asignaTutor(Persona p) {\n     tutor = p;\n  }\n}\n</code></pre> Ahora detallamos la clase para serializar o guardar la informaci\u00f3n en un archivo: Java<pre><code>package UD06.P3_Serializacion;\n\nimport java.io.*;\n\npublic class Guardar {\n\n  public static void main(String args[]) {\n     ObjectOutputStream salida;\n     Persona p1, p2, p3, p4;\n\n     p1 = new Persona(\"Vicent\", 1200.0);\n     p2 = new Persona(\"Mireia\", 1800.0);\n     p3 = new Persona(\"Josep\", 2100.0);\n     p4 = new Persona(\"Marta\", 850.0);\n\n     p1.asignaTutor(p2);\n     p2.asignaTutor(p3);\n     p3.asignaTutor(p4);\n\n     try {\n        salida = new ObjectOutputStream(new FileOutputStream(\"empleados.ser\"));\n        salida.writeObject(p1);\n        salida.close();\n     } catch (IOException e) {\n        System.out.println(\"ERROR: Alg\u00fan problema guardando a disco.\");\n     }\n  }\n}\n</code></pre></p>"},{"location":"ud06/ud0604/","title":"6.4 Sockets","text":"<p>Los sockets son un mecanismo que nos permite establecer un enlace entre dos programas que se ejecutan independientes el uno del otro  (generalmente un programa cliente y un programa servidor). Java, por medio de la librer\u00eda <code>java.net</code>, nos provee dos clases: <code>Socket</code> para implementar la conexi\u00f3n desde el lado del cliente y <code>ServerSocket</code> que nos permitir\u00e1 manipular la conexi\u00f3n desde el lado del servidor.</p> <p>Cabe resaltar que tanto el cliente como el servidor no necesariamente deben estar implementados en Java, solo  deben conocer sus direcciones IP y el puerto por el cual se comunicar\u00e1n.</p> Ejemplo <p>Para nuestro ejemplo de sockets implementaremos ambos (cliente y servidor) usando Java y se comunicar\u00e1n usando el puerto 10000 (elegir puertos en el rango de 1024 hasta 65535). La secuencia de eventos en nuestro ejemplo ser\u00e1: 1. El servidor crear\u00e1 el socket y esperar\u00e1 a que el cliente se conecte o lo detengamos. 2. Por otro lado, el cliente abrir\u00e1 la conexi\u00f3n con el servidor y le enviar\u00e1 una frase en min\u00fasculas que escribir\u00e1 el usuario y la enviar\u00e1 al servidor. 3. Una vez recibida la frase en min\u00fasculas, el servidor la convertir\u00e1 en may\u00fasculas y la devolver\u00e1 al cliente. 4. El cliente mostrar\u00e1 la frase en may\u00fasculas recibida desde el servidor y cerrar\u00e1 la conexi\u00f3n. 5. El servidor quedar\u00e1 a la espera de una nueva conexi\u00f3n de otro cliente. Servidor Java<pre><code>package UD06.P4_Sockets;\n\nimport java.io.*;\nimport java.net.*;\n\npublic class TCPServidor {\n\n  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    String FraseClient;\n    String FraseMajuscules;\n    ServerSocket serverSocket;\n    Socket clientSocket;\n    ObjectInputStream entrada;\n    ObjectOutputStream eixida;\n    serverSocket = new ServerSocket(10000);\n    System.out.println(\"Servidor iniciado y escuchando por el puerto 10000\");\n    while (true) {\n        clientSocket = serverSocket.accept();\n        entrada = new ObjectInputStream(clientSocket.getInputStream());\n        FraseClient = (String) entrada.readObject();\n\n        System.out.println(\"La frase recibida es: \" + FraseClient);\n\n        eixida = new ObjectOutputStream(clientSocket.getOutputStream());\n        FraseMajuscules = FraseClient.toUpperCase();\n        System.out.println(\"El servidor devuelve la frase: \" + FraseMajuscules);\n        eixida.writeObject(FraseMajuscules);\n\n        clientSocket.close();\n        System.out.println(\"Server esperando una nueva conexi\u00f3n...\");\n    }\n  }\n}\n</code></pre> Cliente Java<pre><code>package UD06.P4_Sockets;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class TCPClient {\n\n  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    Socket socket;\n    ObjectInputStream entrada;\n    ObjectOutputStream eixida;\n    String frase;\n\n    socket = new Socket(InetAddress.getLocalHost(), 10000);\n    eixida = new ObjectOutputStream(socket.getOutputStream());\n\n    System.out.println(\"Introduce la frase a enviar en min\u00fasculas\");\n    Scanner in = new Scanner(System.in);\n    frase = in.nextLine();\n    System.out.println(\"Se envia la frase \" + frase);\n    eixida.writeObject(frase);\n\n    entrada = new ObjectInputStream(socket.getInputStream());\n    System.out.println(\n            \"La frase recibida es: \" + (String) entrada.readObject());\n\n    socket.close();\n  }\n}\n</code></pre></p>"},{"location":"ud06/ud0605/","title":"6.5 Manejo de ficheros y carpetas","text":""},{"location":"ud06/ud0605/#la-clase-file","title":"La clase File","text":"<p>La clase <code>File</code> es una representaci\u00f3n abstracta ficheros y carpetas. Cuando creamos en Java un objeto de la clase <code>File</code> en representaci\u00f3n de un fichero o carpeta concretos, no creamos el fichero al que se representa; es decir, el objeto <code>File</code> representa al archivo o carpeta de disco, pero no es el archivo o carpeta de disco.</p> <p>La clase <code>File</code> dispone de m\u00e9todos que permiten realizar determinadas operaciones sobre los ficheros. Podr\u00edamos, por ejemplo, crear un objeto de tipo <code>File</code> que represente a <code>c:\\datos\\libros.txt</code> o <code>/home/abc/datos/libros.txt</code> y, a trav\u00e9s de ese objeto <code>File</code>, realizar consultas relativas al fichero <code>libros.txt</code>, como su tama\u00f1o, atributos, etc; o realizar operaciones sobre \u00e9l: borrarlo, renombrarlo, \u2026</p>"},{"location":"ud06/ud0605/#constructores","title":"Constructores","text":"<p>La clase <code>File</code> tiene varios constructores, que permiten referirse, de varias formas, al archivo que queremos representar:</p> M\u00e9todo Descripci\u00f3n <code>public File (String ruta)</code> Crea el objeto <code>File</code> a partir de la ruta indicada. Si se trata de un archivo tendr\u00e1 que indicar la ruta y el nombre. <code>public File (String ruta, String nombre)</code> Permite indicar de forma separada la ruta del archivo y su nombre. <code>public File (File ruta, String nombre)</code> Permite indicar de forma separada la ruta del archivo y su nombre. En este caso la ruta est\u00e1 representada por otro objeto File. <code>public File (URI uri)</code> Crea el objeto File a partir de un objeto URI (Uniform Resource Identifier). Un URI permite representar un elemento siguiendo una sintaxis concreta, un est\u00e1ndar."},{"location":"ud06/ud0605/#metodos","title":"M\u00e9todos","text":"<p>Aqu\u00ed exponemos algunos m\u00e9todos interesantes. Hay otros que puedes consultar en la documentaci\u00f3n de Java.</p> Relacionados con el nombre del fichero <code>String getName()</code> Devuelve el nombre del fichero o directorio al que representa el objeto (solo el nombre, sin la ruta). <code>String getPath()</code> Devuelve la ruta del fichero o directorio. La ruta obtenida es dependiente del sistema; es decir, contendr\u00e1 el car\u00e1cter de separaci\u00f3n de directorios que est\u00e9 establecido por defecto. Este separador est\u00e1 definido en public <code>static final String separator</code>. <code>String getAbsolutePath()</code> Devuelve la ruta absoluta del fichero o directorio. <code>String getParent()</code> Devuelve la ruta del directorio en que se encuentra el fichero o directorio representado. Devuelve null si no hay directorio padre. Para hacer comprobaciones <code>boolean exists()</code><code>boolean canWrite()</code><code>boolean canRead()</code> <code>boolean isFile()</code><code>boolean isDirectory()</code> Permiten averiguar si el fichero existe, si se puede escribir en el, si se puede leer de \u00e9l,si se trata de un fichero o si se trata de un directorio Obtener informaci\u00f3n de un fichero <code>long length</code> Devuelve el tama\u00f1o en bytes del archivo. El resultado es indefinido si se consulta sobre un directorio o una unidad. <code>long lastModified</code> Devuelve la fecha de la \u00faltima modificaci\u00f3n del archivo. Devuelve el n\u00famero de milisegundos transcurridos desde el 1 de enero de 1970 Para trabajar con directorios <code>boolean mkdir()</code> Crea el directorio al cual representa el objeto File. <code>boolean mkdirs()</code> Crea el directorio al cual representa el objeto File, incluyendo todos aquellos que sean necesarios y no existan. <code>String[] list()</code> Devuelve un array de <code>Strings</code> con los nombres de los ficheros y directorios que contiene el directorio al que representa el objeto File. <code>String[] list(FileNameFilter filtro)</code> Devuelve un array de <code>Strings</code> con los nombres de los ficheros y directorios que contiene el directorio al que representa el objeto File y que cumplen con determinado filtro. <code>public File[] listFiles()</code> Devuelve un array de objetos <code>File</code> que representan a los archivos y carpetas contenidos en el directorio al que se refiere el objeto File. Para hacer cambios <code>boolean renameTo(File nuevoNombre)</code> Permite renombrar un archivo. Hay que tener en cuenta que la operaci\u00f3n puede fracasar por muchas razones, y que ser\u00e1 dependiente del sistema (por ejemplo: que no se pueda mover el fichero de un lugar a otro, que ya exista un fichero que coincide con el nuevo, etc). El m\u00e9todo devuelve true solo si la operaci\u00f3n se ha realizado con \u00e9xito. Existe un m\u00e9todo move en la clase Files para mover archivos de una forma independiente del sistema. <code>boolean delete()</code> Elimina el archivo o la carpeta a la que representa el objeto File. Si se trata de una carpeta tendr\u00e1 que estar vac\u00eda. Devuelve true si la operaci\u00f3n tiene \u00e9xito. <code>boolean createNewFile()</code> Crea un archivo vac\u00edo. Devuelve true si la operaci\u00f3n se realiza con \u00e9xito. <code>File createTempFile(String prefijo, String sufijo)</code> Crea un archivo vac\u00edo en la carpeta de archivos temporales. El nombre llevar\u00e1 el prefijo y sufijo indicados. Devuelve el objeto File que representa al nuevo archivo. Ejemplo: manejo de ficheros y carpetas Java<pre><code>package UD06.P5_Manejo;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class P5_1_Manejo {\n\n  public static void main(String[] args) {\n     Scanner tec = new Scanner(System.in);\n     System.out.println(\"Introduce ruta absoluta de una carpeta\");\n     String nombreCarpeta = tec.nextLine();\n     //Creamos objeto File para representar a la carpeta\n     File car = new File(nombreCarpeta);\n     //Comprobamos si existe\n     if (car.exists()) {\n        //\u00bfEs una carpeta?\n        if (car.isDirectory()) {\n           if (car.canRead()) \n               System.out.println(\"Lectura permitida\");\n           else\n               System.out.println(\"Lectura no permitida\");\n\n           if (car.canWrite())\n               System.out.println(\"Escritura permitida\");\n           else\n               System.out.println(\"Escritura no permitida\");\n\n           if (car.isHidden())\n               System.out.println(\"Carpet aoculta\");\n           else\n               System.out.println(\"Carpeta visible\");\n\n           System.out.println(\"---- Contenido de la carpeta ----\");\n           File[] contenido = car.listFiles();\n           for (File f : contenido) {\n               System.out.println(f.getName());\n           }\n        } else {\n            System.out.println(\"ERROR: \" + car.getAbsolutePath() + \" No es una carpeta\");\n        }\n     } else {\n         System.out.println(\"ERROR: No existe la carpeta/archivo \" + car.getAbsolutePath());\n     }\n  }\n}\n</code></pre>"},{"location":"ud06/ud06ac/","title":"Actividades","text":""},{"location":"ud06/ud06ac/#ejercicios","title":"Ejercicios","text":""},{"location":"ud06/ud06ac/#ejercicio-01-gestorvuelos","title":"Ejercicio 01 - gestorVuelos","text":"<p>Paquete: <code>gestorVuelos</code></p> <p>Se desea realizar una aplicaci\u00f3n <code>GestorVuelos</code> para gestionar la reserva y cancelaci\u00f3n de vuelos en una agencia de viajes. Dicha agencia trabaja \u00fanicamente con la compa\u00f1\u00eda a\u00e9rea AirVostrum, que ofrece vuelos desde/hacia varias ciudades de Europa. Se deben definir las clases que siguen, teniendo en cuenta que sus atributos ser\u00e1n privados y sus m\u00e9todos s\u00f3lo los que se indican en cada clase.</p> <p>A) Implementaci\u00f3n de la clase <code>Vuelo</code>, que permite representar un vuelo mediante los atributos:  </p> <ul> <li><code>identificador</code> (<code>String</code>)</li> <li><code>origen</code> (<code>String</code>)</li> <li><code>destino</code> (<code>String</code>)</li> <li><code>hSalida</code> (un tipo que te permita controlar la hora, no es un <code>String</code> ni un <code>int</code>, etc.)</li> <li><code>hLlegada</code> (un tipo que te permita controlar la hora, no es un <code>String</code> ni un <code>int</code>, etc.)</li> <li>Adem\u00e1s, cada vuelo dispone de 50 asientos, es decir, pueden viajar, como mucho, 50 pasajeros en cada vuelo. Para representarlos, se har\u00e1 uso de <code>asiento</code>, un array de <code>String</code> (nombres de los pasajeros) junto con un atributo <code>numP</code> que indique el n\u00famero actual de asientos reservados. Si el asiento <code>i</code> est\u00e1 reservado, <code>asiento[i]</code> contendr\u00e1 el nombre del pasajero que lo ha reservado. Si no lo est\u00e1, <code>asiento[i]</code> ser\u00e1 <code>null</code>. En el array <code>asiento</code>, las posiciones impares pertenecen a asientos de ventanilla y las posiciones pares, a asientos de pasillo (la posici\u00f3n 0 no se utilizar\u00e1).</li> </ul> <p>En esta clase, se deben implementar los siguientes m\u00e9todos:</p> <ul> <li> <p><code>public Vuelo(String id, String orig, String dest, LocalTime hsal, LocalTime hlleg)</code>: Constructor que crea un vuelo con identificador, ciudad de origen, ciudad de destino, hora de salida y hora de llegada indicados en los respectivos par\u00e1metros, y sin pasajeros.</p> </li> <li> <p><code>public String getIdentificador()</code>: Devuelve el <code>identificador</code></p> </li> <li> <p><code>public String getOrigen()</code>: Devuelve <code>origen</code>.</p> </li> <li> <p><code>public String getDestino()</code>: Devuelve <code>destino</code>.</p> </li> <li> <p><code>public boolean hayLibres()</code>: Devuelve <code>true</code> si quedan asientos libres y <code>false</code> si no quedan.</p> </li> <li> <p><code>public boolean equals(Object o)</code>: Dos vuelos son iguales si tienen el mismo identificador.</p> </li> <li> <p><code>public int reservarAsiento(String pas, char pref) throws VueloCompletoException</code>: Si el vuelo ya est\u00e1 completo se lanza una excepci\u00f3n. Si no est\u00e1 completo, se reserva al pasajero <code>pas</code> el primer asiento libre en <code>pref</code>. El car\u00e1cter <code>pref</code> ser\u00e1 '<code>V</code>' o '<code>P</code>' en funci\u00f3n de que el pasajero desee un asiento de ventanilla o de pasillo. En caso de que no quede ning\u00fan asiento libre en la preferencia indicada (<code>pref</code>), se reservar\u00e1 el primer asiento libre de la otra preferencia. El m\u00e9todo devolver\u00e1 el n\u00famero de asiento que se le ha reservado. Este m\u00e9todo hace uso del m\u00e9todo privado <code>asientoLibre</code>, que se explica a continuaci\u00f3n.</p> </li> <li> <p><code>private int asientoLibre(char pref)</code>: Dado un tipo de asiento <code>pref</code> (pasillo '<code>P</code>' o ventanilla '<code>V</code>'), devuelve el primer asiento libre (el de menor numero) que encuentre de ese tipo. O devuelve <code>0</code> si no quedan asientos libres de tipo <code>pref</code>.</p> </li> <li> <p><code>public void cancelarReserva(int numAsiento)</code>: Se cancela la reserva del asiento <code>numasiento</code>.</p> </li> <li> <p><code>public String toString()</code>: Devuelve una <code>String</code> con los datos del vuelo y los nombres de los pasajeros, con el siguiente formato:</p> </li> </ul> Bash<pre><code>Vuelo:\n  AV101 Valencia Par\u00eds 19:05:00 21:00:00\nPasajeros (23):\n  Asiento 1: Sonia Dominguez\n  \u2026\n  Asiento 23: Fernando Romero\n</code></pre> <p>B) Dise\u00f1ar e implementar una clase <code>TestVuelo</code> que permita probar la clase <code>Vuelo</code> y sus m\u00e9todos. Para ello se desarrollar\u00e1 el m\u00e9todo <code>main</code> en el que:</p> <ul> <li>Se cree el vuelo IB101 de Valencia a Par\u00eds, que sale a las 19:05 y llega a las 21:00</li> <li>Reservar:</li> <li>Un asiento de ventanilla a \"Miguel Fern\u00e1ndez\"</li> <li>Un asiento de ventanilla a \"Ana Folgado\"</li> <li>Un asiento de pasillo a \"David M\u00e1s\"</li> <li>Mostrar el vuelo por pantalla.</li> <li>Cancelar la reserva del asiento que indique el usuario.</li> </ul> <p>C) Implementaci\u00f3n de la clase <code>Compa\u00f1\u00eda</code> para representar todos los vuelos de una compa\u00f1\u00eda a\u00e9rea. Una Compa\u00f1\u00eda tiene un nombre y puede ofrecer, como mucho, 10 vuelos distintos. Para representarlos se utilizar\u00e1 <code>listaVuelos</code>, un array de objetos <code>Vuelo</code> junto con un atributo <code>numVuelos</code> que indique el n\u00famero de vuelos que la compa\u00f1\u00eda ofrece en un momento dado. Las operaciones de esta clase son:</p> <ul> <li> <p><code>public Compania(String n) throws FileNotFoundException</code>: Constructor de una compa\u00f1\u00eda de nombre <code>n</code>. Cuando se crea una compa\u00f1\u00eda, se invoca al m\u00e9todo privado <code>leeVuelos()</code> para cargar la informaci\u00f3n de vuelos desde un fichero. Si el fichero no existe, se propaga la excepci\u00f3n <code>FileNotFoundException</code></p> </li> <li> <p><code>private void leeVuelos() throws FileNotFoundException</code>: Lee desde un fichero toda la informaci\u00f3n de los vuelos que ofrece la compa\u00f1\u00eda y los va almacenando en el array de vuelos <code>listaVuelos</code>. El nombre del fichero coincide con el nombre de la compa\u00f1\u00eda y tiene extensi\u00f3n <code>.txt</code>. La informaci\u00f3n de cada vuelo se estructura en el fichero como sigue:</p> </li> </ul> Text Only<pre><code>&lt;Identificador&gt;\n&lt;Origen&gt;\n&lt;Destino&gt;\n&lt;Hora de salida&gt;\n&lt;Minuto de salida&gt;\n&lt;Hora de llegada&gt;\n&lt;Minuto de llegada&gt;\n...\n...\n</code></pre> <p>Si el fichero no existe, se propaga la excepci\u00f3n <code>FileNotFoundException</code>.</p> <ul> <li> <p><code>public Vuelo buscarVuelo(String id) throws ElementoNoEncontradoException</code>: Dado un identificador de vuelo <code>id</code>, busca dicho vuelo en el array de vuelos <code>listaVuelos</code>. Si lo encuentra, lo devuelve. Si no, lanza <code>ElementoNoEncontradoException</code>.</p> </li> <li> <p><code>public void mostrarVuelosIncompletos(String o, String d)</code>: Muestra por pantalla los vuelos con origen <code>o</code> y destino <code>d</code>, y que tengan asientos libres. Por ejemplo, vuelos con asientos libres de la compa\u00f1\u00eda AirVostrum con origen Mil\u00e1n y destino Valencia:</p> </li> </ul> Bash<pre><code>AirVostrum - Vuelo AV201 - Mil\u00e1n Val\u00e8ncia - 14:25:00 16:20:00\nAirVostrum - Vuelo AV202 - M\u00edl\u00e1n Val\u00e8ncia - 21:40:00 23:35:00\n</code></pre> <p>D) En la clase <code>GestorVuelos</code> se probar\u00e1 el comportamiento de las clases anteriores. En esta clase se debe implementar el m\u00e9todo <code>main</code> en el que, por simplificar, se pide \u00fanicamente:</p> <ul> <li>La creaci\u00f3n de la compa\u00f1\u00eda a\u00e9rea <code>AirVostrum</code>. Se dispone de un fichero de texto \"<code>AirVostrum.txt</code>\", con la informaci\u00f3n de los vuelos que ofrece.</li> <li>Reserva de un asiento de ventanilla en un vuelo de Val\u00e8ncia a Mil\u00e1n por parte de Manuel Soler Roca. Para ello:</li> <li>Mostraremos vuelos con origen Val\u00e8ncia y destino Mil\u00e1n, que no est\u00e9n completos.</li> <li>Pediremos al usuario el identificador del vuelo en que quiere hacer la reserva.</li> <li>Buscaremos el vuelo que tiene el identificador indicado. Si existe realizaremos la reserva y mostraremos un mensaje por pantalla. En caso contrario mostraremos un mensaje de error por pantalla.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-02-maquinaexpendedora","title":"Ejercicio 02 - maquinaExpendedora","text":"<p>Paquete: <code>maquinaExpendedora</code></p> <p>Se desea simular el funcionamiento de una m\u00e1quina expendedora. Se trata de una expendedora sencilla que, por el momento, ser\u00e1 capaz de dispensar \u00fanicamente un producto.</p> <p>Su funcionamiento, a grandes rasgos, es el siguiente:</p> <ol> <li>El cliente introduce dinero en la m\u00e1quina. Al dinero introducido lo llamaremos <code>credito</code>.</li> <li>Selecciona el producto que quiere comprar (ya hemos comentado que por el momento habr\u00e1 un solo producto).</li> <li>Si hay stock del producto seleccionado, la m\u00e1quina dispensa el art\u00edculo elegido y devuelve el importe sobrante (diferencia entre el cr\u00e9dito introducido y el precio del producto).</li> </ol> <p>Durante el proceso se pueden producir diversas incidencias, como por ejemplo, que el cliente no haya introducido suficiente cr\u00e9dito para comprar el producto, que no quede producto o que no haya cambio suficiente para la devoluci\u00f3n. La m\u00e1quina tambi\u00e9n da la posibilidad de solicitar la devoluci\u00f3n del cr\u00e9dito sin realizar la compra.</p> <p>A) Dise\u00f1ar la clase <code>Expendedora</code> (proyecto <code>Expendedora</code>) con los atributos y m\u00e9todos que se describen a continuaci\u00f3n.</p> <ul> <li> <p>Atributos (privados)</p> </li> <li> <p><code>credito</code>: Cantidad de dinero (en euros) introducida por el cliente.</p> </li> <li><code>stock</code>: N\u00famero de unidades que quedan en la m\u00e1quina disponibles para la venta. Se reducir\u00e1 con cada nueva venta.</li> <li><code>precio</code>: Precio del \u00fanico art\u00edculo que dispensa la m\u00e1quina (en euros).</li> <li><code>cambio</code>: Cambio del que dispone la m\u00e1quina. El cambio disponible se reduce cada vez que se devuelve al cliente la diferencia entre el cr\u00e9dito introducido y el precio del producto comprado. El cambio nunca se ve incrementado por las compras de los clientes.</li> <li> <p><code>recaudaci\u00f3n</code>: Representa la suma de las ventas realizadas por la m\u00e1quina (en euros). Se ve incrementada con cada nueva compra.</p> </li> <li> <p>M\u00e9todos:</p> </li> <li> <p>Constructor: <code>public Expendedora (double cambio, int stock, double precio)</code>. Crea la expendedora inicializando los atributos cambio, stock y precio con los valores indicados en los par\u00e1metros). El cr\u00e9dito y la recaudaci\u00f3n ser\u00e1n cero.</p> </li> <li> <p>Consultores:</p> <ul> <li>M\u00e9todos consultores para los atributos cr\u00e9dito, cambio, y recaudaci\u00f3n</li> <li>Los consultores para el stock y el precio los haremos previendo que en el futuro la m\u00e1quina pueda expender m\u00e1s de un tipo de producto. Para consultar el stock y el precio se indicar\u00e1 como par\u00e1metro el n\u00famero de producto que se quiere consultar aunque, por el momento se ignorar\u00e1 el valor de dicho atributo.</li> <li><code>public getStock (int producto)</code> Devuelve el stock disponible del producto indicado. En esta versi\u00f3n simplificada se devolver\u00e1 el valor del atributo stock, sea cual sea el valor de producto.</li> <li><code>public getPrecio (int producto)</code> Devuelve el precio del producto indicado. En esta versi\u00f3n simplificada se devolver\u00e1 el valor del atributo precio, , sea cual sea el valor de producto.</li> </ul> </li> <li> <p>Modificadores: Para simplificar, consideramos que los atributos de la m\u00e1quina solo van a cambiar por operaciones derivadas de su funcionamiento, por lo que no proporcionamos modificadores p\u00fablicos.</p> </li> <li> <p>Otros m\u00e9todos:</p> </li> <li> <p><code>public String toString()</code> Devuelve un <code>String</code> de la forma:</p> Bash<pre><code>Cr\u00e9dito: 3.0 euros\nCambio: 12.73 euros\nStock: 12 unidades\nRecaudaci\u00f3n: 127.87 euros\n</code></pre> </li> <li> <p><code>public void introducirDinero(double importe)</code> Representa la operaci\u00f3n mediante la cual el cliente a\u00f1ade dinero (cr\u00e9dito) a la m\u00e1quina. Esta operaci\u00f3n incrementa el cr\u00e9dito introducido por el cliente en el importe indicado como par\u00e1metro.</p> </li> <li> <p><code>public double solicitarDevolucion()</code> Representa la operaci\u00f3n mediante la cual el cliente solicita la devoluci\u00f3n del cr\u00e9dito introducido sin realizar la compra. El m\u00e9todo devuelve la cantidad de dinero que se devuelve al cliente.</p> </li> <li> <p><code>public double comprarProducto(int producto) throws NoHayCambioException, NoHayProductoException, CreditoInsuficienteException</code>. Representa la operaci\u00f3n mediante la cual el cliente selecciona un producto para su compra. El m\u00e9todo devuelve la cantidad de dinero que se devuelve al cliente.</p> <p>Si no se produce ninguna situaci\u00f3n inesperada, se reduce el stock del producto, se devuelve el cambio, se pone el cr\u00e9dito a cero y se incrementa la recaudaci\u00f3n.</p> <p>Si la venta no es posible se lanzar\u00e1 la excepci\u00f3n correspondiente a la situaci\u00f3n que impide completar la venta.</p> </li> </ul> <p>B) La clase <code>Producto</code> permite representar uno de los art\u00edculos de los que vende una m\u00e1quina expendedora. Para ello utilizaremos tres atributos privados <code>nombre</code> (<code>String</code>), <code>precio</code> (<code>double</code>) y <code>stock</code> (<code>int</code>), y los siguientes m\u00e9todos:</p> <ul> <li><code>public Producto(String nombre, double precio, int stock)</code> Constructor que inicializa el producto con los par\u00e1metros indicados.</li> <li>Consultores de los tres atributos: <code>getNombre</code>, <code>getPrecio</code> y <code>getStock</code>.</li> <li><code>public int decrementarStock()</code>: decrementa en 1 el stock del producto y devuelve el stock resultante.</li> </ul> <p>C) La clase <code>TestExpendedora</code> sirve para provar los m\u00e9todos desarrollados en las clases <code>Expendedora</code> y <code>Producto</code>.</p> <ul> <li>Crea un Objeto de tipo <code>Expendedora</code> e inicializalo con: 12 unidades de stock, 5 euros de cambio y un precio de 3.75 euros. Muestra por pantalla su estado actual.</li> <li>Simula la introducci\u00f3n por parte del cliente de un billete de 5 euros y muestra el estado de la m\u00e1quina <code>Expendedora</code>.</li> <li>Simula la compra de un <code>producto</code> y muestra la cantidad devuelta.</li> <li>Simula la introducci\u00f3n de una moneda de 2 euros y solicita la devoluci\u00f3n sin realizar ninguna compra y muestra la cantidad devuelta.</li> <li>Intenta realizar una compra sin tener suficiente cr\u00e9dito y gestiona la excepci\u00f3n.</li> <li>Crea otro objeto de tipo <code>Expendedora</code> que inicialmente tenga 0 unidades de stock (el resto de valores a tu gusto), simula la compra de un producto teniendo suficiente cr\u00e9dito y cambio. Gestiona la excepci\u00f3n.</li> <li>Crea un \u00faltimo objeto de tipo <code>Expendedora</code> que inicialmente tenga 0 euros de cambio (el resto de valores a tu gusto), simula la compra de un producto para el que la m\u00e1quina tenga que devolver alg\u00fan importe, gestiona la excepci\u00f3n.</li> <li>Muestra las recaudaciones para las 3 m\u00e1quinas expendedoras.</li> </ul> <p>D) La clase <code>Surtido</code> representa una colecci\u00f3n de productos. Para ello se usar\u00e1 un atributo <code>listaProductos</code>, array de <code>Productos</code>. El array se rellenar\u00e1 con los datos de productos extra\u00eddos de un fichero de texto y, una vez creado el surtido no ser\u00e1 posible a\u00f1adir o quitar productos. As\u00ed, el array de productos estar\u00e1 siempre completo y no es necesario ning\u00fan atributo que indique cu\u00e1ntos productos existen en el array.</p> <p>Se implementar\u00e1n los siguientes m\u00e9todos:</p> <ul> <li><code>public Surtido() throws FileNotFoundException</code>: crea el surtido con los datos de los productos que se encuentran en el fichero <code>productos.txt</code>. El fichero tiene el siguiente formato:</li> </ul> Text Only<pre><code>&lt;n\u00ba de productos&gt;\n&lt;nombre de producto&gt; &lt;precio&gt; &lt;stock&gt;\n&lt;nombre de producto&gt; &lt;precio&gt; &lt;stock&gt;\n&lt;nombre de producto&gt; &lt;precio&gt; &lt;stock&gt;\n...\n</code></pre> <p>Como vemos, la primera l\u00ednea del fichero indica el n\u00famero de productos que contiene el surtido. Este dato lo usaremos para dar al array de productos el tama\u00f1o adecuado.</p> <ul> <li> <p><code>public int numProductos()</code>: devuelve el n\u00famero de productos que componen el surtido.</p> </li> <li> <p><code>public Producto getProducto(int numProducto)</code>: devuelve el producto que ocupa la posici\u00f3n <code>numProducto</code> del surtido. La primera posici\u00f3n v\u00e1lida es la <code>1</code>. La posici\u00f3n <code>0</code> no se utiliza.</p> </li> <li><code>public String[] getNombresProductos()</code>: devuelve un array con los nombres de los productos. La posici\u00f3n <code>0</code> del array no se utilizar\u00e1 (ser\u00e1 <code>null</code>).</li> </ul> <p>E) Crea una copia de la clase <code>Expendedora</code> y ll\u00e1mala <code>ExpendedoraSurtido</code>. A\u00f1adir los atributos y hacer los cambios necesarios en la clase para que sea capaz de dispensar varios productos usando la nueva clase <code>Surtido</code>. Por ejemplo, ya no tienen sentido los atributos stock y precio ya que pertenecen al <code>Surtido</code>.</p> <p>A\u00f1ade tambi\u00e9n el m\u00e9todo <code>public String toStringSurtido()</code>, que muestre por pantalla el listado de productos con su nombre, precio y stock para mostrar al cliente que productos puede elegir. El c\u00f3digo del producto coincidir\u00e1 con su posici\u00f3n al leer el surtido.</p> <p>F) Crea una copia de la clase <code>TestExpendedora</code> y ren\u00f3mbrala como <code>TestExpendedora2</code> para adaptarla a los cambios hechos en la clase <code>Expendedora</code> y usando la nueva posibilidad de comprar diferentes productos y usando solamente un \u00fanico objeto <code>Expendedora</code>. Al final en lugar de mostrar la recaudaci\u00f3n de las 3 m\u00e1quinas expendedoras, muestra solo la de la \u00fanica que hay y muestra el surtido.</p>"},{"location":"ud06/ud06ac/#flujos-estandar","title":"Flujos est\u00e1ndar","text":""},{"location":"ud06/ud06ac/#ejercicio-03","title":"Ejercicio 03","text":"<p>ejercicio <code>_03_leeNombre</code></p> <p>Escribir un programa que solicite al usuario su nombre y, utilizando directamente <code>System.in</code>, lo lea de teclado y muestre por pantalla un mensaje del estilo \"Su nombre es Miguel\".  Recuerda que <code>System.in</code> es un objeto de tipo <code>InputStream</code>. La clase <code>InputStream</code> permite leer bytes utilizando el m\u00e9todo <code>read()</code>. Ser\u00e1 tarea nuestra ir construyendo un <code>String</code> a partir de los bytes le\u00eddos. Prueba el programa de manera que el usuario incluya en su nombre alg\u00fan car\u00e1cter \u201cextra\u00f1o\u201d, por ejemplo el s\u00edmbolo \"\u20ac\" \u00bfFunciona bien el programa? \u00bfPor qu\u00e9?</p>"},{"location":"ud06/ud06ac/#ejercicio-04","title":"Ejercicio 04","text":"<p>ejercicio <code>_04_leeEdad</code></p> <p>Escribir un programa que solicite al usuario su edad y, utilizando directamente <code>System.in</code>, la lea de teclado y muestre por pantalla un mensaje del estilo \"Su edad es 32 a\u00f1os\". En este caso, ser\u00e1 tarea nuestra construir un String a partir de los bytes le\u00eddos y transformarlo posteriormente en un entero. </p>"},{"location":"ud06/ud06ac/#ejercicio-05","title":"Ejercicio 05","text":"<p>ejercicio <code>_05_cambiarEstandar</code></p> <p>La salida est\u00e1ndar (<code>System.out</code>) y la salida de errores (<code>System.err</code>) est\u00e1n asociadas por defecto con la pantalla. Se puede cambiar este comportamiento por defecto utilizando los m\u00e9todos <code>System.setout</code> y <code>System.seterr</code> respectivamente. Investiga un poco c\u00f3mo se utilizan, escribe un programa que asocie la salida est\u00e1ndar a al fichero <code>salida.txt</code> y la salida de errores al fichero <code>errores.txt</code> y, a continuaci\u00f3n, escriba alg\u00fan mensaje en cada uno de las salidas, por ejemplo <code>System.out.println(\u201cEl resultado es 20\u201d);</code> y <code>System.err.println(\u201cERROR: Elemento no encontrado\u201d);</code></p>"},{"location":"ud06/ud06ac/#ejercicio-06","title":"Ejercicio 06","text":"<p>ejercicio <code>_06_sumarEdades</code></p> <ul> <li>Escribir m\u00e9todo <code>void sumaEdades()</code> que lea de teclado las edades de una serie de personas y muestre cuanto suman.  El m\u00e9todo finalizar\u00e1 cuando el usuario introduzca una edad negativa.</li> <li>Escribir un m\u00e9todo <code>main</code> que llame al m\u00e9todo anterior para probarlo.</li> <li>Modificar el m\u00e9todo <code>main</code> de forma que, antes de llamar al m\u00e9todo <code>sumaEdades</code>, se cambie la entrada est\u00e1ndar para que tome los datos del fichero <code>edades.txt</code> en lugar de leerlos de teclado.</li> </ul>"},{"location":"ud06/ud06ac/#inputstreamreader","title":"<code>InputStreamReader</code>","text":""},{"location":"ud06/ud06ac/#ejercicio-07","title":"Ejercicio 07","text":"<p>ejercicio <code>_07_leerByte</code></p> <p><code>System.in</code> (<code>InputStream</code>) est\u00e1 orientado a lectura de  bytes. Escribe un programa que lea un byte de teclado y muestre su valor (int) por pantalla. Pru\u00e9balo con un car\u00e1cter \u201cextra\u00f1o\u201d, por ejemplo \u2018\u20ac\u2019.</p>"},{"location":"ud06/ud06ac/#ejercicio-08","title":"Ejercicio 08","text":"<p>ejercicio <code>_08_leerCaracter</code></p> <p><code>InputStreamReader</code> (<code>StreamReader</code>) est\u00e1 orientado a caracteres. Escribe un programa que lea un car\u00e1cter de teclado usando un <code>InputStreamReader</code> y muestre su valor (<code>int</code>) por pantalla. Pru\u00e9balo con un car\u00e1cter \u201cextra\u00f1o\u201d, por ejemplo \u2018\u20ac\u2019. \u00bfSe obtiene el mismo resultado que en el ejercicio anterior?.</p>"},{"location":"ud06/ud06ac/#entrada-orientada-a-lineas","title":"Entrada \"orientada a l\u00edneas\"","text":"<p>En los ejercicios anteriores, las limitaciones de la clase utilizada (<code>InputStream</code>), nos obliga a incluir en el programa instrucciones que detecten que el usuario ha terminado su entrada (ha pulsado INTRO). La clase <code>BuffereReader</code> dispone del m\u00e9todo <code>readLine()</code>, capaz de leer una l\u00ednea completa (la propia instrucci\u00f3n detecta el final de la l\u00ednea) y devolver un <code>String</code>.</p>"},{"location":"ud06/ud06ac/#ejercicio-09","title":"Ejercicio 09","text":"<p>ejercicio <code>_09_leerNombre</code></p> <p>Repite el ejercicio 1 utilizando un <code>BufferedReader</code> asociado a la entrada est\u00e1ndar. La clase <code>BufferedReader</code>, est\u00e1 orientada a leer caracteres en lugar de bytes. \u00bfQu\u00e9 ocurre ahora si el usuario introduce un car\u00e1cter \"extra\u00f1o\" en su nombre?</p>"},{"location":"ud06/ud06ac/#ejercicio-10","title":"Ejercicio 10","text":"<p>ejercicio <code>_10_leeEdad</code></p> <p>Repite el ejercicio 2 utilizando un <code>BufferedReader</code> asociado a la entrada est\u00e1ndar.</p>"},{"location":"ud06/ud06ac/#lecturaescritura-en-ficheros","title":"Lectura/escritura en ficheros","text":""},{"location":"ud06/ud06ac/#ejercicio-11","title":"Ejercicio 11","text":"<p>ejercicio <code>_11_escribirFichero1</code></p> <p>Escribe un programa que, usando las clases <code>FileOutputStream</code> y <code>FileInputStream</code>, </p> <ul> <li>escriba los caracteres de tu nombre en un fichero y los vaya a\u00f1adiendo (<code>nombres.log</code>).</li> <li>lea el fichero creado y lo muestre por pantalla.</li> <li>Si abrimos el fichero creado con un editor de textos, \u00bfsu contenido es legible?</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-12","title":"Ejercicio 12","text":"<p>ejercicio <code>_12_escribirFichero2</code></p> <p>Repetir el ejercicio anterior utilizando las clases <code>FileReader</code> y <code>FileWriter</code>. </p>"},{"location":"ud06/ud06ac/#uso-de-buffers","title":"Uso de buffers","text":"<p>Los  buffers hacen que las operaciones de lectura-escritura  se realicen inicialmente en memoria y, cuando los buffers correspondientes est\u00e1n vac\u00edos/llenos, se hagan definitivamente sobre el dispositivo.</p>"},{"location":"ud06/ud06ac/#ejercicio-13","title":"Ejercicio 13","text":"<p>ejercicio <code>_13_testVelocidadBuffer</code></p> <p>Vamos a probar la diferencia de tiempo que conlleva escribir datos a un fichero directamente o hacerlo a trav\u00e9s de un buffer. Para ello, crea un fichero de 1 Mb (1000000 de bytes aprox.) usando un la clase <code>FileWriter</code> y mide el tiempo que tarda en crearlo. Posteriormente, crea un fichero de exactamente el mismo tama\u00f1o utilizando un <code>BufferedWriter</code> y mide el tiempo que tarda. \u00bfHay diferencia?. Para medir el tiempo puedes utilizar <code>System.currentTimeMillis()</code>, inmediatamente antes y despu\u00e9s de crear el fichero y restar los valores obtenidos.</p>"},{"location":"ud06/ud06ac/#ejercicio-14","title":"Ejercicio 14","text":"<p>ejercicio <code>_14_testVelocidadBuffer2</code></p> <p>Modifica el programa <code>TestVelocidadBuffer</code> para probar c\u00f3mo afecta a la escritura con buffer la ejecuci\u00f3n de la instrucci\u00f3n <code>flush()</code>. Esta instrucci\u00f3n fuerza el volcado del buffer a disco. \u00bfDisminuye la velocidad si tras cada operaci\u00f3n de escritura ejecutamos flush()?</p>"},{"location":"ud06/ud06ac/#ejercicio-15","title":"Ejercicio 15","text":"<p>ejercicio <code>_15_testVelocidadBuffer3</code></p> <p>Modifica el programa <code>TestVelocidadBuffer</code> para probar c\u00f3mo a la velocidad el tama\u00f1o del buffer. La clase <code>BufferedWriter</code> tiene un constructor que permite indicar el tama\u00f1o del buffer. Prueba con distintos valores.</p>"},{"location":"ud06/ud06ac/#streams-para-informacion-binaria","title":"Streams para informaci\u00f3n binaria","text":""},{"location":"ud06/ud06ac/#ejercicio-16","title":"Ejercicio 16","text":"<p>ejercicio <code>_16_personas</code></p> <p>Escribe un programa que, utilizando entre otras la clase <code>DataOutputStream</code>, almacene en un fichero llamado <code>personas.dat</code> la informaci\u00f3n relativa a una serie de personas que va introduciendo el usuario desde teclado:</p> <ul> <li><code>Nombre</code> (String)</li> <li><code>Edad</code> (entero)</li> <li><code>Peso</code> (double)</li> <li><code>Estatura</code> (double)</li> </ul> <p>La entrada del usuario terminar\u00e1 cuando se introduzca un nombre vac\u00edo.</p> <p>Nota: Utiliza la clase <code>Scanner</code> para leer desde teclado y los m\u00e9todos <code>writeDouble</code>, <code>writeInt</code> y <code>writeUTF</code> de la clase <code>DataOutput/InputStream</code> para escribir en el fichero).</p> <p>Al finalizar el programa, abre el fichero resultante con un editor de texto \u00bfLa informaci\u00f3n que contiene es legible?.</p>"},{"location":"ud06/ud06ac/#ejercicio-17","title":"Ejercicio 17","text":"<p>ejercicio <code>_17_anyadirPersonas</code></p> <p>Modifica el programa anterior para que el usuario, al comienzo del programa, pueda elegir si quiere a\u00f1adir datos al fichero o sobre escribir la informaci\u00f3n que contiene.</p>"},{"location":"ud06/ud06ac/#ejercicio-18","title":"Ejercicio 18","text":"<p>ejercicio <code>_18_mostrarPersonas</code></p> <p>Realizar un programa que lea la informaci\u00f3n del fichero <code>personas.dat</code> y la muestre por pantalla. Para determinar que no quedan m\u00e1s datos en el fichero podemos capturar la excepci\u00f3n <code>EOFException</code> .</p>"},{"location":"ud06/ud06ac/#ejercicio-19","title":"Ejercicio 19","text":"<p>ejercicio <code>_19_calculosPersonas</code></p> <p>Realizar un programa, similar al anterior,  que lea la informaci\u00f3n del fichero <code>personas.dat</code> y muestre por pantalla la estatura que tienen de media las personas cuya edad est\u00e1 entre 20 y 30 a\u00f1os.</p>"},{"location":"ud06/ud06ac/#streams-de-objetos-serializacion","title":"Streams de objetos. Serializaci\u00f3n","text":""},{"location":"ud06/ud06ac/#ejercicio-20","title":"Ejercicio 20","text":"<p>ejercicio <code>_20_guardiaLibros</code></p> <ul> <li>(Autor) Crea la clase autor, con los atributos nombre, a\u00f1o de nacimiento y nacionalidad. Incorpora un constructor que reciba todos los datos y el m\u00e9todo <code>toString()</code>.</li> <li>(Libro) Crea la clase Libro, con los atributos titulo, a\u00f1o de edici\u00f3n y autor (Objeto de la clase autor). Incorpora un constructor que reciba todos los datos y el m\u00e9todo <code>toString()</code>.</li> <li>Escribe un programa (GuardaLibros) que cree tres libros y los almacene en el fichero <code>biblioteca.obj</code>.</li> <li>Las clases deber\u00e1n implementar el interfaz <code>Serializable</code>.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-21","title":"Ejercicio 21","text":"<p>ejercicio <code>_21_leeLibros</code></p> <p>Escribe un programa que lea los objetos del fichero <code>biblioteca.obj</code> y los muestre por pantalla.</p>"},{"location":"ud06/ud06ac/#sockets","title":"Sockets","text":""},{"location":"ud06/ud06ac/#ejercicio-22","title":"Ejercicio 22","text":"<p>ejercicio <code>_22_signoZodiaco</code></p> <p>Programar un Servidor que reciba una fecha (previamente validada por el cliente) y nos diga cual es nuestro signo del zod\u00edaco occidental y el animal que corresponde en el zod\u00edaco oriental (animales).</p>"},{"location":"ud06/ud06ac/#mas-ejercicios","title":"M\u00e1s ejercicios","text":""},{"location":"ud06/ud06ac/#ejercicio-23","title":"Ejercicio 23","text":"<p>ejercicio <code>_23_cuentaLineas</code></p> <p>Escribe un programa que, sin utilizar la clase <code>Scanner</code>, muestre el n\u00famero de l\u00edneas que contiene un fichero de texto. El nombre del fichero se solicitar\u00e1 al usuario al comienzo de la ejecuci\u00f3n. </p>"},{"location":"ud06/ud06ac/#ejercicio-24","title":"Ejercicio 24","text":"<p>ejercicio <code>_24_cuentaPalabras</code></p> <p>Escribe un programa que, sin utilizar la clase <code>Scanner</code>, muestre el n\u00famero de palabras que contiene un fichero de texto. El nombre del fichero se solicitar\u00e1 al usuario al comienzo de la ejecuci\u00f3n. </p> <p>Sugerencia</p> <p>Lee el fichero, l\u00ednea a l\u00ednea y utiliza la clase <code>StringTokenizer</code> o bien el m\u00e9todo <code>split</code> de la clase <code>String</code> para averiguar el n\u00ba de palabras.</p>"},{"location":"ud06/ud06ac/#ejercicio-25","title":"Ejercicio 25","text":"<p>ejercicio <code>_25_censura</code></p> <p>Escribir un programa que sustituya por otras, ciertas palabras de un fichero de texto. Para ello, se desarrollar\u00e1 y llamar\u00e1 al m\u00e9todo <code>void aplicaCensura(String entrada, String censura, String salida),</code> que lee de un fichero de entrada y mediante un fichero de censura, crea el correspondiente fichero modificado. Por ejemplo:</p> <p>Fichero de entrada:</p> PHP<pre><code>En un lugar de la Mancha, de cuyo nombre no quiero acordarme, no ha mucho tiempo que viv\u00eda un hidalgo de los de lanza en astillero\n</code></pre> <p>Fichero de censura:</p> PHP<pre><code>lugar sitio\nquiero debo\nhidalgo noble\n</code></pre> <p>Fichero de salida:</p> PHP<pre><code>En un sitio de la Mancha, de cuyo nombre no debo acordarme, no ha mucho tiempo que viv\u00eda un noble de los de lanza en astillero\n</code></pre> <p>Sugerencia</p> <p>Valora la posibilidad de cargar el fichero de censura en un mapa o par clave, valor.</p>"},{"location":"ud06/ud06ac/#ejercicio-26","title":"Ejercicio 26","text":"<p>ejercicio <code>_26_concatenar1</code></p> <p>Escribe un programa que dados dos ficheros de texto <code>f1</code> y <code>f2</code> confeccione un tercer fichero <code>f3</code> cuyo contenido sea el de <code>f1</code> y a continuaci\u00f3n el de <code>f2</code>.</p>"},{"location":"ud06/ud06ac/#ejercicio-27","title":"Ejercicio 27","text":"<p>ejercicio <code>_27_concatenar2</code></p> <p>Escribe un programa que dados dos ficheros de texto <code>f1</code> y <code>f2</code>, a\u00f1ada al final de <code>f1</code> el contenido de <code>f2</code>. Es decir, como el ejercicio anterior, pero sin producir un nuevo fichero.</p>"},{"location":"ud06/ud06ac/#ejercicio-28","title":"Ejercicio 28","text":"<p>ejercicio <code>_28_iguales</code></p> <p>Escribir un programa que compruebe si el contenido de dos ficheros es id\u00e9ntico. Puesto que no sabemos de qu\u00e9 tipo de ficheros se trata, (de texto, binarios, \u2026) habr\u00e1 que hacer una comparaci\u00f3n byte por byte.</p>"},{"location":"ud06/ud06ac/#ejercicio-29","title":"Ejercicio 29","text":"<p>ejercicio <code>_29_generarMedias</code></p> <p>Escribe los siguientes m\u00e9todos y programa:</p> <ul> <li>M\u00e9todo <code>void generar()</code> que genere 20 n\u00fameros aleatorios enteros entre 1 y 100 y los muestre por pantalla.</li> <li>M\u00e9todo <code>void media()</code> que lea de teclado 20 n\u00fameros enteros y calcule su media.</li> <li>Programa que, modificando la entrada y la salida est\u00e1ndar, llame a <code>generar()</code> para que los datos se graben en un fichero y a continuaci\u00f3n llame a <code>media()</code> de manera que se tomen los datos del fichero generado.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-30","title":"Ejercicio 30","text":"<p>ejercicio <code>_30_notas</code></p> <p>Escribir un programa que almacene en un fichero binario (<code>notas.dat</code>) las notas de 20 alumnos. El programa tendr\u00e1 el siguiente funcionamiento:</p> <ul> <li>En el fichero se guardar\u00e1n como m\u00e1ximo 20 notas, pero se pueden guardar menos. El proceso de introducci\u00f3n de notas (y en consecuencia, el programa) finalizar\u00e1 cuando el usuario introduzca una nota no v\u00e1lida (menor que cero o mayor que 10).</li> <li>Si, al comenzar la ejecuci\u00f3n, el fichero ya contiene notas, se indicar\u00e1 al usuario cu\u00e1ntas faltan por a\u00f1adir y las notas que introduzca el usuario se a\u00f1adir\u00e1n a continuaci\u00f3n de las que hay.</li> <li>Si, al comenzar la ejecuci\u00f3n, el fichero ya contiene 20 notas, se le preguntar\u00e1 al usuario si desea sobrescribirlas. En caso afirmativo las notas que introduzca sustituir\u00e1n a las que hay y en caso negativo el fichero no se modificar\u00e1.</li> </ul>"},{"location":"ud06/ud06ac/#mas-ejercicios-lionel","title":"M\u00e1s ejercicios (Lionel)","text":"<p>Descargar Documentos.zip</p> <p>Para probar algunos de estos ejercicios debes utilizar el archivo <code>Documentos.zip</code>. Desc\u00e1rgalo del aula virtual y descompr\u00edmelo en la carpeta de cada proyecto que crees.</p>"},{"location":"ud06/ud06ac/#ejercicio-31","title":"Ejercicio 31","text":"<p>ejercicio <code>_31_informacionFicheros</code></p> <p>Implementa un programa que pida al usuario introducir por teclado una ruta del sistema de archivos (por ejemplo, <code>C:/Windows</code> o <code>Documentos</code>) y muestre informaci\u00f3n sobre dicha ruta (ver funci\u00f3n m\u00e1s abajo). El proceso se repetir\u00e1 una y otra vez hasta que el usuario introduzca una ruta vac\u00eda (tecla intro). Deber\u00e1 manejar las posibles excepciones.</p> <p>Necesitar\u00e1s crear la funci\u00f3n <code>void muestraInfoRuta(File ruta)</code> que dada una ruta de tipo <code>File</code> haga lo siguiente:</p> <ul> <li>Si es un archivo, mostrar\u00e1 por pantalla el nombre del archivo.</li> <li>Si es un directorio, mostrar\u00e1 por pantalla la lista de directorios y archivos que contiene (sus nombres). Deber\u00e1 mostrar primero los directorios y luego los archivos.</li> <li>En cualquier caso, a\u00f1ade delante del nombre la etiqueta <code>[*]</code> o <code>[A]</code> para indicar si es un directorio o un archivo respectivamente.</li> <li>Si el path no existe lanzar\u00e1 un <code>FileNotFoundException</code>.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-32","title":"Ejercicio 32","text":"<p>ejercicio <code>_32_informacionFicheros2</code></p> <p>Partiendo de una copia del programa anterior, modifica la funci\u00f3n <code>muestraInfoRuta</code>:</p> <ul> <li>En el caso de un directorio, mostrar\u00e1 la lista de directorios y archivos en orden alfab\u00e9tico. Es decir, primero los directorios en orden alfab\u00e9tico y luego los archivos en orden alfab\u00e9tico. Te ser\u00e1 \u00fatil <code>Arrays.sort()</code>.</li> <li>A\u00f1ade un segundo argumento <code>boolean info</code> que cuando sea <code>true</code> mostrar\u00e1, junto a la informaci\u00f3n de cada directorio o archivo, su tama\u00f1o en bytes y la fecha de la \u00faltima modificaci\u00f3n. Cuando <code>info</code> sea <code>false</code> mostrar\u00e1 la informaci\u00f3n como en el ejercicio anterior.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-33","title":"Ejercicio 33","text":"<p>ejercicio <code>_33_renombrarFicheros</code></p> <ol> <li>Renombrando directorios y ficheros</li> </ol> <p>Implementa un programa que haga lo siguiente:</p> <ul> <li>Cambiar el nombre de la carpeta <code>Documentos</code> a <code>DOCS</code>, el de la carpeta <code>Fotografias</code> a <code>FOTOS</code> y el de la carpeta <code>Libros</code> a <code>LECTURAS</code>.</li> <li>Cambiar el nombre de todos los archivos de las carpetas <code>FOTOS</code> y <code>LECTURAS</code> quit\u00e1ndole la extensi\u00f3n. Por ejemplo, <code>astronauta.jpg</code> pasar\u00e1 a llamarse <code>astronauta</code>.</li> </ul>"},{"location":"ud06/ud06ac/#ejercicio-34","title":"Ejercicio 34","text":"<p>ejercicio <code>_34_moverCarpetas</code></p> <p>Implementa un programa que cree, dentro de <code>Documentos</code>, dos nuevas carpetas: <code>Mis Cosas</code> y <code>Alfabeto</code>. Mueve las carpetas <code>Fotografias</code> y <code>Libros</code> dentro de <code>Mis Cosas</code>. Luego crea dentro de <code>Alfabeto</code> una carpeta por cada letra del alfabeto (en may\u00fasculas): <code>A</code>, <code>B</code>, <code>C</code>... <code>Z</code>. Te ser\u00e1n de ayuda los c\u00f3digos num\u00e9ricos ASCII: https://elcodigoascii.com.ar.</p>"},{"location":"ud06/ud06ac/#ejercicio-35","title":"Ejercicio 35","text":"<p>ejercicio <code>_35_borrarArchivos</code></p> <p>Implementa un programa con una funci\u00f3n <code>boolean borraTodo(File f)</code> que borre <code>f</code>: Si no existe lanzar\u00e1 una excepci\u00f3n. Si es un archivo lo borrar\u00e1. Si es un directorio, borrar\u00e1 primero sus archivos y luego el propio directorio (recuerda que para poder borrar un directorio debe estar vac\u00edo). Devolver\u00e1 <code>true</code> si pudo borrar el <code>File f</code> (<code>false</code> si no fu\u00e9 posible).</p> <p>Prueba la funci\u00f3n borrando las carpetas: <code>Documentos/Fotografias</code>, <code>Documentos/Libros</code> y <code>Documentos</code> (es decir, tres llamadas a la funci\u00f3n, en ese orden).</p> <p>Super extra challenge: Esta funci\u00f3n, tal y como est\u00e1 definida, no borrar\u00e1 las subcarpetas que est\u00e9n dentro de una carpeta (para ello habr\u00eda que borrar primero el contenido de dichas subcarpetas). \u00bfSe te ocurre c\u00f3mo podr\u00eda hacerse?</p>"},{"location":"ud06/ud06ac/#ejercicio-36","title":"Ejercicio 36","text":"<p>ejercicio <code>_36_maximoMinimo</code></p> <p>Implementa un programa que muestre por pantalla los valores m\u00e1ximos y m\u00ednimos del archivo <code>numeros.txt</code>.</p>"},{"location":"ud06/ud06ac/#ejercicio-37","title":"Ejercicio 37","text":"<p>ejercicio <code>_37_notasAlumnos</code></p> <p>El archivo <code>alumnos_notas.txt</code> contiene una lista de 10 alumnos y las notas que han obtenido en cada asignatura. El n\u00famero de asignaturas de cada alumno es variable. Implementa un programa que muestre por pantalla la nota media de cada alumno junto a su nombre y apellido, ordenado por nota media de mayor a menor.</p>"},{"location":"ud06/ud06ac/#ejercicio-38","title":"Ejercicio 38","text":"<p>ejercicio <code>_38_ordenarArchivos</code></p> <p>Implementa un programa que pida al usuario un nombre de archivo <code>A</code> para lectura y otro nombre de archivo <code>B</code> para escritura. Leer\u00e1 el contenido del archivo <code>A</code> (por ejemplo <code>usa_personas.txt</code>) y lo escribir\u00e1 ordenado alfab\u00e9ticamente en B (por ejemplo <code>usa_personas_sorted.txt</code>).</p>"},{"location":"ud06/ud06ac/#ejercicio-39","title":"Ejercicio 39","text":"<p>ejercicio <code>_39_nombreApellidos</code></p> <p>Implementa un programa que genere aleatoriamente nombres de persona (combinando nombres y apellidos de <code>usa_nombres.txt</code> y <code>usa_apellidos.txt</code>). Se le pedir\u00e1 al usuario cu\u00e1ntos nombres de persona desea generar y a qu\u00e9 archivo a\u00f1adirlos (por ejemplo <code>usa_personas.txt</code>).</p>"},{"location":"ud06/ud06ac/#ejercicio-40","title":"Ejercicio 40","text":"<p>ejercicio <code>_40_diccionario</code></p> <p>Implementa un programa que cree la carpeta <code>Diccionario</code> con tantos archivos como letras del abecedario (<code>A.txt</code>, <code>B.txt</code>\u2026 <code>Z.txt</code>). Introducir\u00e1 en cada archivo las palabras de <code>diccionario.txt</code> que comiencen por dicha letra.</p>"},{"location":"ud06/ud06ac/#ejercicio-41","title":"Ejercicio 41","text":"<p>ejercicio <code>_41_busquedaEnPi</code></p> <p>Implementa un programa que pida al usuario un n\u00famero de cualquier longitud, como por ejemplo \"1234\", y le diga al usuario si dicho n\u00famero aparece en el primer mill\u00f3n de decimales del n\u00ba pi (est\u00e1n en el archivo <code>pi-million.txt</code>). No est\u00e1 permitido utilizar ninguna librer\u00eda ni clase ni m\u00e9todo que realice la b\u00fasqueda. Debes implementar el algoritmo de b\u00fasqueda t\u00fa.</p>"},{"location":"ud06/ud06ac/#ejercicio-42","title":"Ejercicio 42","text":"<p>ejercicio <code>_42_estadisticas</code></p> <p>Implementa un programa que lea un documento de texto y muestre por pantalla algunos datos estad\u00edsticos: n\u00ba de l\u00edneas, n\u00ba de palabras, n\u00ba de caracteres y cu\u00e1les son las 10 palabras m\u00e1s comunes (y cu\u00e1ntas veces aparecen). Prueba el programa con los archivos de la carpeta <code>Libros</code>.</p> <p>Sugerencia</p> <p>Para llevar la cuenta de cu\u00e1ntas veces aparece cada palabra puedes utilizar una HashTable. Una tabla hash es una estructura de datos tipo colecci\u00f3n (como el ArrayList), que permite almacenar pares clave-valor. Por ejemplo {\u201celefante\u201d, 5} o {\u201ccasa\u201d, 10} son pares  que asocian una palabra (clave) con un n\u00ba entero (valor)."},{"location":"ud06/ud06pi/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li> <p>Curso Java. Entrada Salida datos I. V\u00eddeo 14</p> </li> <li> <p>Curso Java. Entrada Salida datos II. V\u00eddeo 15</p> </li> <li>Curso Java. Streams I. Accediendo a ficheros. Lectura. V\u00eddeo 152</li> <li>Curso Java. Streams II. Accediendo a ficheros Escritura. V\u00eddeo 153</li> <li>Curso Java. Streams III. Usando buffers. V\u00eddeo 154</li> <li>Curso Java Streams IV. Leyendo archivos. Streams Byte I. V\u00eddeo 155</li> <li>Curso Java. Streams V. Escribiendo archivos Streams Byte II. V\u00eddeo 156</li> <li>Curso Java. Serializaci\u00f3n. V\u00eddeo 157</li> <li>Curso Java. Serializaci\u00f3n II. SerialVersionUID. V\u00eddeo 158</li> <li>Curso Java. Sockets I. V\u00eddeo 190</li> <li>Curso Java. Manipulaci\u00f3n archivos y directorios. Clase File I. V\u00eddeo 159</li> <li>Curso Java. Manipulaci\u00f3n archivos y directorios. Clase File II. V\u00eddeo 160</li> </ul>"},{"location":"ud06/ud06re/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>Apuntes Lionel</li> </ul>"},{"location":"ud07/ud0701/","title":"7.1 Introducci\u00f3n","text":"<p>Cuando el volumen de datos a manejar por una aplicaci\u00f3n es elevado, no basta con utilizar variables.</p> <p>Manejar los datos de un \u00fanico pedido en una aplicaci\u00f3n puede ser relativamente sencillo, pues un pedido est\u00e1 compuesto por una serie de datos y eso simplemente se traduce en varias variables. Pero, \u00bfqu\u00e9 ocurre cuando en una aplicaci\u00f3n tenemos que gestionar varios pedidos a la vez? Lo mismo ocurre en otros casos. </p> <p>Para poder realizar ciertas aplicaciones se necesita poder manejar datos que van m\u00e1s all\u00e1 de meros datos simples (n\u00fameros y letras). A veces, los datos que tiene que manejar la aplicaci\u00f3n son datos compuestos, es decir, datos que est\u00e1n compuestos a su vez de varios datos m\u00e1s simples. Por ejemplo, un pedido est\u00e1 compuesto por varios datos, los datos podr\u00edan ser el cliente que hace el pedido, la direcci\u00f3n de entrega, la fecha requerida de entrega y los art\u00edculos del pedido.</p> <p>Los datos compuestos son un tipo de estructura de datos, y en realidad ya los has manejado. Las clases son un ejemplo de estructuras de datos que permiten almacenar datos compuestos, y el objeto en s\u00ed, la instancia de una clase, ser\u00eda el dato compuesto. Pero, a veces, los datos tienen estructuras a\u00fan m\u00e1s complejas, y son necesarias soluciones adicionales.</p> <p>Esas soluciones consisten b\u00e1sicamente en la capacidad de poder manejar varios datos del mismo o diferente tipo de forma din\u00e1mica y flexible.</p>"},{"location":"ud07/ud0701/#estructuras-de-almacenamiento","title":"Estructuras de almacenamiento","text":"<p>\u00bfC\u00f3mo almacenar\u00edas en memoria un listado de n\u00fameros del que tienes que extraer el valor m\u00e1ximo?</p> <p>Seguro que te resultar\u00eda f\u00e1cil. Pero, \u00bfy si el listado de n\u00fameros no tiene un tama\u00f1o fijo, sino que puede variar en tama\u00f1o de forma din\u00e1mica? Entonces la cosa se complica.</p> <p>Un listado de n\u00fameros que aumenta o decrece en tama\u00f1o es una de las cosas que aprender\u00e1s a utilizar aqu\u00ed, utilizando estructuras de datos.</p> <p>Pasaremos por alto las clases y los objetos, pues ya los has visto con anterioridad, pero debes saber que las clases en s\u00ed mismas son la evoluci\u00f3n de un tipo de estructuras de datos conocidas como datos compuestos (tambi\u00e9n llamadas registros). Las clases, adem\u00e1s de aportar la ventaja de agrupar datos relacionados entre s\u00ed en una misma estructura (caracter\u00edstica aportada por los datos compuestos), permiten agregar m\u00e9todos que manejen dichos datos, ofreciendo una herramienta de programaci\u00f3n sin igual. Pero todo esto ya lo sab\u00edas.</p> <p>Las estructuras de almacenamiento, en general, se pueden clasificar de varias formas, atendiendo a: </p> Si pueden almacenar datos de diferente tipo o no con capacidad de almacenar varios datos del mismo tipo: varios n\u00fameros, varios caracteres, etc. los arrays, las listas, los conjuntos, las cadenas de caracteres con capacidad de almacenar varios datos de distinto tipo: n\u00fameros, fechas, cadenas de caracteres, etc. las clases En funci\u00f3n de si pueden o no cambiar de tama\u00f1o de forma din\u00e1mica cuyo tama\u00f1o se establece en el momento de la creaci\u00f3n o definici\u00f3n y su tama\u00f1o no puede variar despu\u00e9s. los arrays, las matrices (arrays multidimensionales) cuyo tama\u00f1o es variable (conocidas como estructuras din\u00e1micas). Su tama\u00f1o crece o decrece seg\u00fan las necesidades de forma din\u00e1mica. las listas, \u00e1rboles, conjuntos y el caso de algunos tipos de cadenas de caracteres. Atendiendo a la forma en la que los datos se ordenan dentro de la estructura que no se ordenan de por s\u00ed, y debe ser el programador el encargado de ordenar los datos si fuera necesario los arrays ordenadas: al incorporar un dato nuevo a todos los datos existentes, este se almacena en una posici\u00f3n concreta que ir\u00e1 en funci\u00f3n del orden. El orden establecido en la estructura puede variar dependiendo de las necesidades del programa: alfab\u00e9tico, orden num\u00e9rico de mayor a menor, momento de inserci\u00f3n, etc. ArrayList, TreeSet <p>Todav\u00eda no conoces mucho de las estructuras, y probablemente todo te suena raro y extra\u00f1o. No te preocupes, poco a poco ir\u00e1s descubri\u00e9ndolas. Ver\u00e1s que son sencillas de utilizar y muy c\u00f3modas.</p>"},{"location":"ud07/ud0701/#clases-y-metodos-genericos","title":"Clases y m\u00e9todos gen\u00e9ricos","text":"<p>\u00bfCrees que el c\u00f3digo es m\u00e1s legible al utilizar gen\u00e9ricos o que se complica? La verdad es que al principio cuesta, pero despu\u00e9s, el c\u00f3digo se entiende mejor que si se empieza a insertar conversiones de tipo.</p> <p>Las clases gen\u00e9ricas son equivalentes a los m\u00e9todos gen\u00e9ricos pero a nivel de clase, permiten definir un par\u00e1metro de tipo gen\u00e9rico que se podr\u00e1 usar a lo largo de toda la clase, facilitando as\u00ed crear clases gen\u00e9ricas que son capaces de trabajar con diferentes tipos de datos base. Para crear una clase gen\u00e9rica se especifican los par\u00e1metros de tipo al lado del nombre de la clase:</p> Java<pre><code> public class Util&lt;T&gt; {\n    T temp;\n\n    public void invertir (T[] array) {\n       for (int i = 0; i &lt; array.length / 2; i++) {\n          temp = array[i];\n          array[i] = array[array.length - i - 1];\n          array[array.length - i - 1] = temp;\n       }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, la clase <code>Util</code> contiene el m\u00e9todo <code>invertir</code> cuya funci\u00f3n es invertir el orden de los elementos de cualquier <code>array</code>, sea del tipo que sea. Para usar esa clase gen\u00e9rica hay que crear un objeto o instancia de dicha clase especificando el tipo base entre los s\u00edmbolos menor que (<code>&lt;</code>) y mayor que (<code>&gt;</code>), justo detr\u00e1s del nombre de la clase. Veamos un ejemplo:</p> Java<pre><code>Integer[] numeros = {0,1,2,3,4,5,6,7,8,9}; //el array clase wrapper\n\nUtil&lt;Integer&gt; u = new Util&lt;Integer&gt;();\n\nu.invertir(numeros);\nfor (int i=0; i&lt;numeros.length; i++){\n   System.out.println(numeros[i]);\n}\n</code></pre> <p>Como puedes observar, el uso de gen\u00e9ricos es sencillo, tanto a nivel de clase como a nivel de m\u00e9todo.</p> <p>Simplemente, a la hora de crear una instancia de una clase gen\u00e9rica, hay que especificar el tipo, tanto en la definici\u00f3n (<code>Util&lt;Integer&gt; u</code>) como en la creaci\u00f3n (<code>new Util&lt;Integer&gt;()</code>).</p> <p>Los gen\u00e9ricos los vamos a usar ampliamente a partir de ahora, aplicados a un mont\u00f3n de clases gen\u00e9ricas que tiene Java y que son de gran utilidad, por lo que es conveniente que aprendas bien a usar una clase gen\u00e9rica.</p> <p>Par\u00e1metros de las clases gen\u00e9ricas</p> <p>Los par\u00e1metros de tipo de las clases gen\u00e9ricas solo pueden ser clases: - no pueden ser jam\u00e1s tipos de datos primitivos como <code>int</code>, <code>short</code>, <code>double</code>, etc. - debemos usar sus clases envoltorio (wrappers) <code>Integer</code>, <code>Short</code>, <code>Double</code>, etc.</p> <p>Todav\u00eda hay un mont\u00f3n de cosas m\u00e1s sobre los m\u00e9todos y las clases gen\u00e9ricas que deber\u00edas saber. A continuaci\u00f3n se muestran algunos usos interesantes de los gen\u00e9ricos:</p> <ul> <li>Dos o m\u00e1s par\u00e1metros de tipo (I):</li> </ul> <p>Si el m\u00e9todo gen\u00e9rico necesita tener dos o m\u00e1s par\u00e1metros gen\u00e9ricos, podemos indicarlo separ\u00e1ndolos por comas. </p> Java<pre><code>public class Util&lt;T,M&gt;{\n    public static &lt;T,M&gt; int sumaDeLongitudes (T[] a, M[] b){\n       return a.length + b.length;\n    }\n}\n</code></pre> <p>\u200b   En el ejemplo anterior se suman las longitudes de dos arrays que no tienen que ser del mismo tipo.</p> <ul> <li>Dos o m\u00e1s par\u00e1metros de tipo (II):</li> </ul> <p>Usar un m\u00e9todo o una clase con dos o m\u00e1s par\u00e1metros gen\u00e9ricos es sencillo, a la hora de invocar al m\u00e9todo o crear la clase, se indican los tipos base separados por coma.</p> Java<pre><code>Integer[] a1 = {0,1,2,3,4};\nDouble[]  a2 = {0d,1d,2d,3d,4d};\nint resultado = Util.&lt;Integer,Double&gt;sumaDeLongitudes(a1,a2);\nSystem.out.println(resultado);\n</code></pre> <ul> <li>Dos o m\u00e1s par\u00e1metros de tipo (III):</li> </ul> <p>Si una clase gen\u00e9rica necesita tener dos o m\u00e1s par\u00e1metros gen\u00e9ricos, podemos indicarlo separ\u00e1ndolos por comas.    En el ejemplo anterior se muestra una clase que almacena una terna de elementos de diferente tipo base que est\u00e1n relacionados entre s\u00ed.</p> Java<pre><code>public class Terna&lt;A,B,C&gt;{\n  A a;\n  B b;\n  C c;\n  public Terna(A a, B b, C c){\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n  public A getA(){return a;}\n  public B getB(){return b;}\n  public C getC(){return c;}\n}\n</code></pre> <ul> <li>M\u00e9todos con tipos adicionales:</li> </ul> <p>Una clase gen\u00e9rica puede tener unos par\u00e1metros gen\u00e9ricos, pero si en uno de sus m\u00e9todos necesitamos otros par\u00e1metros gen\u00e9ricos distintos, no hay problema, podemos combinarlos.</p> Java<pre><code>class Util&lt;A,B&gt;{\n  A a;\n  Util (A a){\n    this.a = a;\n  }\n  public &lt;B&gt; void salida(B b){\n    System.out.println ( a.toString() + b.toString() );\n  }\n}\n</code></pre> <ul> <li>Inferencia (deducci\u00f3n) de tipos (I):</li> </ul> <p>No siempre es necesario indicar los tipos a la hora de instanciar un m\u00e9todo gen\u00e9rico. A partir de Java 7, es capaz de determinar los tipos a partir de los par\u00e1metros.</p> Java<pre><code>Integer[] a1 = {0,1,2,3,4};\nDouble[]  a2 = {0d,1d,2d,3d,4d};\nutil.&lt;Integer,Double&gt;sumaDeLongitudes(a1,a2);\nutil.sumaDeLongitudes(a1,a2);  //no es necesario indicar el tipo para instanciar\n</code></pre> <p>Las dos expresiones de arriba serian v\u00e1lidas y funcionar\u00edan. Si no es capaz de inferirlos, nos dar\u00e1 un error a la hora de compilar.</p> <ul> <li>Inferencia de tipos (II):</li> </ul> <p>A partir de Java 7 es posible usar el operador diamante <code>&lt; &gt;</code> para simplificar la instanciaci\u00f3n o creaci\u00f3n de nuevos objetos a partir de clases gen\u00e9ricas. Cuidado, esto solo es posible a partir de Java 7.</p> Java<pre><code>Integer a1 = 0;\nDouble  d1 = 1.3d;\nFloat   f1 = 1.4f;\nTerna &lt;Integer,Double,Float&gt; t = new Terna&lt;&gt;(a1,d1,f1);\n</code></pre> <ul> <li>Limitaci\u00f3n de tipos:</li> </ul> <p>Se pueden limitar el conjunto de tipos que se pueden usar con una clase o m\u00e9todo gen\u00e9rico usando el operador <code>extends</code>. El operador <code>extends</code> permite indicar que la clase que se pasa como par\u00e1metro gen\u00e9rico tiene que derivar de una clase espec\u00edfica.</p> Java<pre><code>public class Util {\n    public static &lt;T extends Number&gt; Double sumar (T t1, T t2){\n        return t1.doubleValue() + t2.doubleValue();\n    }\n}\n</code></pre> <p>En el ejemplo, no se admitir\u00e1 ninguna clase que no derive de <code>Number</code>, pudiendo as\u00ed realizar operaciones matem\u00e1ticas.</p> <ul> <li>Paso de clases gen\u00e9ricas por par\u00e1metro:</li> </ul> <p>Cuando un m\u00e9todo tiene como par\u00e1metro una clase gen\u00e9rica (como en el caso del m\u00e9todo test del ejemplo), se puede especificar cu\u00e1l debe ser el tipo base usado en la instancia de la clase gen\u00e9rica que se le pasa como argumento. Esto permite, entre otras cosas, crear diferentes versiones de un mismo m\u00e9todo (sobrecarga), dependiendo del tipo base usado en la instancia de la clase gen\u00e9rica se ejecutar\u00e1 una versi\u00f3n u otra.</p> Java<pre><code>public class Ejemplo &lt;A&gt; {\n  public A a;\n}\n...\nvoid test (Ejemplo&lt;Integer&gt; e) {\n  ...\n}\n</code></pre> <ul> <li>Paso de clases gen\u00e9ricas por par\u00e1metro. Wildcards (I):</li> </ul> <p>Cuando un m\u00e9todo admite como par\u00e1metro una clase gen\u00e9rica en la que no importa el tipo de objeto sobre la que se ha creado, podemos usar el interrogante para indicar \"cualquier tipo\".</p> Java<pre><code>public class Ejemplo &lt;A&gt; {\n   public A a;\n}\n...\nvoid test (Ejemplo&lt;?&gt; e) {\n   ...\n}\n</code></pre> <ul> <li>Paso de clases gen\u00e9ricas por par\u00e1metro. Wildcards (II):</li> </ul> <p>Tambi\u00e9n es posible limitar el conjunto de tipos que una clase gen\u00e9rica puede usar, a trav\u00e9s del operador <code>extends</code>. El ejemplo anterior es como decir \"cualquier tipo que derive de Number\".</p> Java<pre><code>public class Ejemplo &lt;A&gt; {\n   public A a;\n}\n...\nvoid test (Ejemplo&lt;? extends Number&gt; e) {\n   ...\n}\n</code></pre>"},{"location":"ud07/ud0702/","title":"7.2 Colecciones","text":""},{"location":"ud07/ud0702/#introduccion","title":"Introducci\u00f3n","text":"<p>\u00bfQu\u00e9 consideras una colecci\u00f3n? Pues seguramente al pensar en el t\u00e9rmino se te viene a la cabeza una colecci\u00f3n de libros o algo parecido, y la idea no va muy desencaminada. Una colecci\u00f3n a nivel de software es un grupo de elementos almacenados de forma conjunta en una misma estructura. Eso son las colecciones.</p> <p>Las colecciones definen un conjunto de interfaces, clases gen\u00e9ricas y algoritmos que permiten manejar grupos de objetos, todo ello enfocado a potenciar la reusabilidad del software y facilitar las tareas de programaci\u00f3n. Te parecer\u00e1 incre\u00edble el tiempo que se ahorra empleando colecciones y c\u00f3mo se reduce la complejidad del software us\u00e1ndolas adecuadamente. Las colecciones permiten almacenar y manipular grupos de objetos que, a priori, est\u00e1n relacionados entre s\u00ed (aunque no es obligatorio que est\u00e9n relacionados, lo l\u00f3gico es que si se almacenan juntos es porque tienen alguna relaci\u00f3n entre s\u00ed), pudiendo trabajar con cualquier tipo de objeto (de ah\u00ed que se empleen los gen\u00e9ricos en las colecciones).</p> <p>Adem\u00e1s las colecciones permiten realizar algunas operaciones \u00fatiles sobre los elementos almacenados, tales como b\u00fasqueda u ordenaci\u00f3n. En algunos casos es necesario que los objetos almacenados cumplan algunas condiciones (que implementen algunas interfaces), para poder hacer uso de estos algoritmos. </p> <p>Las colecciones son en general elementos de programaci\u00f3n que est\u00e1n disponibles en muchos lenguajes de programaci\u00f3n. En algunos lenguajes de programaci\u00f3n su uso es algo m\u00e1s complejo (como es el caso de C++), pero en Java su uso es bastante sencillo.</p> <p>Las colecciones en Java parten de una serie de interfaces b\u00e1sicas. Cada interfaz define un modelo de colecci\u00f3n y las operaciones que se pueden llevar a cabo sobre los datos almacenados, por lo que es necesario conocerlas. La interfaz inicial, a trav\u00e9s de la cual se han construido el resto de colecciones, es la interfaz <code>java.util.Collection</code>, que define las operaciones comunes a todas las colecciones derivadas. A continuaci\u00f3n se muestran las operaciones m\u00e1s importantes definidas por esta interfaz, ten en cuenta que <code>Collection</code> es una interfaz gen\u00e9rica donde <code>&lt;E&gt;</code> es el par\u00e1metro de tipo (podr\u00eda ser cualquier clase):</p> <ul> <li>M\u00e9todo <code>int size()</code> : retorna el n\u00famero de elementos de la colecci\u00f3n.</li> <li>M\u00e9todo <code>boolean isEmpty()</code> : retornar\u00e1 verdadero si la colecci\u00f3n est\u00e1 vac\u00eda.</li> <li>M\u00e9todo <code>boolean contains (Object element)</code>: retornar\u00e1 verdadero si la colecci\u00f3n tiene el elemento pasado como par\u00e1metro.</li> <li>M\u00e9todo <code>boolean add(E element)</code> : permitir\u00e1 a\u00f1adir elementos a la colecci\u00f3n.</li> <li>M\u00e9todo <code>boolean remove(Object element)</code> : permitir\u00e1 eliminar elementos de la colecci\u00f3n.</li> <li>M\u00e9todo <code>Iterator&lt;E&gt; iterator()</code>: permitir\u00e1 crear un iterador para recorrer los elementos de la colecci\u00f3n. Esto se ve m\u00e1s adelante, no te preocupes.</li> <li>M\u00e9todo <code>Object[] toArray()</code>: permite pasar la colecci\u00f3n a un array de objetos tipo Object.</li> <li>M\u00e9todo <code>boolean containsAll(Collection&lt;?&gt; c)</code>: permite comprobar si una colecci\u00f3n contiene los elementos existentes en otra colecci\u00f3n, si es as\u00ed, retorna verdadero.</li> <li>M\u00e9todo <code>boolean addAll(Collection&lt;?&gt; extends E&gt; c)</code>: permite a\u00f1adir todos los elementos de una colecci\u00f3n a otra colecci\u00f3n, siempre que sean del mismo tipo (o deriven del mismo tipo base).</li> <li>M\u00e9todo <code>boolean removeAll(Collection&lt;?&gt; c)</code>: si los elementos de la colecci\u00f3n pasada como par\u00e1metro est\u00e1n en nuestra colecci\u00f3n, se eliminan, el resto se quedan.</li> <li>M\u00e9todo <code>boolean retainAll(Collection&lt;?&gt; c)</code>: si los elementos de la colecci\u00f3n pasada como par\u00e1metro est\u00e1n en nuestra colecci\u00f3n, se dejan, el resto se eliminan.</li> <li>M\u00e9todo <code>void clear()</code>: vaciar la colecci\u00f3n.</li> </ul> <p>M\u00e1s adelante veremos c\u00f3mo se usan estos m\u00e9todos, ser\u00e1 cuando veamos las implementaciones (clases gen\u00e9ricas que implementan alguna de las interfaces derivadas de la interfaz <code>Collection</code>).</p>"},{"location":"ud07/ud0702/#conjuntos-sets","title":"Conjuntos (sets)","text":"<p>\u00bfCon qu\u00e9 relacionar\u00edas los conjuntos? Seguro que con las matem\u00e1ticas. Los conjuntos son un tipo de colecci\u00f3n que no admite duplicados, derivados del concepto matem\u00e1tico de conjunto.</p> <p>La interfaz <code>java.util.Set</code> define c\u00f3mo deben ser los conjuntos, y implementa la interfaz <code>Collection</code>, aunque no a\u00f1ade ninguna operaci\u00f3n nueva. Las implementaciones (clases gen\u00e9ricas que implementan la interfaz <code>Set</code>) m\u00e1s usadas son las siguientes:</p> <ul> <li><code>java.util.HashSet</code>. Conjunto que almacena los objetos usando tablas hash (estructura de datos formada b\u00e1sicamente por un array donde la posici\u00f3n de los datos va determinada por una funci\u00f3n hash, permitiendo localizar la informaci\u00f3n de forma extraordinariamente r\u00e1pida. Los datos est\u00e1n ordenados en la tabla en base a un resumen num\u00e9rico de los mismos (en hexadecimal generalmente) obtenido a partir de un algoritmo para c\u00e1lculo de res\u00famenes, denominadas funciones hash. El resumen no tiene significado para un ser humano, se trata simplemente de un mecanismo para obtener un n\u00famero asociado a un conjunto de datos. El inconveniente de estas tablas es que los datos se ordenan por el resumen obtenido, y no por el valor almacenado. El resumen, de un buen algoritmo hash, no se parece en nada al contenido almacenado) lo cual acelera enormemente el acceso a los objetos almacenados.</li> </ul> <p>Inconvenientes: necesitan bastante memoria y no almacenan los objetos de forma ordenada (al contrario, pueden aparecer completamente desordenados).</p> <ul> <li> <p><code>java.util.LinkedHashSet</code>. Conjunto que almacena objetos combinando tablas hash, para un acceso r\u00e1pido a los datos, y listas enlazadas (estructura de datos que almacena los objetos enlaz\u00e1ndolos entre s\u00ed a trav\u00e9s de un apuntador de memoria o puntero, manteniendo un orden, que generalmente es el del momento de inserci\u00f3n, pero que puede ser otro. Cada dato se almacena en una estructura llamada nodo en la que existe un campo, generalmente llamado siguiente, que contiene la direcci\u00f3n de memoria del siguiente nodo (con el siguiente dato)) para conservar el orden. El orden de almacenamiento es el de inserci\u00f3n, por lo que se puede decir que es una estructura ordenada a medias.</p> </li> <li> <p>Inconvenientes: necesitan bastante memoria y es algo m\u00e1s lenta que <code>HashSet</code> .</p> </li> <li> <p><code>java.util.TreeSet</code>. Conjunto que almacena los objetos usando unas estructuras conocidas como \u00e1rboles rojo\u2010negro. Son m\u00e1s lentas que los dos tipos anteriores. pero tienen una gran ventaja: los datos almacenados se ordenan por valor. Es decir, que aunque se inserten los elementos de forma desordenada, internamente se ordenan dependiendo del valor de cada uno.</p> </li> </ul> <p>Poco a poco, iremos viendo que son las listas enlazadas y los \u00e1rboles (no profundizaremos en los \u00e1rboles rojo\u2010negro, pero si veremos las estructuras tipo \u00e1rbol en general). Veamos un ejemplo de uso b\u00e1sico de la estructura <code>HashSet</code> y despu\u00e9s, profundizaremos en los <code>LinkedHashSet</code> y los <code>TreeSet</code> .</p> <p>Para crear un conjunto, simplemente creamos el <code>HashSet</code> indicando el tipo de objeto que va a almacenar, dado que es una clase gen\u00e9rica que puede trabajar con cualquier tipo de dato debemos crearlo como sigue (no olvides hacer la importaci\u00f3n de <code>java.util.HashSet</code> primero):</p> Java<pre><code>HashSet&lt;Integer&gt; conjunto=new HashSet&lt;Integer&gt;();\nHashSet&lt;Integer&gt; conjunto=new HashSet&lt;&gt;(); //a partir de Java 7\n</code></pre> <p>Despu\u00e9s podremos ir almacenando objetos dentro del conjunto usando el m\u00e9todo <code>add</code> (definido por la interfaz <code>Set</code>). Los objetos que se pueden insertar ser\u00e1n siempre del tipo especificado al crear el conjunto:</p> Java<pre><code>Integer n=new Integer(10);\nif (!conjunto.add(n)){\n    System.out.println(\"N\u00famero ya en la lista.\");\n}\n</code></pre> <p>Si el elemento ya est\u00e1 en el conjunto, el m\u00e9todo <code>add</code> retornar\u00e1 <code>false</code> indicando que no se pueden insertar duplicados. Si todo va bien, retornar\u00e1 <code>true</code>.</p>"},{"location":"ud07/ud0702/#acceso","title":"Acceso","text":"<p>Y ahora te preguntar\u00e1s, \u00bfc\u00f3mo accedo a los elementos almacenados en un conjunto? Para obtener los elementos almacenados en un conjunto hay que usar iteradores, que permiten obtener los elementos del conjunto uno a uno de forma secuencial (no hay otra forma de acceder a los elementos de un conjunto, es su inconveniente). Los iteradores se ven en mayor profundidad m\u00e1s adelante, de momento, vamos a usar iteradores de forma transparente, a trav\u00e9s de una estructura for especial, denominada bucle \" for-each \" o bucle \"para cada\". En el siguiente c\u00f3digo se usa un bucle foreach, en \u00e9l la variable i va tomando todos los valores almacenados en el conjunto hasta que llega al \u00faltimo:</p> Java<pre><code>for (Integer i: conjunto) {\n    System.out.println(\"Elemento almacenado:\"+i);\n}\n</code></pre> <p>Como ves la estructura <code>for-each</code> es muy sencilla: la palabra <code>for</code> seguida de \"(<code>tipo variable:colecci\u00f3n</code>)\" y el cuerpo del bucle; <code>tipo</code> es el tipo del objeto sobre el que se ha creado la colecci\u00f3n, <code>variable</code> pues es la variable donde se almacenar\u00e1 cada elemento de la colecci\u00f3n y <code>coleccion</code> la colecci\u00f3n en s\u00ed. Los bucles <code>for-each</code> se pueden usar para todas las colecciones.</p>"},{"location":"ud07/ud0702/#linkedhashset-y-treeset","title":"<code>LinkedHashSet</code> y <code>TreeSet</code>","text":"<p>\u00bfEn qu\u00e9 se diferencian las estructuras <code>LinkedHashSet</code> y <code>TreeSet</code> de la estructura <code>HashSet</code>? Ya se comento antes, y es b\u00e1sicamente en su funcionamiento interno.</p> <p>La estructura <code>LinkedHashSet</code> es una estructura que internamente funciona como una lista enlazada, aunque usa tambi\u00e9n tablas hash para poder acceder r\u00e1pidamente a los elementos. Una lista enlazada es una estructura similar a la representada en la imagen de la derecha, la cual est\u00e1 compuesta por nodos (elementos que forman la lista) que van enlaz\u00e1ndose entre s\u00ed. Un nodo contiene dos cosas: el dato u objeto almacenado en la lista y el siguiente nodo de la lista. Si no hay siguiente nodo, se indica poniendo nulo (null) en la variable que contiene el siguiente nodo.</p> <p>Las listas enlazadas tienen un mont\u00f3n de operaciones asociadas en las que no vamos a profundizar: eliminaci\u00f3n de un nodo de la lista, inserci\u00f3n de un nodo al final, al principio o entre dos nodos, etc. </p> <p>Gracias a las colecciones podremos utilizar listas enlazadas sin tener que complicarnos en detalles de programaci\u00f3n.</p> <p>La estructura <code>TreeSet</code>, en cambio, utiliza internamente \u00e1rboles. Los \u00e1rboles son como las listas pero mucho m\u00e1s complejos. En vez de tener un \u00fanico elemento siguiente, pueden tener dos o m\u00e1s elementos siguientes, formando estructuras organizadas y jer\u00e1rquicas.</p> <p>Los nodos se diferencian en dos tipos: nodos padre y nodos hijo; un nodo padre puede tener varios nodos hijo asociados (depende del tipo de \u00e1rbol), dando lugar a una estructura que parece un \u00e1rbol invertido (de ah\u00ed su nombre).</p> <p>En la figura de abajo se puede apreciar un \u00e1rbol donde cada nodo puede tener dos hijos, denominados izquierdo (izq) y derecho (dch). Puesto que un nodo hijo puede tambi\u00e9n ser padre a su vez, los \u00e1rboles se suelen visualizar para su estudio por niveles para entenderlos mejor, donde cada nivel contiene hijos de los nodos del nivel anterior, excepto el primer nivel (que no tiene padre).</p> <p>Los \u00e1rboles son estructuras complejas de manejar y que permiten operaciones muy sofisticadas. Los \u00e1rboles usados en los <code>TreeSet</code>, los \u00e1rboles rojo\u2010negro, son \u00e1rboles auto-ordenados, es decir, que al insertar un elemento, este queda ordenado por su valor de forma que al recorrer el \u00e1rbol, pasando por todos los nodos, los elementos salen ordenados. El ejemplo mostrado en la imagen es simplemente un \u00e1rbol binario, el m\u00e1s simple de todos.</p> <p>Nuevamente, no se va a profundizar en las operaciones que se pueden realizar en un \u00e1rbol a nivel interno (inserci\u00f3n de nodos, eliminaci\u00f3n de nodos, b\u00fasqueda de un valor, etc.). Nos aprovecharemos de las colecciones para hacer uso de su potencial. En la siguiente tabla tienes un uso comparado de <code>TreeSet</code> y <code>LinkedHashSet</code> . Su creaci\u00f3n es similar a como se hace con <code>HashSet</code> , simplemente sustituyendo el nombre de la clase <code>HashSet</code> por una de las otras. Ni <code>TreeSet</code> , ni <code>LinkedHashSet</code> admiten duplicados, y se usan los mismos m\u00e9todos ya vistos antes, los existentes en la interfaz <code>Set</code> (que es la interfaz que implementan).</p> <ul> <li>Conjunto <code>TreeSet</code> (Ejemplo01):</li> </ul> Java<pre><code>package UD07.P2_2_Sets;\n\nimport java.util.TreeSet;\n\npublic class Ejemplo01 {\n\n    public static void main(String[] args) {\n        TreeSet&lt;Integer&gt; t = new TreeSet&lt;&gt;();\n        t.add(4);\n        t.add(3);\n        t.add(1);\n        t.add(99);\n        for (Integer i : t) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n</code></pre> <p>Resultado mostrado por pantalla (el resultado sale ordenado por valor):</p> Java<pre><code>1 3 4 99\n</code></pre> <ul> <li>Conjunto <code>LinkedHashSet</code> (Ejemplo02):</li> </ul> Java<pre><code>package UD07.P2_2_Sets;\n\nimport java.util.LinkedHashSet;\n\npublic class Ejemplo02 {\n\n    public static void main(String[] args) {\n        LinkedHashSet&lt;Integer&gt; t = new LinkedHashSet&lt;&gt;();\n        t.add(4);\n        t.add(3);\n        t.add(1);\n        t.add(99);\n        for (Integer i : t) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n</code></pre> <p>Resultado mostrado por pantalla (los valores salen ordenados seg\u00fan el momento de inserci\u00f3n en el conjunto):</p> Java<pre><code>4 3 1 99\n</code></pre>"},{"location":"ud07/ud0702/#operar-con-elementos","title":"Operar con elementos","text":"<p>\u00bfC\u00f3mo podr\u00eda copiar los elementos de un conjunto de uno a otro? \u00bfHay que usar un bucle for y recorrer toda la lista para ello? \u00a1Qu\u00e9 va! Para facilitar esta tarea, los conjuntos, y las colecciones en general, facilitan un mont\u00f3n de operaciones para poder combinar los datos de varias colecciones. Ya se vieron en un apartado anterior, aqu\u00ed simplemente vamos poner un ejemplo de su uso.</p> <p>Partimos del siguiente ejemplo, en el que hay dos colecciones de diferente tipo, cada una con 4 n\u00fameros enteros:</p> Java<pre><code>TreeSet&lt;Integer&gt; A= new TreeSet&lt;Integer&gt;();\nA.add(9); A.add(19); A.add(5); A.add(7); // Elementos del conjunto A: 9, 19, 5 y 7\nLinkedHashSet&lt;Integer&gt; B= new LinkedHashSet&lt;Integer&gt;();\nB.add(10); B.add(20); B.add(5); B.add(7); // Elementos del conjunto B: 10, 20, 5 y 7\n</code></pre> <p>En el ejemplo anterior, el literal de n\u00famero se convierte autom\u00e1ticamente a la clase envoltorio <code>Integer</code> sin tener que hacer nada, lo cual es una ventaja. Veamos las formas de combinar ambas colecciones:</p> <ul> <li>Uni\u00f3n. A\u00f1adir todos los elementos del conjunto B en el conjunto A.</li> </ul> Java<pre><code> A.addAll(B)\n</code></pre> <p>Todos los del conjunto A, a\u00f1adiendo los del B, pero sin repetir los que ya est\u00e1n: </p> Bash<pre><code>5, 7, 9, 10, 19 y 20.\n</code></pre> <ul> <li>Diferencia. Eliminar los elementos del conjunto B que puedan estar en el conjunto A.</li> </ul> Java<pre><code> A.removeAll(B)\n</code></pre> <p>Todos los elementos del conjunto A, que no est\u00e9n en el conjunto B: </p> Bash<pre><code>9, 19.\n</code></pre> <ul> <li>Intersecci\u00f3n. Retiene los elementos comunes a ambos conjuntos.</li> </ul> Java<pre><code> A.retainAll(B)\n</code></pre> <p>Todos los elementos del conjunto A, que tambi\u00e9n est\u00e1n en el conjunto B:</p> Bash<pre><code>5 y 7.\n</code></pre> <p>Recuerda</p> <p>Estas operaciones son comunes a todas las colecciones.</p> Ejemplo 03 Java<pre><code>package UD07.P2_2_Sets;\n\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.TreeSet;\n\npublic class Ejemplo03 {\n\n    private static void imprimirColeccion(Collection&lt;?&gt; c) {\n        for (Object i : c) {\n            System.out.print(i.toString() + \" \");\n        }\n        System.out.println(\"\");\n    }\n\n    public static void main(String[] args) {\n        TreeSet&lt;Integer&gt; conjuntoA = new TreeSet&lt;&gt;();\n        conjuntoA.add(9);\n        conjuntoA.add(19);\n        conjuntoA.add(5);\n        conjuntoA.add(7); // Elementos del conjunto A: 9, 19, 5 y 7\n        LinkedHashSet&lt;Integer&gt; conjuntoB = new LinkedHashSet&lt;&gt;();\n        conjuntoB.add(10);\n        conjuntoB.add(20);\n        conjuntoB.add(5);\n        conjuntoB.add(7); // Elementos del conjunto B: 10, 20, 5 y 7\n\n        conjuntoA.addAll(conjuntoB);\n        imprimirColeccion(conjuntoA); //5 7 9 10 19 20\n\n        conjuntoA.removeAll(conjuntoB);\n        imprimirColeccion(conjuntoA); //9 19\n\n        //recolocamos todo como al principio\n        conjuntoA.add(5);\n        conjuntoA.add(7);\n        conjuntoB.add(10);\n        conjuntoB.add(20);\n        conjuntoB.add(5);\n        conjuntoB.add(7);\n\n        conjuntoA.retainAll(conjuntoB);\n        imprimirColeccion(conjuntoA); //5 7\n\n    }\n}\n</code></pre>"},{"location":"ud07/ud0702/#ordenacion","title":"Ordenaci\u00f3n","text":"<p>Por defecto, los <code>TreeSet</code> ordenan sus elementos de forma ascendente, pero, \u00bfse podr\u00eda cambiar el orden de ordenaci\u00f3n? Los <code>TreeSet</code> tienen un conjunto de operaciones adicionales, adem\u00e1s de las que incluye por el hecho de ser un conjunto, que permite entre otras cosas, cambiar la forma de ordenar los elementos. Esto es especialmente \u00fatil cuando el tipo de objeto que se almacena no es un simple n\u00famero, sino algo m\u00e1s complejo (un art\u00edculo por ejemplo). <code>TreeSet</code> es capaz de ordenar tipos b\u00e1sicos (n\u00fameros, cadenas y fechas) pero otro tipo de objetos no puede ordenarlos con tanta facilidad.</p> <p>Para indicar a un <code>TreeSet</code> c\u00f3mo tiene que ordenar los elementos, debemos decirle cu\u00e1ndo un elemento va antes o despu\u00e9s que otro, y cu\u00e1ndo son iguales. Para ello, utilizamos la interfaz gen\u00e9rica <code>java.util.Comparator</code>, usada en general en algoritmos de ordenaci\u00f3n, como veremos m\u00e1s adelante.</p> <p>Se trata de crear una clase que implemente dicha interfaz, as\u00ed de f\u00e1cil. Dicha interfaz requiere de un \u00fanico m\u00e9todo que debe calcular si un objeto pasado por par\u00e1metro es mayor, menor o igual que otro del mismo tipo. Veamos un ejemplo general de c\u00f3mo implementar un comparador para una hipot\u00e9tica clase <code>Objeto</code>:</p> Java<pre><code>class ComparadorDeObjetos implements Comparator&lt;Objeto&gt; {\n    public int compare(Objeto o1, Objeto o2) { ... }\n}\n</code></pre> <p>La interfaz <code>Comparator</code> obliga a implementar un \u00fanico m\u00e9todo, es el m\u00e9todo <code>compare</code> , el cual tiene dos par\u00e1metros: los dos elementos a comparar. Las reglas son sencillas, a la hora de personalizar dicho m\u00e9todo:</p> <ul> <li>Si el primer objeto (o1) es menor que el segundo (o2), debe retornar un n\u00famero entero negativo.</li> <li>Si el primer objeto (o1) es mayor que el segundo (o2), debe retornar un n\u00famero entero positivo.</li> <li>Si ambos son iguales, debe retornar 0.</li> </ul> <p>A veces, cuando el orden que deben tener los elementos es diferente al orden real (por ejemplo cuando ordenamos los n\u00fameros en orden inverso), la definici\u00f3n de antes puede ser un poco liosa, as\u00ed que es recomendable en tales casos pensar de la siguiente forma:</p> <ul> <li>Si el primer objeto (o1) debe ir antes que el segundo objeto (o2), retornar entero negativo.</li> <li>Si el primer objeto (o1) debe ir despu\u00e9s que el segundo objeto (o2), retornar entero positivo.</li> <li>Si ambos son iguales, debe retornar 0.</li> </ul> <p>Una vez creado el comparador simplemente tenemos que pasarlo como par\u00e1metro en el momento de la creaci\u00f3n al <code>TreeSet</code> , y los datos internamente mantendr\u00e1n dicha ordenaci\u00f3n:</p> Java<pre><code>TreeSet&lt;Objeto&gt; ts = new TreeSet&lt;Objeto&gt;(new ComparadorDeObjetos());\n</code></pre> <p>Hay otra manera de definir esta ordenaci\u00f3n, pero lo estudiaremos m\u00e1s a fondo en el punto 7.4 Comparadores.</p> Revisa este ejemplo 04 <p>Realiza un peque\u00f1o programa que pregunte al usuario 5 n\u00fameros diferentes (almacen\u00e1ndolos en un <code>HashSet</code>), y que despu\u00e9s calcule la suma de los mismos (usando un bucle <code>for\u2010each</code>). SOLUCI\u00d3N Una soluci\u00f3n posible podr\u00eda ser la siguiente. F\u00edjate en la soluci\u00f3n y ver\u00e1s que el uso de conjuntos ha simplificado enormemente el ejercicio, permitiendo al programador o la programadora centrarse en otros aspectos: Java<pre><code>package UD07.P2_HashSet;\n\n\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class EjemploHashSet {\n\n    public static void main(String[] args) {\n        HashSet&lt;Integer&gt; conjunto = new HashSet&lt;Integer&gt;();\n        Scanner teclado = new Scanner(System.in);\n        int numero;\n        do {\n            try {\n                System.out.print(\"Introduce un n\u00famero \" + (conjunto.size() + 1) + \": \");\n                numero = teclado.nextInt();\n                if (!conjunto.add(numero)) {\n                    System.out.println(\"N\u00famero ya en la lista. Introducir otro.\");\n                }\n            } catch (NumberFormatException e) {\n                System.out.println(\"N\u00famero err\u00f3neo.\");\n            }\n        } while (conjunto.size() &lt; 5);\n        // Calcular la suma\n        Integer suma = 0;\n        for (Integer i : conjunto) {\n            suma = suma + i;\n        }\n        System.out.println(\"La suma es: \" + suma);\n    }\n}\n</code></pre></p> Revisa este ejemplo 05 Java<pre><code>package UD07.P2_Comparator;\n\nimport java.io.*;\nimport java.util.*;\n\nclass Estudiante {\n  private int id;\n  private String nombre;\n\n  public Estudiante(int valor, String nombre) {\n    this.id = valor;\n    this.nombre = nombre;\n  }\n\n  public String getNombre() {\n    return this.nombre;\n  }\n\n  public int getId() {\n    return this.id;\n  }\n}\n\n// Comparador mediante atributo entero\nstatic class IdComparator implements Comparator&lt;Estudiante&gt; {\n  public int compare(Estudiante e1, Estudiante e2) {\n    return e1.getId()-e2.getId();\n  }\n}\n// Comparador mediante atributo String \nstatic class NombreComparator implements Comparator&lt;Estudiante&gt; {\n  public int compare(Estudiante e1, Estudiante e2) {\n    return e1.getNombre().compareTo(e2.getNombre());\n  }\n}\n\nclass EjemploComparador {\n\n  public static void main (String[] args){\n    // Crear TreeSet con Comparador con objeto Estudiante\n    TreeSet&lt;Estudiante&gt; setId = new TreeSet&lt;Estudiante&gt;(new IdComparator());\n\n    setId.add(new Estudiante(450,\"Laura\"));\n    setId.add(new Estudiante(341,\"Esther\"));\n    setId.add(new Estudiante(134,\"Daniel\"));\n    setId.add(new Estudiante(590,\"Jorge\"));\n\n    System.out.println(\"Ordenaci\u00f3n por marca:\");\n    for(Estudiante elemento : setId) {\n       System.out.print(elemento.getNombre()+\"\\t\"+elemento.getId());\n       System.out.println();\n    }  \n\n    TreeSet&lt;Estudiante&gt; setNombre= new TreeSet&lt;Estudiante&gt;(new NombreComparator());\n\n    setNombre.add(new Estudiante(450,\"Laura\"));\n    setNombre.add(new Estudiante(341,\"Esther\"));\n    setNombre.add(new Estudiante(134,\"Daniel\"));\n    setNombre.add(new Estudiante(590,\"Jorge\"));\n\n    System.out.println(\"Ordenaci\u00f3n por nombre:\");\n    for(students elemento : setNombre) {\n       System.out.print(elemento.getNombre() +\"\\t\"+ elemento.getId());\n       System.out.println();\n    }\n  }\n}\n</code></pre> Bash<pre><code>Ordenaci\u00f3n por marca:\nDaniel  134\nEsther  341\nLaura   450\nJorge   590\nOrdenaci\u00f3n por nombre:\nDaniel  134\nEsther  341\nJorge   590\nLaura   450\n</code></pre>"},{"location":"ud07/ud0702/#listas","title":"Listas","text":"<p>\u00bfEn qu\u00e9 se diferencia una lista de un conjunto? Las listas son elementos de programaci\u00f3n un poco m\u00e1s avanzados que los conjuntos. Su ventaja es que ampl\u00edan el conjunto de operaciones de las colecciones a\u00f1adiendo operaciones extra. Veamos algunas de ellas:</p> <ul> <li>S\u00ed pueden almacenar duplicados. Si no queremos duplicados, hay que verificar manualmente que el elemento no est\u00e9 en la lista antes de su inserci\u00f3n.</li> <li>Acceso posicional. Podemos acceder a un elemento indicando su posici\u00f3n en la lista.</li> <li>B\u00fasqueda. Es posible buscar elementos en la lista y obtener su posici\u00f3n. En los conjuntos, al ser colecciones sin aportar nada nuevo, solo se pod\u00eda comprobar si un conjunto conten\u00eda o no un elemento, retornando verdadero o falso. Las listas mejoran este aspecto.</li> <li>Extracci\u00f3n de sublistas. Es posible obtener una lista que contenga solo una parte de los elementos de forma muy sencilla.</li> </ul> <p>En Java, para las listas se dispone de una interfaz llamada <code>java.util.List</code>, y dos implementaciones (<code>java.util.LinkedList</code> y <code>java.util.ArrayList</code>), con diferencias significativas entre ellas. Los m\u00e9todos de la interfaz <code>List</code>, que obviamente estar\u00e1n en todas las implementaciones, y que permiten las operaciones anteriores son:</p> <ul> <li><code>E get(int index)</code> : el m\u00e9todo <code>get</code> permite obtener un elemento partiendo de su posici\u00f3n (index).</li> <li><code>E set(int index, E element)</code> : el m\u00e9todo <code>set</code> permite cambiar el elemento almacenado en una posici\u00f3n de la lista (index), por otro (element).</li> <li><code>void add(int index, E element)</code> : se a\u00f1ade otra versi\u00f3n del m\u00e9todo <code>add</code>, en la cual se puede insertar un elemento (element) en la lista en una posici\u00f3n concreta (index), desplazando los existentes.</li> <li><code>E remove(int index)</code> : se a\u00f1ade otra versi\u00f3n del m\u00e9todo <code>remove</code>, esta versi\u00f3n permite eliminar un elemento indicando su posici\u00f3n en la lista.</li> <li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code> : se a\u00f1ade otra versi\u00f3n del m\u00e9todo <code>addAll</code> , que permite insertar una colecci\u00f3n pasada por par\u00e1metro en una posici\u00f3n de la lista, desplazando el resto de elementos.</li> <li><code>int indexOf(Object o)</code> : el m\u00e9todo <code>indexOf</code> permite conocer la posici\u00f3n (\u00edndice) de un elemento, si dicho elemento no est\u00e1 en la lista retornar\u00e1 <code>\u20101</code>.</li> <li><code>int lastIndexOf(Object o)</code> : el m\u00e9todo <code>lastIndexOf</code> nos permite obtener la \u00faltima ocurrencia del objeto en la lista (dado que la lista s\u00ed puede almacenar duplicados).</li> <li><code>List&lt;E&gt; subList(int from, int to)</code> : el m\u00e9todo <code>subList</code> genera una sublista (una vista parcial de la lista) con los elementos comprendidos entre la posici\u00f3n inicial (incluida) y la posici\u00f3n final (no incluida).</li> </ul> <p>Comienzo de lista por 0</p> <p>Ten en cuenta que los elementos de una lista empiezan a numerarse por 0. Es decir, que el primer elemento de la lista es el 0. Ten en cuenta tambi\u00e9n que <code>List</code> es una interfaz gen\u00e9rica, por lo que <code>&lt;E&gt;</code> corresponde con el tipo base usado como par\u00e1metro gen\u00e9rico al crear la lista.</p>"},{"location":"ud07/ud0702/#uso","title":"Uso","text":"<p>Y, \u00bfc\u00f3mo se usan las listas? Pues para usar una lista haremos uso de sus implementaciones <code>LinkedList</code> y <code>ArrayList</code>. Veamos un ejemplo de su uso y despu\u00e9s obtendr\u00e1s respuesta a esta pregunta.</p> <p>Supongo que intuir\u00e1s c\u00f3mo se usan, pero nunca viene mal un ejemplo sencillo, que nos aclare las ideas. El siguiente ejemplo muestra c\u00f3mo usar un <code>LinkedList</code> pero valdr\u00eda tambi\u00e9n para <code>ArrayList</code> (no olvides importar las clases <code>java.util.LinkedList</code> y <code>java.util.ArrayList</code> seg\u00fan sea necesario). En este ejemplo se usan los m\u00e9todos de acceso posicional a la lista:</p> Java<pre><code>LinkedList&lt;Integer&gt; ll = new LinkedList&lt;&gt;(); // declaraci\u00f3n y creaci\u00f3n del LinkedList de enteros.\nll.add(1); // a\u00f1ade un elemento al final de la lista.\nll.add(3); // a\u00f1ade otro elemento al final de la lista.\nll.add(1,2); // a\u00f1ade en la posici\u00f3n 1 el elemento 2.\nll.add(ll.get(1) + ll.get(2)); // suma los valores contenidos en la posici\u00f3n 1 y 2, y lo agrega al final.\nll.remove(0); // elimina el primer elementos de la lista.\n</code></pre> <p>En el ejemplo anterior, se realizan muchas operaciones, \u00bfcu\u00e1l ser\u00e1 el contenido de la lista al final?</p> Java<pre><code>// recorrer la colecci\u00f3n:\nfor (Integer elemento: ll){\n    System.out.print(elemento + \" \");\n}\n// devuelve: 2 3 5\n</code></pre> <p>Veamos otro ejemplo, esta vez con <code>ArrayList</code>, de c\u00f3mo obtener la posici\u00f3n de un elemento en la lista:</p> Java<pre><code>ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;(); // declaraci\u00f3n y creaci\u00f3n del ArrayList de enteros.\nal.add(10); \nal.add(11); // a\u00f1adimos dos elementos a la lista.\nal.set(al.indexOf(11), 12); // sustituimos el 11 por el 12, primero lo buscamos y luego lo reemplazamos.\n</code></pre> <p>En el ejemplo anterior, se emplea tanto el m\u00e9todo <code>indexOf</code> para obtener la posici\u00f3n de un elemento, como el m\u00e9todo <code>set</code> para reemplazar el valor en una posici\u00f3n, una combinaci\u00f3n muy habitual. El ejemplo anterior generar\u00e1 un <code>ArrayList</code> que contendr\u00e1 dos n\u00fameros, el 10 y el 12. </p> <p>Veamos ahora un ejemplo algo m\u00e1s dif\u00edcil:</p> Text Only<pre><code>al.addAll(0, ll.subList(1, ll.size()));\n</code></pre> <p>Cuidado</p> <p><code>subList</code> ==&gt; Returns a view of the portion of this list between the specified <code>fromIndex</code>, inclusive, and <code>toIndex</code>, exclusive (API de Java).</p> <p>Este ejemplo es especial porque usa sublistas. Se usa el m\u00e9todo <code>size</code> para obtener el tama\u00f1o de la lista. Despu\u00e9s el m\u00e9todo <code>subList</code> para extraer una sublista de la lista (que inclu\u00eda en origen los n\u00fameros 2, 3 y 5), desde la posici\u00f3n 1 hasta el final de la lista (lo cual dejar\u00eda fuera al primer elemento). Y por \u00faltimo, se usa el m\u00e9todo <code>addAll</code> para a\u00f1adir todos los elementos de la sublista al <code>ArrayList</code> anterior desde su posici\u00f3n 0. Y quedar\u00eda:</p> Java<pre><code>3, 5, 10 y 12.\n</code></pre> <p>Debes saber que las operaciones aplicadas a una sublista repercuten sobre la lista original. Por ejemplo, si ejecutamos el m\u00e9todo <code>clear</code> sobre una sublista, se borrar\u00e1n todos los elementos de la sublista, pero tambi\u00e9n se borrar\u00e1n dichos elementos de la lista original:</p> Java<pre><code>al.subList(0, 2).clear();\n</code></pre> <p>Lo mismo ocurre al a\u00f1adir un elemento, se a\u00f1ade en la sublista y en la lista original.</p> Revisa este ejemplo 06 Java<pre><code>package UD07.P2_3_Listas;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\n\npublic class Ejemplo06 {\n\n  private static void imprimirColeccion(Collection&lt;?&gt; c) {\n    for (Object i : c) {\n       System.out.print(i.toString() + \" \");\n    }\n    System.out.println(\"\");\n  }\n  public static void main(String[] args) {\n    LinkedList&lt;Integer&gt; t = new LinkedList&lt;&gt;(); //declaraci\u00f3n+creaci\u00f3n LinkedList\n    t.add(1); //a\u00f1ade un elemento al final de la lista\n    t.add(3); //a\u00f1ade otro elemento al final de la lista\n    t.add(1, 2); //a\u00f1ade en la posici\u00f3n 1 el elemento 2\n    t.add(t.get(1) + t.get(2)); //suma contendio de posici\u00f3n 1 y 2, y agrega al final\n    t.remove(0); //elimina el primer elementos de la lista\n    imprimirColeccion(t); //2 3 5 \n\n    ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;(); //declaraci\u00f3n+creaci\u00f3n ArrayList\n    al.add(10);\n    al.add(11); //a\u00f1adimos dos elementos a la lista.\n    al.set(al.indexOf(11), 12); //sustituimos el 11 por el 12, primero lo buscamos y luego lo reemplazamos.\n\n    al.addAll(0, t.subList(1, t.size()));\n    imprimirColeccion(al); //3 5 10 12 \n\n    al.subList(0, 2).clear();\n    imprimirColeccion(al); //10 12 \n  }\n}\n</code></pre>"},{"location":"ud07/ud0702/#linkedlist-y-arraylist","title":"<code>LinkedList</code> y <code>ArrayList</code>","text":"<p>\u00bfY en qu\u00e9 se diferencia un <code>LinkedList</code> de un <code>ArrayList</code> ?</p> <p>Los <code>LinkedList</code> utilizan listas doblemente enlazadas, que son listas enlazadas (como se vio en un apartado anterior), pero que permiten ir hacia atr\u00e1s en la lista de elementos. Los elementos de la lista se encapsulan en los llamados nodos.</p> <p>Los nodos van enlazados unos a otros para no perder el orden y no limitar el tama\u00f1o de almacenamiento. Tener un doble enlace significa que en cada nodo se almacena la informaci\u00f3n de cu\u00e1l es el siguiente nodo y adem\u00e1s, de cu\u00e1l es el nodo anterior. Si un nodo no tiene nodo siguiente o nodo anterior, se almacena null (o nulo) para ambos casos.</p> <p>No es el caso de los <code>ArrayList</code>. Estos se implementan utilizando arrays que se van redimensionando conforme se necesita m\u00e1s espacio o menos. La redimensi\u00f3n es transparente a nosotros, no nos enteramos cu\u00e1ndo se produce, pero eso redunda en una diferencia de rendimiento notable dependiendo del uso. Los ArrayList son m\u00e1s r\u00e1pidos en cuanto a acceso a los elementos, acceder a un elemento seg\u00fan su posici\u00f3n es m\u00e1s r\u00e1pido en un array que en una lista doblemente enlazada (hay que recorrer la lista). En cambio, eliminar un elemento implica muchas m\u00e1s operaciones en un array que en una lista enlazada de cualquier tipo.</p> <p>\u00bfY esto qu\u00e9 quiere decir? Que si se van a realizar muchas operaciones de eliminaci\u00f3n de elementos sobre la lista, conviene usar una lista enlazada (<code>LinkedList</code>), pero si no se van a realizar muchas eliminaciones, sino que solamente se van a insertar y consultar elementos por posici\u00f3n, conviene usar una lista basada en arrays redimensionados (<code>ArrayList</code> ).</p> <p><code>LinkedList</code> tiene otras ventajas que nos puede llevar a su uso. Implementa las interfaces <code>java.util.Queue</code> y <code>java.util.Deque</code>. Dichas interfaces permiten hacer uso de las listas como si fueran una cola de prioridad o una pila, respectivamente.</p> <p>Las colas, tambi\u00e9n conocidas como colas de prioridad, son una lista pero que aportan m\u00e9todos para trabajar de forma diferente. \u00bfT\u00fa sabes lo que es hacer cola para que te atiendan en una ventanilla? Pues igual. Se trata de que el primero que llega es el primero en ser atendido (<code>FIFO</code>, First In First Out en ingl\u00e9s). Simplemente se aportan tres m\u00e9todos nuevos: meter en el final de la lista (<code>add</code> y <code>offer</code>), sacar y eliminar el elemento m\u00e1s antiguo (<code>poll</code>), y examinar el elemento al principio de la lista sin eliminarlo (<code>peek</code>). Dichos m\u00e9todos est\u00e1n disponibles en las listas enlazadas <code>LinkedList</code> :</p> <ul> <li><code>boolean add(E e)</code> y <code>boolean offer(E e)</code> : retornar\u00e1n true si se ha podido insertar el elemento al final de la <code>LinkedList</code>.</li> <li><code>E poll()</code> : retornar\u00e1 el primer elemento de la <code>LinkedList</code> y lo eliminar\u00e1 de la misma. Al insertar al final, los elementos m\u00e1s antiguos siempre est\u00e1n al principio. Retornar\u00e1 null si la lista est\u00e1 vac\u00eda.</li> <li><code>E peek()</code> : retornar\u00e1 el primer elemento de la <code>LinkedList</code> pero no lo eliminar\u00e1, permite examinarlo. Retornar\u00e1 null si la lista est\u00e1 vac\u00eda.</li> </ul> <p>Las pilas, mucho menos usadas, son todo lo contrario a las listas. Una pila es igual que una monta\u00f1a de hojas en blanco, para a\u00f1adir hojas nuevas se ponen encima del resto, y para retirar una se coge la primera que hay encima de todas. En las pilas el \u00faltimo en llegar es el primero en ser atendido (<code>LIFO</code>, Last In First Out en ingl\u00e9s). Para ello se proveen de tres m\u00e9todos: meter al principio de la pila (<code>push</code>), sacar y eliminar del principio de la pila (<code>pop</code>), y examinar el primer elemento de la pila (<code>peek</code>, igual que si usara la lista como una cola). Las pilas se usan menos y haremos menos hincapi\u00e9 en ellas. Simplemente ten en mente que, tanto las colas como las pilas, son una lista enlazada sobre la que se hacen operaciones especiales.</p>"},{"location":"ud07/ud0702/#a-tener-en-cuenta","title":"A tener en cuenta","text":"<p>A la hora de usar las listas, hay que tener en cuenta un par de detalles, \u00bfsabes cu\u00e1les? Es sencillo, pero importante.</p> <p>No es lo mismo usar las colecciones (listas y conjuntos) con objetos inmutables (<code>Strings</code>, <code>Integer</code>, etc.) que con objetos mutables. Los objetos inmutables no pueden ser modificados despu\u00e9s de su creaci\u00f3n, por lo que cuando se incorporan a la lista, a trav\u00e9s de los m\u00e9todos <code>add</code> , se pasan por copia (es decir, se realiza una copia de los mismos). En cambio los objetos mutables (como las clases que t\u00fa puedes crear), no se copian, y eso puede producir efectos no deseados.</p> <p>Imag\u00ednate la siguiente clase, que contiene un n\u00famero:</p> Java<pre><code>class Test {\n    public Integer num;\n    Test (int num) {\n        this.num = new Integer(num); \n    }\n}\n</code></pre> <p>La clase de antes es mutable, por lo que no se pasa por copia a la lista. Ahora imagina el siguiente c\u00f3digo en el que se crea una lista que usa este tipo de objeto, y en el que se insertan dos objetos:</p> Java<pre><code>Test p1 = new Test(11); // se crea un objeto Test donde el entero que contiene vale 11.\nTest p2 = new Test(12); // se crea otro objeto Test donde el entero que contiene vale 12.\nLinkedList&lt;Test&gt; lista = new LinkedList&lt;Test&gt;(); // creamos una lista enlazada para objetos tipo Test.\nlista.add(p1); // a\u00f1adimos el primero objeto test.\nlista.add(p2); // a\u00f1adimos el segundo objeto test.\nfor (Test p:lista){\n    System.out.println(p.num); // mostramos la lista de objetos.\n}\n</code></pre> <p>\u00bfQu\u00e9 mostrar\u00eda por pantalla el c\u00f3digo anterior? Simplemente mostrar\u00eda los n\u00fameros 11 y 12. Ahora bien, \u00bfqu\u00e9 pasa si modificamos el valor de uno de los n\u00fameros de los objetos test? \u00bfQu\u00e9 se mostrar\u00e1 al ejecutar el siguiente c\u00f3digo?</p> Java<pre><code>p1.num = 44;\nfor (Test p:lista){\n    System.out.println(p.num);\n}\n</code></pre> <p>El resultado de ejecutar el c\u00f3digo anterior es que se muestran los n\u00fameros 44 y 12. El n\u00famero ha sido modificado y no hemos tenido que volver a insertar el elemento en la lista para que en la lista se cambie tambi\u00e9n. Esto es porque en la lista no se almacena una copia del objeto Test, sino un apuntador a dicho objeto (solo hay una copia del objeto a la que se hace referencia desde distintos lugares).</p> <p>Cita</p> <p>Controlar la complejidad es la esencia de la programaci\u00f3n.\" Brian Kernighan</p> Revisa este ejemplo 07 <p>Tenemos la clase <code>Producto</code> con:</p> <ul> <li>Dos atributos: nombre (<code>String</code>) y cantidad (<code>int</code>).</li> <li>Un constructor con par\u00e1metros.</li> <li>Un constructor sin par\u00e1metros.</li> <li>M\u00e9todos <code>get</code> y <code>set</code> asociados a los atributos.</li> </ul> <p><code>Producto.java</code> Java<pre><code>package UD07.P2_3_Listas;\n\npublic class Producto {\n\n  //Atributos\n  private String nombre;\n  private int cantidad;\n\n  //M\u00e9todos\n  //Constructor con par\u00e1metros donde asignamos el valor dado a los atributos\n  public Producto(String nombre, int cantidad) {\n    this.nombre = nombre;\n    this.cantidad = cantidad;\n  }\n\n  //Constructor sin par\u00e1metros donde inicializamos los atributos\n  public Producto() {\n    //La palabra reservada null se utiliza para inicializar los objetos,\n    //indicando que el puntero del objeto no apunta a ninguna direcci\u00f3n\n    //de memoria. No hay que olvidar que String es una clase.\n    this.nombre = null;\n    this.cantidad = 0;\n  }\n\n  //Metodo get y set\n  public String getNombre() {\n    return nombre;\n  }\n\n  public void setNombre(String nombre) {\n    this.nombre = nombre;\n  }\n\n  public int getCantidad() {\n    return cantidad;\n  }\n\n  public void setCantidad(int cantidad) {\n    this.cantidad = cantidad;\n  }\n}\n</code></pre> En el programa principal creamos una lista de productos y realizamos operaciones sobre ella:</p> <p><code>Ejemplo06.java</code> Java<pre><code>package UD07.P2_3_Listas;\n\nimport java.util.ArrayList;\n\npublic class Ejemplo07 {\n\n  public static void main(String[] args) {\n\n    //Definimos 5 instancias de la clase Producto\n    Producto p1 = new Producto(\"Pan\", 6);\n    Producto p2 = new Producto(\"Leche\", 2);\n    Producto p3 = new Producto(\"Manzanas\", 5);\n    Producto p4 = new Producto(\"Brocoli\", 2);\n    Producto p5 = new Producto(\"Carne\", 2);\n\n    //Definir un ArrayList\n    ArrayList&lt;Producto&gt; lista = new ArrayList&lt;&gt;();\n\n    //Colocar instancias de producto en ArrayList\n    lista.add(p1);\n    lista.add(p2);\n    lista.add(p3);\n    lista.add(p4);\n\n    //A\u00f1adimos \"Carne\" en la posici\u00f3n 1 de la lista\n    lista.add(1, p5);\n\n    //A\u00f1adimos \"Carne\" en la \u00faltima posici\u00f3n\n    lista.add(p5);\n\n    //Imprimir el contenido del ArrayList\n    System.out.println(\" - Lista con \" + lista.size() + \" elementos\");\n\n    for (Producto p : lista) {\n      System.out.println(p.getNombre() + \" : \" + p.getCantidad());\n    }\n\n    p5.setCantidad(99); //cambiamos la cantidad al producto, cambiar\u00e1 la lista?\n\n    ((Producto)lista.get(1)).setCantidad(66); //\n\n    System.out.println(p5.getCantidad());\n\n    //Imprimir el contenido del ArrayList\n    System.out.println(\" - Lista con \" + lista.size() + \" elementos\");\n\n    for (Producto p : lista) {\n       System.out.println(p.getNombre() + \" : \" + p.getCantidad());\n    }\n\n    //Eliminar todos los valores del ArrayList\n    lista.clear();\n    System.out.println(\" - Lista final con \" + lista.size() + \" elementos\");\n  }\n}\n</code></pre></p>"},{"location":"ud07/ud0702/#mapas-conjuntos-de-pares-clavevalor","title":"Mapas - conjuntos de pares [clave/valor]","text":"<p>\u00bfC\u00f3mo almacenar\u00edas los datos de un diccionario? Tenemos por un lado cada palabra y por otro su significado. Para resolver este problema existen precisamente los arrays asociativos. Un tipo de array asociativo son los mapas o diccionarios, que permiten almacenar pares de valores conocidos como clave y valor. La clave se utiliza para acceder al valor, como una entrada de un diccionario permite acceder a su definici\u00f3n.</p> <p>En Java existe la interfaz <code>java.util.Map</code> que define los m\u00e9todos que deben tener los mapas, y existen tres implementaciones principales de dicha interfaz: <code>java.util.HashMap</code>, <code>java.util.TreeMap</code> y <code>java.util.LinkedHashMap</code>. \u00bfTe suenan? Claro que s\u00ed. Cada una de ellas, respectivamente, tiene caracter\u00edsticas similares a <code>HashSet</code> , <code>TreeSet</code> y <code>LinkedHashSet</code> , tanto en funcionamiento interno como en rendimiento.</p> <p>Los mapas utilizan clases gen\u00e9ricas para dar extensibilidad y flexibilidad, y permiten definir un tipo base para la clave, y otro tipo diferente para el valor. Veamos un ejemplo de c\u00f3mo crear un mapa, que es extensible a los otros dos tipos de mapas:</p> Java<pre><code>HashMap&lt;String,Integer&gt; t = new HashMap&lt;&gt;();\n</code></pre> <p>El mapa anterior permite usar cadenas como llaves y almacenar de forma asociada a cada llave, un n\u00famero entero. Veamos los m\u00e9todos principales de la interfaz <code>Map</code>, disponibles en todas las implementaciones. En los ejemplos, <code>V</code> es el tipo base usado para el valor (<code>Value</code>) y <code>K</code> el tipo base usado para la llave (<code>Key</code>):</p> M\u00e9todo. Descripci\u00f3n. <code>V put(K key, V value);</code> Inserta un par de objetos llave (key) y valor (value) en el mapa. Si la llave ya existe en el mapa, entonces retornar\u00e1 el valor asociado que ten\u00eda antes, si la llave no exist\u00eda, entonces retornar\u00e1 null. <code>V get(Object key);</code> Obtiene el valor asociado a una llave ya almacenada en el mapa. Si no existe la llave, retornar\u00e1 null. <code>V remove(Object key);</code> Elimina la llave y el valor asociado. Retorna el valor asociado a la llave, por si lo queremos utilizar para algo, o null, si la llave no existe. <code>boolean containsKey(Object key);</code> Retornar\u00e1 true si el mapa tiene almacenada la llave pasada por par\u00e1metro, false en cualquier otro caso. <code>boolean containsValue(Object value);</code> Retornar\u00e1 true si el mapa tiene almacenado el valor pasado por par\u00e1metro, false en cualquier otro caso. <code>int size();</code> Retornar\u00e1 el n\u00famero de pares llave y valor almacenado en el mapa. <code>boolean isEmpty();</code> Retornar\u00e1 true si el mapa est\u00e1 vac\u00edo, false en cualquier otro caso. <code>void clear();</code> Vac\u00eda el mapa. Revisa este ejemplo 08 Java<pre><code>package UD07.P2_4_Maps;\n\nimport java.util.HashMap;\n\npublic class Ejemplo08 {\n\n  public static void main(String[] args) {\n     HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();\n     //Insertamos un solo elemento A con valor 1\n     hashMap.put(\"A\", 1);\n\n     //Busqueda por clave\n     if (hashMap.containsKey(\"A\")) {\n       System.out.printf(\"Contiene la clave A. Su valor es: %d\\n\", hashMap.get(\"A\"));\n     }\n\n     //Busqueda por valor\n     if (hashMap.containsValue(0)) {\n       System.out.println(\"Contiene el valor 0\");\n     }\n\n     //Eliminar el elemento con clave A\n     hashMap.remove(\"A\");\n\n     //Ahora a\u00f1adimos varios elementos para imprimirlos\n     hashMap.put(\"A\", 1);\n     hashMap.put(\"E\", 12);\n     hashMap.put(\"I\", 15);\n     hashMap.put(\"O\", 0);\n     hashMap.put(\"U\", 0);\n     //Recorremos el mapa y lo imprimimos\n     for (HashMap.Entry&lt;String, Integer&gt; elemento : hashMap.entrySet()) {\n       System.out.printf(\"Clave: %s. Valor: %d\\n\", elemento.getKey(), elemento.getValue());\n     }\n  }\n}\n</code></pre>"},{"location":"ud07/ud0703/","title":"7.3 Iteradores","text":"<p>\u00bfQu\u00e9 son los iteradores realmente? Son un mecanismo que nos permite recorrer todos los elementos de una colecci\u00f3n de forma sencilla, de forma secuencial, y de forma segura. </p> <p>Mapas</p> <p>Los mapas, como no derivan de la interfaz <code>Collection</code> realmente, no tienen iteradores, pero como veremos, existe un truco interesante.</p> <p>Los iteradores permiten recorrer las colecciones de dos formas: bucles <code>for\u2010each</code> (existentes en Java a partir de la versi\u00f3n 1.5) y a trav\u00e9s de un bucle normal creando un iterador. Como los bucles <code>for-each</code> ya los hemos visto antes (y ha quedado patente su simplicidad), nos vamos a centrar en el otro m\u00e9todo, especialmente \u00fatil en versiones antiguas de Java. Ahora la pregunta es, \u00bfc\u00f3mo se crea un iterador? Pues invocando el m\u00e9todo \"<code>iterator()</code>\" de cualquier colecci\u00f3n.</p> <p>Veamos un ejemplo (en el ejemplo <code>c</code> es una colecci\u00f3n cualquiera):</p> Java<pre><code>Iterator&lt;Integer&gt; it = c.iterator();\n</code></pre> <p>F\u00edjate que se ha especificado un par\u00e1metro para el tipo de dato gen\u00e9rico en el iterador (poniendo <code>&lt;Integer&gt;</code> despu\u00e9s de <code>Iterator</code>). Esto es porque los iteradores son tambi\u00e9n clases gen\u00e9ricas, y es necesario especificar el tipo base que contendr\u00e1 el iterador. Si no se especifica el tipo base del iterador, igualmente nos permitir\u00eda recorrer la colecci\u00f3n, pero retornar\u00e1 objetos tipo Object (clase de la que derivan todas las clases), con lo que nos veremos obligados a forzar la conversi\u00f3n de tipo.</p> <p>Para recorrer y gestionar la colecci\u00f3n, el iterador ofrece tres m\u00e9todos b\u00e1sicos:</p> <ul> <li><code>boolean hasNext()</code> : retornar\u00e1 true si le quedan m\u00e1s elementos a la colecci\u00f3n por visitar, false en caso contrario.</li> <li><code>E next()</code> : retornar\u00e1 el siguiente elemento de la colecci\u00f3n, si no existe siguiente elemento, lanzar\u00e1 una excepci\u00f3n ( <code>NoSuchElementException</code> para ser exactos), con lo que conviene chequear primero si el siguiente elemento existe.</li> <li><code>remove()</code> : elimina de la colecci\u00f3n el \u00faltimo elemento retornado en la \u00faltima invocaci\u00f3n de <code>next</code> (no es necesario pas\u00e1rselo por par\u00e1metro). Cuidado, si <code>next</code> no ha sido invocado todav\u00eda, saltar\u00e1 una inc\u00f3moda excepci\u00f3n.</li> </ul> <p>\u00bfC\u00f3mo recorrer\u00edamos una colecci\u00f3n con estos m\u00e9todos? Pues de una forma muy sencilla, un simple bucle mientras (<code>while</code>) con la condici\u00f3n <code>hasNext()</code> nos permite hacerlo:</p> Java<pre><code>while (it.hasNext()) { // mientras haya siguiente elemento, seguiremos en el bucle\n   Integer n = it.next(); // escogemos el siguiente elemento\n\n   if (n%2 == 0)\n      it.remove(); // si es par, eliminamos el elemento de la lista\n}\n</code></pre> <p>\u00bfQu\u00e9 elementos contendr\u00eda la lista despu\u00e9s de ejecutar el bucle? Efectivamente, solo n\u00fameros impares.</p> <p>Acceso posicional en las listas con m\u00e9todos <code>get</code> y <code>set</code></p> <p>Las listas permiten acceso posicional a trav\u00e9s de los m\u00e9todos <code>get</code> y <code>set</code>, y acceso secuencial a trav\u00e9s de iteradores, \u00bfcu\u00e1l es para t\u00ed la forma m\u00e1s c\u00f3moda de recorrer todos los elementos, un acceso posicional a trav\u00e9s un bucle <code>for (i=0; i&lt;lista.size(); i++)</code> o un acceso secuencial usando un bucle <code>while (iterador.hasNext())</code>?</p> <p>\u00bfQu\u00e9 inconvenientes tiene usar los iteradores sin especificar el tipo de objeto? En el siguiente ejemplo, se genera una lista con los n\u00fameros del 0 al 10. De la lista, se eliminan aquellos que son pares y solo se dejan los impares. En el primer ejemplo se especifica el tipo de objeto del iterador, en el segundo ejemplo no; observa el uso de la conversi\u00f3n de tipos en la l\u00ednea 7.</p> Ejemplo indicando el tipo de objeto del iterador Java<pre><code>ArrayList&lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();\nfor (int i=0; i&lt;10; i++){\n    lista.add(i); \n}\n//lista: [0,1,2,3,4,5,6,7,8,9]\nIterator&lt;Integer&gt; it = lista.iterator();\nwhile (it.hasNext()) {\n    Integer n = it.next();\n    if (n%2 == 0){\n        it.remove();\n    }\n}\n//lista: [1,3,5,7,9]\n</code></pre> Ejemplo no indicando el tipo de objeto del iterador Java<pre><code>ArrayList &lt;Integer&gt; lista = new ArrayList&lt;Integer&gt;();\nfor (int i=0; i&lt;10; i++){\n    lista.add(i); \n}\nIterator it = lista.iterator();\nwhile (it.hasNext()) {\n    Integer n = (Integer)it.next();\n    if (n%2 == 0){\n        it.remove();\n    }\n}\n</code></pre> <p>Un iterador es seguro porque esta pensado para no sobrepasar los l\u00edmites de la colecci\u00f3n, ocultando operaciones m\u00e1s complicadas que pueden repercutir en errores de software. Pero realmente se convierte en inseguro cuando es necesario hacer la operaci\u00f3n de conversi\u00f3n de tipos. Si la colecci\u00f3n no contiene los objetos esperados, al intentar hacer la conversi\u00f3n, saltar\u00e1 una inc\u00f3moda excepci\u00f3n.</p> <p>Usar gen\u00e9ricos aporta grandes ventajas, pero us\u00e1ndolos adecuadamente. </p> <p>Para recorrer los mapas con iteradores, hay que hacer un peque\u00f1o truco. Usamos el m\u00e9todo <code>entrySet</code> que ofrecen los mapas para generar un conjunto con las entradas (pares de llave\u2010valor), o bien, el m\u00e9todo <code>keySet</code> para generar un conjunto con las llaves existentes en el mapa. </p> Veamos como ser\u00eda para el segundo caso, el m\u00e1s sencillo\": Text Only<pre><code>```java\n</code></pre> <p>HashMap mapa = new HashMap&lt;&gt;(); for (int i=0; i&lt;10; i++){     mapa.put(i, i); // Insertamos datos de prueba en el mapa. } for (Integer elemento : mapa.keySet()){     // Recorremos el conjunto generado por keySet, contendr\u00e1 las llaves.     Integer valor = mapa.get(elemento); //Para cada llave, accedemos a su valor si es necesario.     System.out.println(valor); } ``` <p>Lo \u00fanico que tienes que tener en cuenta es que el conjunto generado por <code>keySet</code> no tendr\u00e1 obviamente el m\u00e9todo <code>add</code> para a\u00f1adir elementos al mismo, dado que eso tendr\u00e1s que hacerlo a trav\u00e9s del mapa.</p> <p>Eliminar elementos de una colecci\u00f3n con iteradores</p> <p>Si usas iteradores, y piensas eliminar elementos de la colecci\u00f3n (e incluso de un mapa), debes usar el m\u00e9todo <code>remove</code> del iterador y no el de la colecci\u00f3n. Si eliminas los elementos utilizando el m\u00e9todo <code>remove</code> de la colecci\u00f3n, mientras est\u00e1s dentro de un bucle de iteraci\u00f3n, o dentro de un bucle <code>for\u2010each</code>, los fallos que pueden producirse en tu programa son impredecibles. \u00bfLogras adivinar porqu\u00e9 se pueden producir dichos problemas? Los problemas son debidos a que el m\u00e9todo <code>remove</code> del iterador elimina el elemento de dos sitios: de la colecci\u00f3n y del iterador en s\u00ed (que mantiene interiormente informaci\u00f3n del orden de los elementos). Si usas el m\u00e9todo <code>remove</code> de la colecci\u00f3n, la informaci\u00f3n solo se elimina de un lugar, de la colecci\u00f3n.</p> Revisa este ejemplo 9 <p>Ejemplo que crea, rellena y recorre un <code>ArrayList</code> de dos formas diferentes. Cabe destacar que, por defecto, el m\u00e9todo <code>System.out.println()</code> invoca al m\u00e9todo <code>toString()</code> de los elementos que se le pasen como argumento, por lo que realmente no es necesario utilizar <code>toString()</code> dentro de <code>println()</code>. Java<pre><code>package UD07.P3.Iterators;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Ejemplo09 {\n\n  public static void main(String[] args) {\n    //creamos la lista\n    ArrayList l = new ArrayList();\n\n    //A\u00f1adimos elementos al final de la lista\n    l.add(\"uno\");\n    l.add(\"dos\");\n    l.add(\"tres\");\n    l.add(\"cuatro\");\n\n    //A\u00f1adimos el elemento en la posici\u00f3n 2\n    l.add(2, \"dos2\");\n\n    System.out.println(l.size()); //devuelve 5\n    System.out.println(l.get(0)); //devuelve uno\n    System.out.println(l.get(1)); //devuelve dos\n    System.out.println(l.get(2)); //devuelve dos2\n    System.out.println(l.get(3)); //devuelve tres\n    System.out.println(l.get(4)); //devuelve cuatro\n\n    //Recorremos la lista con un for y mostramos su contenido\n    for (int i = 0; i &lt; l.size(); i++) {\n       System.out.print(l.get(i));\n    }//imprime: unodosdos2trescuatro\n\n    System.out.println();\n\n    //Recorremos la lista con un Iterador\n    //creamos el iterador\n    Iterator it = l.iterator();\n\n    //mientras haya elementos\n    while (it.hasNext()) {\n       System.out.print(it.next()); //obtengo el siguiente elemento\n    }//imprime; unodosdos2trescuatro\n\n    System.out.println();\n\n    for (Object elemento : l) {\n       System.out.print(elemento);\n    }//imprime; unodosdos2trescuatro\n  }\n}\n</code></pre></p> Revisa este ejemplo 10 <p>Este ejemplo es la versi\u00f3n del ejemplo 07 con iteradores. Java<pre><code>package UD07.P3.Iterators;\n\nimport UD07.P2_3_Listas.Producto;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Ejemplo10 {\n\n  public static void main(String[] args) {\n\n    //Definimos 5 instancias de la clase Producto\n    Producto p1 = new Producto(\"Pan\", 6);\n    Producto p2 = new Producto(\"Leche\", 2);\n    Producto p3 = new Producto(\"Manzanas\", 5);\n    Producto p4 = new Producto(\"Brocoli\", 2);\n    Producto p5 = new Producto(\"Carne\", 2);\n\n    //Definir un ArrayList\n    ArrayList&lt;Producto&gt; lista = new ArrayList&lt;&gt;();\n\n    //Colocar instancias de producto en ArrayList\n    lista.add(p1);\n    lista.add(p2);\n    lista.add(p3);\n    lista.add(p4);\n\n    //A\u00f1adimos \"Carne\" en la posici\u00f3n 1 de la lista\n    lista.add(1, p5);\n\n    //A\u00f1adimos \"Carne\" en la \u00faltima posici\u00f3n\n    lista.add(p5);\n\n    //Imprimir el contenido del ArrayList\n    System.out.println(\" - Lista con \" + lista.size() + \" elementos\");\n\n    //Definir Iterator  para extraer/imprimir valores\n    //si queremos utilizar un for con el iterador no hace falta poner el incremento\n    for (Iterator&lt;Producto&gt; it = lista.iterator(); it.hasNext();) {\n       Producto p = it.next();\n       System.out.println(p.getNombre() + \" : \" + p.getCantidad());\n    }\n\n    p5.setCantidad(99); //cambiamos la cantidad al producto, cambiar\u00e1 la lista?\n\n    ((Producto)lista.get(1)).setCantidad(66); //\n\n    System.out.println(p5.getCantidad());\n\n    //Imprimir el contenido del ArrayList\n    System.out.println(\" - Lista con \" + lista.size() + \" elementos\");\n\n    //Definir Iterator  para extraer/imprimir valores\n    //si queremos utilizar un for con el iterador no hace falta poner el incremento\n    for (Iterator&lt;Producto&gt; it = lista.iterator(); it.hasNext();) {\n       Producto p = it.next();\n       System.out.println(p.getNombre() + \" : \" + p.getCantidad());\n    }\n\n    //Eliminar todos los valores del ArrayList\n    lista.clear();\n    System.out.println(\" - Lista final con \" + lista.size() + \" elementos\");\n  }\n}\n</code></pre></p>"},{"location":"ud07/ud0704/","title":"7.4 Comparadores","text":"<p>En Java hay dos mecanismos para cambiar la forma en la que los elementos se ordenan. Imagina que tienes los art\u00edculos almacenados en una lista llamada <code>articulos</code>, y que cada art\u00edculo se almacena en la siguiente clase <code>Articulo</code> (f\u00edjate que el c\u00f3digo de art\u00edculo es una cadena y no un n\u00famero):</p> Java<pre><code>class Articulo {\n    public String codArticulo; // c\u00f3digo de art\u00edculo\n    public String descripcion; // descripci\u00f3n del art\u00edculo\n    public int cantidad; // cantidad a proveer del art\u00edculo\n}\n</code></pre> <p>A) La primera forma de ordenar consiste en crear una clase que implemente la interfaz <code>java.util.Comparator</code>, y por ende, el m\u00e9todo <code>compare</code> definido en dicha interfaz. Esto se explic\u00f3 en el apartado de conjuntos, al explicar el <code>TreeSet</code>, as\u00ed que no vamos a profundizar en ello. No obstante, el comparador para ese caso podr\u00eda ser as\u00ed:</p> Java<pre><code>class comparadorArticulos implements Comparator&lt;Articulo&gt;{\n    @Override\n    public int compare( Articulo o1, Articulo o2) {\n        return o1.codArticulo.compareTo(o2.codArticulo);\n    }\n}\n</code></pre> <p>Una vez creada esta clase, ordenar los elementos es muy sencillo; simplemente se pasa como segundo par\u00e1metro del m\u00e9todo <code>sort</code> una instancia del comparador creado:</p> Java<pre><code>Collections.sort(articulos, new comparadorArticulos());\n</code></pre> <p>B) La segunda forma es quiz\u00e1s m\u00e1s sencilla cuando se trata de objetos cuya ordenaci\u00f3n no existe de forma natural, pero requiere modificar la clase <code>Articulo</code>. Consiste en hacer que los objetos que se insertan en la lista o array implementen la interfaz <code>java.util.Comparable</code>. Todos los objetos que implementan la interfaz <code>Comparable</code> son \"ordenables\" y se puede invocar el m\u00e9todo <code>sort</code> sin indicar un comparador para ordenarlos. La interfaz <code>comparable</code> solo requiere implementar el m\u00e9todo <code>compareTo</code>:</p> Java<pre><code>class Articulo implements Comparable&lt;Articulo&gt;{\n    public String codArticulo;\n    public String descripcion;\n    public int cantidad;\n\n    @Override\n    public int compareTo(Articulo o) {\n        return codArticulo.compareTo(o.codArticulo);\n    }\n}\n</code></pre> <p>Del ejemplo anterior se pueden denotar dos cosas importantes:</p> <p>1) que la interfaz <code>Comparable</code> es gen\u00e9rica y que para que funcione sin problemas es conveniente indicar el tipo base sobre el que se permite la comparaci\u00f3n (en este caso, el objeto <code>Articulo</code> debe compararse consigo mismo), y 2) que el m\u00e9todo <code>compareTo</code> solo admite un par\u00e1metro, dado que comparar\u00e1 el objeto con el que se pasa por par\u00e1metro.</p> <p>El funcionamiento del m\u00e9todo <code>compareTo</code> es el mismo que el m\u00e9todo <code>compare</code> de la interfaz <code>Comparator</code>: si la clase que se pasa por par\u00e1metro es igual al objeto, se tendr\u00eda que retornar 0; si es menor o anterior, se deber\u00eda retornar un n\u00famero menor que cero; si es mayor o posterior, se deber\u00eda retornar un n\u00famero mayor que 0.</p> <p>Ordenar ahora la lista de art\u00edculos es sencillo, f\u00edjate que f\u00e1cil: <code>Collections.sort(articulos);</code></p> Consulta el c\u00f3digo de ejemplo 11 <p>Ejercicio resuelto <code>Comparator1</code>. Imag\u00ednate que Objeto es una clase como la siguiente: Java<pre><code>package UD07.P4.Comparator1;\n\npublic class Objeto {\n\n  public int a;\n  public int b;\n\n  public Objeto(int a, int b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  @Override\n  public String toString() {\n    return \"Objeto{\" + \"a=\" + a + \", b=\" + b + '}';\n  }\n\n}\n</code></pre> Imagina que ahora, al a\u00f1adirlos en un <code>TreeSet</code>, estos se tienen que ordenar de forma que la suma de sus atributos (a y b) sea descendente, \u00bfcomo ser\u00eda el comparador?</p> <p>Respuesta</p> <p>Una de las posibles soluciones a este problema podr\u00eda ser la siguiente: Java<pre><code>package UD07.P4.Comparator1;\n\nimport java.util.Comparator;\n\nclass ComparadorDeObjetos implements Comparator&lt;Objeto&gt; {\n\n  @Override\n  public int compare(Objeto o1, Objeto o2) {\n     int sumao1 = o1.a + o1.b;\n     int sumao2 = o2.a + o2.b;\n     return suma02 - suma01; // invertir la resta para descendientes\n  }\n}\n</code></pre></p> <p>Y para usarlo tendriamos: Java<pre><code>package UD07.P4.Comparator1;\n\nimport java.util.TreeSet;\n\npublic class Ejemplo11 {\n\n  public static void main(String[] args) {\n     TreeSet&lt;Objeto&gt; ts = new TreeSet&lt;Objeto&gt;(new ComparadorDeObjetos());\n\n     Objeto o1= new Objeto(0, 1);\n     ts.add(o1);\n\n     ts.add(new Objeto(1, 2));\n     ts.add(new Objeto(4, 5));\n     ts.add(new Objeto(2, 3));\n\n     for (Objeto elemento : ts) {\n        System.out.println(elemento);\n     }\n  }\n}\n</code></pre> Observa que la salida muestra los elementos correctamente ordenados, aunque se insertaron de manera \"aleatoria\": Bash<pre><code>Objeto{a=4, b=5}\nObjeto{a=2, b=3}\nObjeto{a=1, b=2}\nObjeto{a=0, b=1}\n</code></pre></p> Consulta el c\u00f3digo de ejemplo 12 <p>Ejercicio resuelto <code>Comparator2</code>. Ahora convertiremos la clase <code>Objeto</code> para que directamente implemente la interfaz <code>Comparable</code>: Java<pre><code>package UD07.P4.Comparator2;\n\npublic class Objeto implements Comparable&lt;Objeto&gt; {\n\n  public int a;\n  public int b;\n\n  public Objeto(int a, int b) {\n     this.a = a;\n     this.b = b;\n  }\n\n  @Override\n  public String toString() {\n     return \"Objeto{\" + \"a=\" + a + \", b=\" + b + '}';\n  }\n\n  @Override\n  public int compareTo(Objeto t) {\n     int sumao1 = this.a + this.b;\n     int sumao2 = t.a + t.b;\n     return suma02 - suma01; // invertir la resta para descendientes\n  }\n\n}\n</code></pre></p> <p>Y lo usamos directamente en la clase <code>Principal</code>: Java<pre><code>package UD07.P4.Comparator2;\n\nimport java.util.TreeSet;\n\npublic class Ejemplo12 {\n\n  public static void main(String[] args) {\n     TreeSet&lt;Objeto&gt; ts = new TreeSet&lt;Objeto&gt;();\n\n     ts.add(new Objeto(0, 1));\n     ts.add(new Objeto(1, 2));\n     ts.add(new Objeto(4, 5));\n     ts.add(new Objeto(2, 3));\n\n     for (Objeto elemento : ts) {\n        System.out.println(elemento);\n     }\n  }\n}\n</code></pre></p> <p>F\u00edjate que la salida sigue mostrando los elementos correctamente ordenados, aunque se insertaron de manera \"aleatoria\": Bash<pre><code>Objeto{a=4, b=5}\nObjeto{a=2, b=3}\nObjeto{a=1, b=2}\nObjeto{a=0, b=1}\n</code></pre></p>"},{"location":"ud07/ud0705/","title":"7.5 Extras","text":"<p>\u00bfQu\u00e9 m\u00e1s ofrece las clases <code>java.util.Collections</code> y <code>java.util.Arrays</code> de Java? Una vez vista la ordenaci\u00f3n, quiz\u00e1s lo m\u00e1s complicado, veamos algunas operaciones adicionales. En los ejemplos, la variable <code>array</code> es un array y la variable <code>lista</code> es una lista de cualquier tipo de elemento:</p> Operaci\u00f3n Descripci\u00f3n Ejemplos Desordenar una lista. Desordena una lista, este m\u00e9todo no est\u00e1 disponible para arrays. <code>Collections.shuffle (lista);</code> Rellenar una lista o array. Rellena una lista o array copiando el mismo valor en todos los elementos del array o lista. \u00datil para reiniciar una lista o array. <code>Collections.fill (lista,elemento);</code><code>Arrays.fill (array,elemento);</code> B\u00fasqueda binaria. Permite realizar b\u00fasquedas r\u00e1pidas en un una lista o array ordenados. Es necesario que la lista o array est\u00e9n ordenados, sino lo est\u00e1n, la b\u00fasqueda no tendr\u00e1 \u00e9xito. <code>Collections.binarySearch(lista,elemento);</code><code>Arrays.binarySearch(array, elemento);</code> Convertir un array a lista. Permite r\u00e1pidamente convertir un array a una lista de elementos, extremadamente \u00fatil. No se especifica el tipo de lista retornado (no es <code>ArrayList</code> ni <code>LinkedList</code>), solo se especifica que retorna una lista que implementa la interfaz <code>java.util.List</code>. <code>List lista = Arrays.asList(array);</code> Si el tipo de dato almacenado en el array es conocido (<code>Integer</code> por ejemplo), es conveniente especificar el tipo de objeto de la lista: <code>List&lt;Integer&gt; lista = Arrays.asList(array);</code> Convertir una lista a array. Permite convertir una lista en array. Esto se puede realizar en todas las colecciones, y no es un m\u00e9todo de la clase <code>Collections</code>, sino propio de la interfaz <code>Collection</code>. Es conveniente que sepas de su existencia. Para este ejemplo, supondremos que los elementos de la lista son n\u00fameros, dado que hay que crear un array del tipo almacenado en la lista, y del tama\u00f1o de la lista: <code>Integer[] array=new Integer[lista.size()];</code><code>lista.toArray(array);</code> Dar la vuelta. Da la vuelta a una lista, poni\u00e9ndola en orden inverso al que tiene. <code>Collections.reverse(lista);</code> Imprimir un array o lista lista.toString()Arrays.toString(array) <p>Otra operaci\u00f3n que ya se ha visto en alg\u00fan ejemplo anterior es la de dividir una cadena en partes. Cuando una cadena est\u00e1 formada internamente por trozos de texto claramente delimitados por un separador (una coma, un punto y coma o cualquier otro), es posible dividir la cadena y obtener cada uno de los trozos de texto por separado en un array de cadenas.</p> <p>Para poder realizar esta operaci\u00f3n, usaremos el m\u00e9todo <code>split</code> de la clase <code>String</code> . El delimitador o separador es una expresi\u00f3n regular, \u00fanico argumento del m\u00e9todo <code>split</code>, y puede ser obviamente todo lo complejo que sea necesario:</p> Java<pre><code>String texto=\"Z,B,A,X,M,O,P,U\";\nString[] partes=texto.split(\",\");\n//partes={\"Z\", \"B\", \"A\", \"X\", \"M\", \"O\", \"P\", \"U\"}\nArrays.sort(partes);//lo ordenamos\n//partes={\"A\", \"B\", \"M\", \"O\", \"P\", \"U\", \"X\", \"Z\"}\n</code></pre> <p>En el ejemplo anterior la cadena texto contiene una serie de letras separadas por comas. La cadena se ha dividido con el m\u00e9todo <code>split</code> , y se ha guardado cada car\u00e1cter por separado en un <code>array</code>. Despu\u00e9s se ha ordenado el <code>array</code>. \u00a1Incre\u00edble lo que se puede llegar a hacer con solo tres l\u00edneas de c\u00f3digo!</p>"},{"location":"ud07/ud0706/","title":"7.6 Programaci\u00f3n funcional","text":""},{"location":"ud07/ud0706/#que-es-la-programacion-funcional","title":"\u00bfQu\u00e9 es la programaci\u00f3n funcional?","text":"<p>Paradigma de programaci\u00f3n declarativo, no imperativo, se dice c\u00f3mo es el problema a resolver, en lugar de los pasos a seguir para resolverlo.</p> <p>La mayor\u00eda de lenguajes populares actuales no se pueden considerar funcionales, ni puros ni h\u00edbridos, pero han adaptado su sintaxis y funcionalidad para ofrecer parte de este paradigma.</p>"},{"location":"ud07/ud0706/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<p>Transparencia referencial: la salida de una funci\u00f3n debe depender s\u00f3lo de sus argumentos. Si la llamamos varias veces con los mismos argumentos, debe producir siempre el mismo resultado.</p> <p>Inmutabilidad de los datos: los datos deben ser inmutables para evitar posibles efectos colaterales.</p> <p>Composici\u00f3n de funciones: las funciones se tratan como datos, de modo que la salida de una funci\u00f3n se puede tomar como entrada para la siguiente.</p> <p>Funciones de primer orden: funciones que permiten tener otras funciones como par\u00e1metros, a modo de callbacks.</p> <p>.</p> <p>Si llamamos repetidamente a esta funci\u00f3n con el par\u00e1metro 1, cada vez producir\u00e1 un resultado distinto (3, 4, 5...). Java<pre><code>class Prueba{\n    static int valorExterno = 1;\n\n    static int unaFuncion(int parametro){\n        valorExterno++;\n        return valorExterno + parametro;\n    }\n}\n</code></pre></p> <p>Imperativo  vs  Declarativo</p> <p>Queremos obtener una sublista con los mayores de edad de entre una lista de personas:</p> <p>Imperativo: Java<pre><code>List&lt;Persona&gt; adultos = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; personas.size(); i++){\n    if (personas.get(i).getEdad() &gt;= 18)\n        adultos.add(personas.get(i));\n}\n</code></pre></p> <p>Declarativo: List adultos = personas.stream().filter(p -&gt; p.getEdad() &gt;= 18).collect(Collectors.toList()); Se puede observar que el ejemplo declarativo es m\u00e1s compacto, y menos propenso a errores. (Adem\u00e1s sirve de ejemplo a la composici\u00f3n de funciones)."},{"location":"ud07/ud0706/#funciones-lambda","title":"Funciones Lambda","text":"<p>Son expresiones breves que simplifican la implementaci\u00f3n de elementos m\u00e1s costosos en cuanto a l\u00edneas de c\u00f3digo. Tambi\u00e9n se las conoce como funciones an\u00f3nimas, no necesitan una clase/nombre. En java se pueden aplicar a la implementaci\u00f3n de interfaces, aunque tienen m\u00e1s utilidades pr\u00e1cticas. En algunos lenguajes se les suele denominar \"funciones flecha\" (arrow functions) ya que en su sintaxis es caracter\u00edstica una flecha, que separa la cabecera de la funci\u00f3n de su cuerpo.</p> <p>Comparaciones</p> <p>API del m\u00e9todo List.sort de Java: Java<pre><code>default void sort(Comparator&lt;? super E&gt; c)\n</code></pre> La interfaz <code>Comparator</code> pide implementar un m\u00e9todo <code>compare</code>, que recibe dos datos del tipo a tratar (T), y devuelve un entero indicando si el primero es menor, mayor, o son iguales (de forma similar al m\u00e9todo <code>compareTo</code> de la interfaz <code>Comparable</code>.) Java<pre><code>int compare (T o1, T o2)\n</code></pre> Imaginemos una clase <code>Persona</code>: Java<pre><code>class Persona{\n    private String nombre;\n    private int edad;\n    ...\n}\n</code></pre> Y un ArrayList <code>personas</code> formada por objetos de tipo <code>Persona</code>: Java<pre><code>...\nArrayList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\npersonas.add(new Persona(\"Nacho\", 52));\npersonas.add(new Persona(\"David\", 47));\npersonas.add(new Persona(\"Pepe\", 42));\npersonas.add(new Persona(\"Maria\", 22));\npersonas.add(new Persona(\"Marta\", 4));\n...\n</code></pre> Ahora queremos ordenar el <code>ArrayList</code> de <code>personas</code> de mayor a menor edad usando... Implementaci\u00f3n \"tradicional\" java: <code>Comparator</code> o<code>Comparable</code> Java<pre><code>...\nclass ComparadorPersona implements Comparator &lt;Persona&gt;{\n    @Override\n    public int compare(Persona p1, Persona p2){\n        return p2.getEdad() - p1.getEdad();\n    }\n}\n...\n</code></pre> Java<pre><code>...\npersonas.sort(new ComparadorPersona());\nfor (int i = 0; i &lt; personas.size(); i++){\n System.out.println(personas.get(i));\n}\n...     \n</code></pre> Sin embargo, implementado con funciones Lambda seria... Java<pre><code>...\npersonas.sort((p1, p2) -&gt; p2.getEdad() - p1.getEdad());\nfor (int i = 0; i &lt; personas.size(); i++){\n    System.out.println(personas.get(i));\n}\n...\n</code></pre></p>"},{"location":"ud07/ud0706/#estructura-de-una-expresion-lambda","title":"Estructura de una expresi\u00f3n lambda","text":"<p><code>(lista de parametros) -&gt; {cuerpo de la funci\u00f3n a implementar}</code></p> <ul> <li>El operador lambda (<code>-&gt;</code>) separa la declaraci\u00f3n de par\u00e1metros de la declaraci\u00f3n del cuerpo de la funci\u00f3n.</li> <li>Los par\u00e1metros del lado izquierdo de la flecha se pueden omitir si s\u00f3lo hay un par\u00e1metro. Cuando no se tienen par\u00e1metros, o cuando se tienen dos o m\u00e1s, es necesario utilizar par\u00e9ntesis.</li> <li>El cuerpo de la funci\u00f3n son las llaves de la parte derecha se pueden omitir si la \u00fanica operaci\u00f3n a realizar es un simple <code>return</code>.</li> </ul> <p>Funciones Lambda</p> <p>Las utilizaremos a fondo con las <code>Interfaces</code>. Java<pre><code>z -&gt; z + 2 //un s\u00f3lo par\u00e1metro\n</code></pre> Java<pre><code>() -&gt; System.out.println(\"Mensaje 1\") //sin par\u00e1metros\n</code></pre> Java<pre><code>(int longitud, int altura) -&gt; { return altura * longitud; } //dos par\u00e1metros\n</code></pre> Java<pre><code>(String x) -&gt; {\n String retorno = x;\n retorno = retorno.concat(\"***\");\n return retorno;\n} //un bloque de c\u00f3digo m\u00e1s elaborado\n</code></pre></p>"},{"location":"ud07/ud0706/#gestion-de-colecciones-con-streams-en-java","title":"Gesti\u00f3n de colecciones con streams en Java","text":"<p>Desde Java 8, permiten procesar grandes cantidades de datos aprovechando la paralelizaci\u00f3n que permita el sistema. No modifican la colecci\u00f3n original, sino que crean copias. </p> <p>Dos tipos de operaciones </p> <ul> <li>Intermedias: devuelven otro stream resultado de procesar el anterior de alg\u00fan modo (filtrado, mapeo), para ir enlazando operaciones </li> <li>Finales: cierran el stream devolviendo alg\u00fan resultado (colecci\u00f3n resultante, c\u00e1lculo num\u00e9rico, etc). </li> </ul> <p>Muchas de estas operaciones tienen como par\u00e1metro una interfaz, que puede implementarse muy brevemente empleando expresiones lambda</p>"},{"location":"ud07/ud0706/#filtrado","title":"Filtrado","text":"<p>El m\u00e9todo <code>filter</code> es una operaci\u00f3n intermedia que permite quedarnos con los datos de una colecci\u00f3n que cumplan el criterio indicado como par\u00e1metro. <code>filter</code> recibe como par\u00e1metro una interfaz <code>Predicate</code>, cuyo m\u00e9todo test recibe como par\u00e1metro un objeto y devuelve si ese objeto cumple o no una determinada condici\u00f3n.</p> Java<pre><code>[...]\nStream&lt;Persona&gt; adultos = personas.stream().filter(p -&gt; p.getEdad() &gt;= 18);\n//La funci\u00f3n lambda se podr\u00eda traducir como: \"Aquellas personas 'p' de la colecci\u00f3n cuya edad sea mayor o igual que 18 a\u00f1os\"\n</code></pre>"},{"location":"ud07/ud0706/#mapeo","title":"Mapeo","text":"<p>El m\u00e9todo <code>map</code> es una operaci\u00f3n intermedia que permite transformar la colecci\u00f3n original para quedarnos con cierta parte de la informaci\u00f3n o crear otros datos. <code>map</code> recibe como par\u00e1metro una interfaz <code>Function</code>, cuyo m\u00e9todo <code>apply</code> recibe como par\u00e1metro un objeto y devuelve otro objeto diferente, normalmente derivado del par\u00e1metro.</p> Java<pre><code>[...]\nStream&lt;Integer&gt; edades = personas.stream().map(p -&gt; p.getEdad());\n//La funci\u00f3n lambda hace que se a\u00f1adan al stream de enteros las edades de las personas 'p' de la colecci\u00f3n personas.\n</code></pre>"},{"location":"ud07/ud0706/#combinar","title":"Combinar","text":"<p>Se pueden combinar operaciones intermedias (composici\u00f3n de funciones) para producir resultados m\u00e1s complejos. Por ejemplo, las edades de las personas adultas.</p> Java<pre><code>[...]\nStream&lt;Integer&gt; edadesAdultos = personas.stream()\n    .filter(p -&gt; p.getEdad() &gt;= 18).map (p -&gt; p.getEdad());\n//A\u00f1adiriamos al stream solamente las edades, de aquellas personas que son mayores de edad.\n</code></pre>"},{"location":"ud07/ud0706/#ordenar","title":"Ordenar","text":"<p>El m\u00e9todo <code>sorted</code> es una operaci\u00f3n intermedia que permite ordenar los elementos de una colecci\u00f3n seg\u00fan cierto criterio. Por ejemplo, ordenar las personas adultas por edad. <code>sorted</code> recibe como par\u00e1metro una interfaz <code>Comparator</code>, que ya conocemos.</p> Java<pre><code>Stream&lt;Persona&gt; personasOrdenadas = personas.stream()\n    .filter(p -&gt; p.getEdad() &gt;= 18)\n    .sorted((p1, p2) -&gt; p1.getEdad() - p2.getEdad());\n//Para cada pareja de personas p1 y p2, ord\u00e9nalas en funcion de la resta de la edad de p1 menos la edad de p2 (lo que haciamos en el compareTo)\n</code></pre>"},{"location":"ud07/ud0706/#coleccion","title":"Colecci\u00f3n","text":"<p>El m\u00e9todo <code>collect</code> es una operaci\u00f3n final que permite obtener alg\u00fan tipo de colecci\u00f3n a partir de los datos procesados por las operaciones intermedias. Por ejemplo, una lista con las edades de las personas adultas.</p> Java<pre><code>List&lt;Integer&gt; edadesAdultos = personas.stream().filter(p -&gt; p.getEdad() &gt;= 18).map(p -&gt; p.getEdad()).collect(Collectors.toList());\n//similar a ejemplos anteriores, pero esta vez obtenemos una lista de enteros, en lugar de un stream.\n</code></pre> <p>El m\u00e9todo <code>collect</code> tambi\u00e9n permite obtener una cadena de texto que una los elementos resultantes, a trav\u00e9s de un separador com\u00fan. En la funci\u00f3n <code>Collectors.joining</code> se puede indicar tambi\u00e9n un prefijo y un sufijo para el texto.</p> Java<pre><code>String nombresAdultos = personas.stream().filter(p -&gt; p.getEdad() &gt;= 18)\n    .map(p -&gt; p.getNombre())\n    .collect(Collectors.joining(\", \",\"Adultos: \",\"\"));\n//genera una lista de nombres de personas, con un prefijo, separado y sufijo.\n</code></pre>"},{"location":"ud07/ud0706/#foreach","title":"<code>forEach</code>","text":"<p>El m\u00e9todo <code>forEach</code> permite recorrer cada elemento del stream resultante, y hacer lo que se necesite con \u00e9l. Por ejemplo, sacar por pantalla en l\u00edneas separadas los nombres de las personas adultas.</p> Java<pre><code>personas.stream().filter(p -&gt; p.getEdad() &gt;= 18)\n    .map(p -&gt; p.getNombre()).forEach(p -&gt; System.out.println(p));\n</code></pre>"},{"location":"ud07/ud0706/#media-aritmetica","title":"Media aritm\u00e9tica","text":"<p>El m\u00e9todo average permite, junto con la operaci\u00f3n intermedia mapToInt, obtener una media de un stream que haya producido una colecci\u00f3n resultante num\u00e9rica. Por ejemplo, la media de edades de las personas adultas.</p> Java<pre><code>double mediaAdultos = personas.stream().filter(p -&gt; p.getEdad() &gt;= 18)\n    .mapToInt(p -&gt; p.getEdad()).average().getAsDouble();\n</code></pre>"},{"location":"ud07/ud07ac/","title":"Actividades","text":""},{"location":"ud07/ud07ac/#ejercicios","title":"Ejercicios","text":""},{"location":"ud07/ud07ac/#ejercicio-01","title":"Ejercicio 01","text":"<p>Paquete: <code>_01_varios</code></p> <p>Dise\u00f1ar la clase Varios con los siguientes m\u00e9todos est\u00e1ticos que se har\u00e1n apoy\u00e1ndose en alguna clase de las vistas al estudiar las colecciones de Java:</p> <ul> <li><code>int[] quitarDuplicados (int[] v)</code>, que dado un array de enteros devuelva otro array con los mismos valores que el original pero sin duplicados.</li> <li><code>int[] union1(int[] v1, int[] v2)</code>, que dados dos arrays v1 y v2 devuelva otro array con los elementos que est\u00e1n en v1 o que est\u00e1n en v2, sin que ning\u00fan elemento se repita.</li> <li><code>int[] uni\u00f3n2(int v1[], int v2[])</code>, que dados dos arrays v1 y v2 devuelva otro array con los elementos que est\u00e1n en v1 o que est\u00e1n en v2. En este caso, si hay elementos duplicados se mantendr\u00e1n.</li> <li><code>int[] interseccion(int v1[], int v2[])</code>, que dados dos arrays v1 y v2 devuelva otro array con los elementos que aparecen en los dos arrays. Cada elemento com\u00fan aparecer\u00e1 una sola vez en el resultado.</li> <li><code>int[] diferencia1 (int v1[], int v2[])</code>, que dados dos arrays v1 y v2 devuelva otro array con los elementos que de v1 que no est\u00e1n en v2. En caso de haber elementos duplicados en v1 estos se mantendr\u00e1n en el resultado.</li> <li><code>int[] diferencia2 (int v1[], int v2[])</code>, que dados dos arrays v1 y v2 devuelva otro array con los elementos de v1 que no est\u00e1n en v2. El array resultante no tendr\u00e1 elementos duplicados.</li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-02","title":"Ejercicio 02","text":"<p>Paquete: <code>_02_biblioteca</code></p> <p>Se quiere hacer una aplicaci\u00f3n en la que los usuarios van a hacer b\u00fasquedas de libros para saber si se  encuentran en los fondos de la biblioteca. El funcionamiento b\u00e1sico ser\u00eda algo as\u00ed: Al iniciarse la aplicaci\u00f3n todo el cat\u00e1logo de libros se cargar\u00eda en memoria y a partir de ese momento los usuarios pueden realizar b\u00fasquedas por t\u00edtulo, que interesa que sean lo m\u00e1s r\u00e1pidas posibles. Nunca se insertan nuevos libros durante la ejecuci\u00f3n de la aplicaci\u00f3n.</p> <p>a) Dise\u00f1a la clase <code>Libro</code> con los m\u00e9todos que consideres oportunos y los siguientes atributos:</p> <ul> <li>Titulo (String): es el dato que identifica al libro.</li> <li>Autor (String): autor del libro.</li> <li>Estanter\u00eda (String): estanter\u00eda de la biblioteca en la que se encuentra el libro.</li> </ul> <p>b) Dise\u00f1a la clase <code>CatalogoLibros</code> como una colecci\u00f3n de libros. Utiliza el tipo de colecci\u00f3n que crees que m\u00e1s se ajusta a los requisitos de la aplicaci\u00f3n justificando la elecci\u00f3n. Implementa los siguients m\u00e9todos:</p> <ul> <li> <p><code>public CatalogoLibros(Libro v[])</code>: constructor. Para simplificar, inicializa el cat\u00e1logo y lo rellena con los libros del array v, en lugar de obtenerlos de un fichero.</p> </li> <li> <p><code>public String buscar(Libro l)</code>: dado un libro, lo busca en el Cat\u00e1logo y devuelve la estanter\u00eda en la que se encuentra el libro o null si el libro no est\u00e1 en el Cat\u00e1logo.</p> </li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-03","title":"Ejercicio 03","text":"<p>Paquete: <code>_03_academia</code></p> <p>Se quiere dise\u00f1ar una clase <code>Academia</code>. De una Academia se conoce  su nombre, direcci\u00f3n y las Aulas que tiene (necesitas tambi\u00e9n generar la clase <code>Aula</code>).  </p> <p>Definir la clase Academia utilizando una Collection para almacenar las aulas. El tipo de colecci\u00f3n a utilizar se decidir\u00e1 teniendo en cuenta que \u00e9stas se quieren mantener ordenadas seg\u00fan el criterio del m\u00e9todo compareTo de la clase Aula. Implementar los atributos, el constructor, y los siguientes m\u00e9todos:</p> <ul> <li> <p><code>void ampliar (Aula a)</code>, que a\u00f1ade un aula a la academia.</p> </li> <li> <p><code>void quitar (Aula a)</code>, que elimina un aula de la academia.</p> </li> <li> <p><code>int getNumAulas()</code>, que devuelva el n\u00famero de aulas que tiene.  </p> </li> <li> <p><code>toString()</code>, que muestre todas las aulas de la academia.</p> </li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-04","title":"Ejercicio 04","text":"<p>Paquete: <code>_04_listaEspera</code></p> <p>Deseamos mantener la lista de espera de pacientes de un hospital. Se quiere poder:</p> <ul> <li> <p>A\u00f1adir pacientes a la lista.</p> </li> <li> <p>Mantener los pacientes por orden de inserci\u00f3n en la lista de espera.</p> </li> <li> <p>Obtener el paciente m\u00e1s prioritario (al que hay que atender de la lista de espera), es decir, el que m\u00e1s tiempo lleva esperando, el que antes entr\u00f3 en el hospital.</p> </li> </ul> <p>a) Dise\u00f1a la clase <code>Paciente</code> con los atributos nombre y gravedad. La gravedad es un valor aleatorio (entre 1: m\u00e1s grave y 5: menos grave) generado al crear el paciente.</p> <p>b) Realiza la implementaci\u00f3n de la clase <code>ListaEspera</code> con la estructura de datos elegida. A\u00f1ade los m\u00e9todos para insertar un paciente, obtener de la lista de espera al m\u00e1s prioritario y eliminar de la lista de espera al m\u00e1s prioritario. </p> <p>\u200b   \u00bfQu\u00e9 tipo de estructura de datos utilizar\u00edamos para almacenar los pacientes, un <code>List</code>, <code>Set</code> o <code>Map</code>? Justifica la respuesta mediante un comentario arriba de la implementaci\u00f3n de esta clase (puntos a favor de la que elijes y en contra de las que descartas).</p> <p>c) Implementa una <code>ListaEsperaPorGravedad</code>, en la que se atienda primero a los pacientes m\u00e1s graves, independientemente de si llegaron antes o despu\u00e9s.  </p>"},{"location":"ud07/ud07ac/#ejercicio-05","title":"Ejercicio 05","text":"<p>Paquete: <code>_05_diccionarioIngEsp</code></p> <p>a) Dise\u00f1ar la clase <code>DiccionarioBiling\u00fce</code> para almacenar pares formados por:</p> <ul> <li> <p>Palabra en castellano.</p> </li> <li> <p>Colecci\u00f3n de traducciones a ingles.</p> </li> </ul> <p>b) La clase dispondr\u00e1 de los siguientes m\u00e9todos:</p> <ul> <li> <p>constructor: crea el diccionario vacio.</p> </li> <li> <p><code>anyadirTraduccion(String cast, String ingl)</code>: a\u00f1ade la pareja (cast, ingl) al diccionario de forma que:</p> </li> <li> <p>Si la palabra cast no estaba en el diccionario la a\u00f1ade, junto con su traducci\u00f3n.</p> </li> <li>Si la palabra cast estaba ya en el diccionario pero no aparec\u00eda como traducci\u00f3n la palabra ing, a\u00f1ade ing a su colecci\u00f3n de traducciones.</li> <li>Si la palabra cast estaba y la traducci\u00f3n ing tambi\u00e9n, no se realizar\u00e1n cambios.</li> <li> <p>El m\u00e9todo devuelve true si se han realizado cambios en el diccionario y false en caso contrario.</p> </li> <li> <p><code>quitarTraduccion(String cast, String ingl)</code>: quita la traducci\u00f3n ingl a la palabra cast. Si la palabra en castellano se queda sin traducciones, se elimina del dicicionario. Si se han producido cambios se devuelve true y en caso contrario false.</p> </li> <li> <p><code>traduccionesDe(String cast)</code>: devuelve una colecci\u00f3n con las traducciones de la palabra indicada o null si la palabra no est\u00e1 en el diccionario.</p> </li> <li> <p><code>toString()</code>: devuelve un String con las palabras del diccionario y sus traducciones.  </p> </li> <li> <p>clase  <code>RepeticionPalabras</code> : escribe un programa que abra el fichero de texto que indique el usuario y muestre cu\u00e1ntas veces se repite cada palabra que contiene. Ayudarse de un Map. \u00bfSe podr\u00eda resolver con un Set? \u00bfY con un List?</p> </li> <li> <p>clase <code>TraductorSimple</code> : escribir un programa que solicite al usuario una frase y la muestre traducida a ingl\u00e9s, palabra a palabra. Para ello, se dispone de un fichero palabras.txt que contiene parejas (palabra en espa\u00f1ol, palabra en ingl\u00e9s) separadas por un tabulador. Cada pareja se encuentra en una l\u00ednea del fichero. El proceso ser\u00e1 el siguiente:</p> </li> <li> <p>Leer el fichero y cargar sus datos en una estructura de datos adecuada. Tener en cuenta que nos interesar\u00e1 buscar una palabra en castellano y obtener su correspondencia en ingl\u00e9s.</p> </li> <li>Solicitar al usuario una frase. Traducir, usando la estructura de datos anterior, cada palabra de la frase y formar con ellas la frase traducida.</li> <li>Mostrar la frase traducida al usuario.</li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-06","title":"Ejercicio 06","text":"<p>Paquete: <code>_06_listaAdmitidos</code></p> <p>Una serie de personas han solicitado realizar un curso de ingl\u00e9s. De las que han sido admitidas se quiere almacenar su nif, su nombre y su nivel en un <code>HashSet</code>. En el <code>HashSet</code> se almacenar\u00e1n objetos de la clase <code>Inscripci\u00f3n</code>.</p> <ul> <li> <p>Implementa la clase <code>Incripci\u00f3n</code> para representar el nif, nombre y nivel de un solicitante. Adem\u00e1s de los atributos implementa aquellos m\u00e9todos que consideres necesarios.</p> </li> <li> <p>Escribe un programa (clase <code>ComprobarAdmision</code>) que:  </p> </li> <li> <p>Defina un <code>HashSet</code> de Inscripciones, llamado <code>admitidas</code>.</p> </li> <li> <p>A\u00f1ada varias inscripciones (inv\u00e9ntate los datos).</p> </li> <li> <p>Permita al usuario introducir un dni para comprobar si la persona indicada ha sido admitida. Indicarle si aparece o no en la lista y, en caso afirmativo, mostrar el nombre y el nivel en que ha sido admitido.</p> </li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-07","title":"Ejercicio 07","text":"<p>Paquete: <code>_07_palabrasOrdenadas</code></p> <p>Escribe un programa que, dado un fichero de texto cuya ubicaci\u00f3n indica el usuario, muestre sus palabras ordenadas ascendentemente y, despu\u00e9s, descendentemente. Cada palabra se mostrar\u00e1 una sola vez, aunque en el texto aparezca varias. </p>"},{"location":"ud07/ud07ac/#ejercicio-08","title":"Ejercicio 08","text":"<p>Paquete: <code>_08_equipoDeFutbol</code></p> <p>Crear una clase Futbolista con los siguientes atributos y m\u00e9todos:</p> <ul> <li> <p>Atributos:</p> </li> <li> <p>Nombre: nombre del futbolista</p> </li> <li> <p>Edad: edad del futbolista</p> </li> <li> <p>Posici\u00f3n: Posici\u00f3n que ocupa en el campo el futbolista. Ser\u00e1 un tipo       enumerado. Podr\u00e1 ser cualquiera de las siguientes: Portero, Defensa, Centrocampista, Delantero. Cada posici\u00f3n tendr\u00e1 asociada un salario m\u00e1ximo y       un salario m\u00ednimo).</p> <ul> <li>Portero, entre 2000 y 3000 euros.</li> <li>Defensa, entre 2500 y 3500 euros.</li> <li>Centrocampista, entre 3500 y 4000 euros.</li> <li>Delantero, entre 4000 y 5000 euros.</li> </ul> </li> <li> <p>M\u00e9todos:</p> </li> <li> <p>getters y setters.</p> </li> <li><code>toString()</code>: imprimir\u00e1 la informaci\u00f3n asociada al Futbolista.</li> </ul> <p>b) Adem\u00e1s Futbolista implementar\u00e1 la interfaz Deportista. Esta interfaz poseer\u00e1 los siguientes m\u00e9todos:</p> <ul> <li><code>getAnyosProfesional</code> : retorna el n\u00famero de a\u00f1os que un deportista ha estado compitiendo en nivel profesional.</li> <li><code>getListadoEquipos</code> : devuelve un listado con el nombre de todos los equipos en los que ha estado el deportista.</li> <li><code>getTotalTrofeos</code> : obtiene el total de trofeos conseguidos por el deportista.</li> </ul> <p>c) Tambi\u00e9n se debe crear una clase Equipo que tenga como atributos:</p> <ul> <li>Nombre: nombre del equipo</li> <li>Listado de Futbolistas: Listado de futbolistas del equipo</li> <li>Y se deber\u00e1 controlar el n\u00famero m\u00e1ximo de futbolistas por posici\u00f3n. Que ser\u00e1n los que a continuaci\u00f3n se definen:</li> <li>Portero: 2 como m\u00e1ximo.</li> <li>Defensa: 5 como m\u00e1ximo.</li> <li>Centrocampista: 5 como m\u00e1ximo.</li> <li>Delantero: 4 como m\u00e1ximo.</li> </ul> <p>\u200b   Adem\u00e1s, constar\u00e1 de los siguientes m\u00e9todos:</p> <ul> <li> <p><code>agregarFutbolista</code> : a\u00f1adir\u00e1 un futbolista al equipo siempre que la posici\u00f3n de este no est\u00e9 completa. En caso contrario lanzar\u00e1 una excepci\u00f3n de tipo <code>RegistroFutbolistaException</code>.</p> </li> <li> <p><code>listarFormaci\u00f3nDelEquipo</code> : listar\u00e1 todos los miembros del equipo ordenados por    posici\u00f3n. Se mostrar\u00e1n en el siguiente orden:</p> </li> <li> <p>Porteros, Defensas, Centrocampistas, Delanteros.</p> </li> </ul> <p>La gesti\u00f3n se har\u00e1 en dos pasos:</p> <ul> <li>Primero generaremos el listado ordenado, para ello utilizar\u00e9is el m\u00e9todo sort asociado al ArrayList, y deber\u00e9is sobreescribir el m\u00e9todo compare.</li> <li>Luego recorreremos este con un iterator y mostraremos la informaci\u00f3n de cada elemento.</li> </ul> <p>d) Respecto a la clase Aplicaci\u00f3n <code>TestEquipo</code>, simplemente crear un equipo y a\u00f1adir futbolistas de diferente tipo, generar una soluci\u00f3n d\u00f3nde se pruebe todo lo implementado. Es decir, el hecho de superar el n\u00famero m\u00e1ximo de futbolistas en cada posici\u00f3n en cada equipo y tambi\u00e9n que se vea el funcionamiento del m\u00e9todo que ordena.</p>"},{"location":"ud07/ud07ac/#ejercicio-09","title":"Ejercicio 09","text":"<p>Paquete: <code>_09_sistemaAnalisisTextos</code></p> <p>Crear un sistema de an\u00e1lisis de texto que permita procesar y analizar cadenas de texto utilizando conceptos avanzaeos de colecciones en JAVA.</p> <p>a) Crea una clase de  nombre <code>AnalizadoDeTexto</code> que contenga los siguientes atributos y m\u00e9todos:</p> <ul> <li>atributos:</li> <li>texto (String)</li> <li>palabras (HashMap) <li>m\u00e9todos:</li> <li>constructor: que reciba el texto a analizar e inicialice el atributo <code>texto</code>.</li> <li><code>contarPalabras()</code>: m\u00e9todo que procese el texto, cuente la frecuencia de cada palabra y almacene los resultado en el atributo <code>palabras</code>. Ignora las diferencias entre may\u00fasculas y min\u00fasculas.</li> <li><code>palabrasMasFrecuentes(int n)</code>: m\u00e9todo que devuelva una lista de las <code>n</code> palabras m\u00e1s frecuentes en ele texto, junto con su frecuencia.</li> <li><code>palabrasMenosFrecuentes(int n)</code>: m\u00e9todo que devuelva una lista de las <code>n</code> palabras menos frecuentes en ele texto, junto con su frecuencia.</li> <li><code>palabrasPorLongitud()</code>: m\u00e9todo que devuelva un mapa (HashMap) en el que las claves sean las longitudes de las palabras y los valores sean listas (ArrayList) de palabras que tengan esa longitud. Ordena las listas de palabras alfab\u00e9ticamente.</li> <p>b) Realiza pruebas en un main <code>TestAnalizadorDeTexto</code>:</p> <ul> <li>Crea una instancia de un objeto de la clase <code>AnalizadoDeTexto</code> con un texto de prueba.</li> <li>Ejecuta el m\u00e9todo <code>contarPalabras()</code> para procesar el texto.</li> <li>Muestra las palabras m\u00e1s y menos frecuentes utilizando los m\u00e9todos <code>palabrasMasFrecuentes(int n)</code> y <code>palabrasMenosFrecuentes(int n)</code>.</li> <li>Muestra las palabras agrupadas por su longitud utilizando el m\u00e9todo <code>palabrasPorLongitud()</code>.</li> </ul>"},{"location":"ud07/ud07ac/#ejercicios-genericidad","title":"Ejercicios Genericidad","text":""},{"location":"ud07/ud07ac/#ejercicio-10","title":"Ejercicio 10","text":"<p>Paquete: <code>_10_genericos.genericos</code></p> <p>Crear una clase <code>Generico</code> que incorpore los m\u00e9todos gen\u00e9ricos que se indican a continuaci\u00f3n. Los m\u00e9todos creados ser\u00e1n public static. En el proyecto se crear\u00e1 adem\u00e1s la clase o clases necesarias para probar los m\u00e9todos desarrollados.</p> <ul> <li><code>Object minimo (Object o1, Object o2)</code>, que devuelva el m\u00ednimo de dos objetos cualesquiera (que se suponen del mismo tipo). Una vez desarrollado, prueba el m\u00e9todo para obtener el m\u00ednimo de dos objetos Integer. Pru\u00e9balo tambi\u00e9n para obtener el m\u00ednimo entre un Objeto Integer y un objeto String. En \u00e9ste \u00faltimo caso, el programa \u00bfda error de ejecuci\u00f3n? Si es as\u00ed, explica por qu\u00e9.</li> <li><code>Object maximo (Object o1, Object o2)</code>, que devuelva el maximo de dos objetos cualesquiera (que se suponen del mismo tipo).</li> <li><code>Object minimo (Object v[])</code>, que devuelva el m\u00ednimo de un array de objetos cualesquiera (que se suponen del mismo tipo). Al respecto de \u00e9ste \u00faltimo comentario, \u00bfSe puede poner en un array de Object objetos de distinto tipo, como por ejemplo Strings, Integer, ...? En caso afirmativo, \u00bffuncionar\u00eda el m\u00e9todo desarrollado con un array construido as\u00ed?</li> <li><code>Object maximo (Object v[])</code>, que devuelva el maximo de un array de objetos cualesquiera (que se suponen del mismo tipo).</li> <li><code>int numVeces(Object v[], Object x)</code> que devuelva el el numero de apariciones del objeto x en el array v.</li> <li><code>int numVecesOrdenado(Object v[], Object x)</code> que devuelva el el numero de apariciones del objeto x en el array v ordenado ascendentemente.</li> <li><code>int mayores(Object v[], Object x)</code> que, dado un array de Object v y un Object x devuelva el n\u00famero de elementos de v que son mayores que x.</li> <li><code>int mayoresOrdenado(Object v[], Object x)</code> que, dado un array de Object v ordenado ascendentemente y un Object x devuelva el n\u00famero de elementos de v que son mayores que x.</li> <li><code>int menores(Object v[], Object x)</code> que, dado un array de Object v y un Object x devuelva el n\u00famero de elementos de v que son menores que x.</li> <li><code>int menoresOrdenado(Object v[], Object x)</code> que, dado un array de Object v ordenado ascendentemente y un Object x devuelva el n\u00famero de elementos de v que son menores que x.</li> <li><code>boolean estaEn(Object v[], Object x)</code> que devuelva true si el Objeto x est\u00e1 en el array v.</li> <li><code>boolean estaEnOrdenado(Object v[], Object x)</code> que devuelva true si el Objeto x est\u00e1 en el array v, ordenado ascendentemente.</li> <li><code>int posici\u00f3nDe(Object v[], Object x)</code>, que devuelva la posici\u00f3n que ocupa x dentro del array v, o -1 si x no est\u00e1 en v.</li> <li><code>int posicionDeOrdenado(Object v[], Object x)</code>, que devuelva la posici\u00f3n que ocupa x dentro del array v ordenado ascendentemente, o -1 si x no est\u00e1 en v.</li> <li><code>boolean estaOrdenado(Object v[])</code>, que devuelva true si el array est\u00e1 ordenado ascendentemente.</li> </ul>"},{"location":"ud07/ud07ac/#ejercicio-11","title":"Ejercicio 11","text":"<p>Paquete: <code>_10_genericos.nevera</code></p> <p>Se quiere crear una aplicaci\u00f3n que controla una nevera inteligente de \u00faltima generaci\u00f3n. Los alimentos que contiene la nevera se van a representar como objetos de la clase <code>Alimento</code> y la clase <code>NeveraInteligente</code>, tiene un array de Alimentos entre sus atributos privados.</p> <p>Se pide implementar la clase Alimento teniendo en cuenta que uno de los m\u00e9todos de NeveraInteligente necesitar\u00e1 ordenar por calor\u00edas los Alimentos que contiene la nevera utilizando un m\u00e9todo de Ordenaci\u00f3n gen\u00e9rico. El dise\u00f1o de la clase Alimento ha de incluir, por tanto, determinados elementos que lo permitan. La clase Alimento tendr\u00e1 \u00fanicamente dos atributos (privados): nombre y calorias.</p>"},{"location":"ud07/ud07ac/#ejercicio-12","title":"Ejercicio 12","text":"<p>Paquete: <code>_10_genericos.academia</code></p> <p>Se quiere dise\u00f1ar una clase <code>Academia</code>. De una Academia se conoce su nombre, direcci\u00f3n y las Aulas que tiene (Aula es una clase implementada en un ejercicio de herencia que ya hicimos). </p> <ol> <li>Definir la clase <code>Academia</code> utilizando una colecci\u00f3n (que permita ordenaci\u00f3n) para almacenar las aulas.: Implementar los atributos, el constructor, y los siguientes m\u00e9todos:</li> <li><code>void ampliar (Aula a)</code>, que a\u00f1ade un aula a la academia.</li> <li><code>void quitar (Aula a)</code>, que elimina un aula de la academia.</li> <li><code>int getNumAulas()</code>, que devuelva el n\u00famero de aulas que tiene. </li> <li>m\u00e9todo <code>toString()</code></li> <li>Realiza en la clase <code>Aula</code> los cambios necesarios para que se pueda ordenar las aulas de la Academia usando un m\u00e9todo gen\u00e9rico de ordenaci\u00f3n. El orden ser\u00eda creciente por capacidad del aula., y a igual capacidad primero las aulas de mayor superficie</li> <li>A\u00f1ade a la clase <code>Academia</code> un m\u00e9todo <code>ordenar</code> que ordene las aulas con el criterio especificado. Para realizar la ordenaci\u00f3n se llamar\u00e1 a un m\u00e9todo de ordenaci\u00f3n.</li> </ol>"},{"location":"ud07/ud07ac/#ejercicio-13","title":"Ejercicio 13","text":"<p>Paquete: <code>_10_genericos.conjuntos</code></p> <ol> <li> <p>Dise\u00f1ar un interface <code>Conjunto</code> para modelizar conjuntos de elementos. Dise\u00f1ar (solo la cabecera) de los siguientes m\u00e9todos de la clase conjunto (prestar atenci\u00f3n a si los m\u00e9todos deben ser static o no):</p> </li> <li> <p><code>A\u00f1adir</code>, que a\u00f1ade un elemento al conjunto, provocando la excepci\u00f3n <code>ElementoDuplicado</code> si el elemento ya estaba en el conjunto.</p> </li> <li><code>Quitar</code>, que elimina el elemento indicado al conjunto. Provoca <code>ElementoNoEncontrado</code> si el elemento indicado no estaba en el conjunto.</li> <li> <p><code>Intersecci\u00f3n</code>\u00b8 que dados dos conjuntos que recibe como par\u00e1metro devuelve un tercer conjunto que es la intersecci\u00f3n de los dos dados.</p> </li> <li> <p><code>Pertenece</code>\u00b8 que dado un elemento devuelve si este pertenece o no al conjunto.</p> </li> <li> <p>Dise\u00f1ar una clase <code>ConjuntoArray</code> que implemente el interface <code>Conjunto</code>. Esta clase implementar\u00e1 los m\u00e9todos del interface <code>Conjunto</code>. Para ello utilizar\u00e1 un array <code>Object elementos[]</code> y un <code>int numElementos</code>, de manera que los elementos del conjunto se mantendr\u00e1n almacenados en el array. Adem\u00e1s de los m\u00e9todos del interface habr\u00e1 que crear un constructor para la clase y tambi\u00e9n vendr\u00e1 bien tener un m\u00e9todo <code>toString</code> para poder probarla.</p> </li> </ol> <p>Opci\u00f3n:</p> <p>Tambi\u00e9n lo puedes implementar con una Colecci\u00f3n de las vistas en el tema anterior.</p>"},{"location":"ud07/ud07ac/#actividades","title":"Actividades","text":""},{"location":"ud07/ud07ac/#actividad-01","title":"Actividad 01","text":"<p>Realizar las siguientes actividades relacionadas con <code>ArrayList</code>.</p> <ul> <li>Crear un <code>ArrayList</code> de enteros llamado misNumeros.</li> <li>A\u00f1adir los valores 1, 6, 3, 2, 0, 4, 5.</li> <li>Mostrar los datos del <code>ArrayList</code>.</li> <li>Mostrar el valor de la posici\u00f3n 5.</li> <li>A\u00f1adir el valor 8 en la posici\u00f3n 4.</li> <li>Cambiar el valor de la posici\u00f3n 1 por 9.</li> <li>Eliminar el valor 5. (<code>misNumeros.remove(new Integer(5))</code> )</li> <li>Eliminar el valor de la posici\u00f3n 3.</li> <li>Recorrer el array con un bucle for.</li> <li>Recorrer el array con un bucle <code>Iterator</code>.</li> <li>Comprobar si existe el elemento 0.</li> <li>Comprobar si existe el elemento 7.</li> <li>Clonar el <code>ArrayList</code> <code>misNumeros</code> en otro llamado <code>copiaArrayList</code>.</li> <li>A\u00f1adir el elemento 9.</li> <li>Mostrar la posici\u00f3n de la primera ocurrencia del elemento 9.</li> <li>Mostrar la posici\u00f3n de la \u00faltima ocurrencia del elemento 9.</li> <li>Borrar todos los elementos del <code>ArrayList</code> <code>copiaArrayList</code>.</li> <li>Comprobar si el <code>ArrayList</code> <code>copiaArrayList</code> est\u00e1 vacio.</li> <li>Convertir el <code>ArrayList</code> <code>misNumeros</code> en un <code>Array</code> y recorrerlo con un bucle mejorado.</li> </ul>"},{"location":"ud07/ud07ac/#actividad-02","title":"Actividad 02","text":"<p>Un cine precisa una aplicaci\u00f3n para controlar las personas de la cola para los estrenos de pel\u00edculas. Debemos crear una lista con la edad de las personas de la cola y tendremos que calcular la entrada seg\u00fan la edad de la persona (m\u00ednimo 5 a\u00f1os). Para la edad de la persona se generan aleatoriamente n\u00fameros entre 5 y 60 a\u00f1os. Al final, deberemos mostrar la cantidad total recaudada. El n\u00famero de personas de la cola se elige al azar entre 0 y 50.</p> <p>La lista de precios se basa en la siguiente tabla.</p> EDAD PRECIO Entre 5 y 10 a\u00f1os 5 \u20ac Entre 11 y 17 a\u00f1os 7.5 \u20ac Mayor de 18 a\u00f1os 9.5 \u20ac <p>Como comprobaci\u00f3n imprime el n\u00famero de personas, el precio total y la lista de edades. Por ejemplo:</p> Bash<pre><code>Hay un total de 6 personas en la cola.\nEl precio total es de 57,00 euros\n[18, 36, 50, 35, 28, 55]\n</code></pre>"},{"location":"ud07/ud07ac/#actividad-03","title":"Actividad 03","text":"<p>Un supermercado nos pide que hagamos una aplicaci\u00f3n que almacene los productos comprados. La aplicaci\u00f3n debe almacenar Productos (clase) y cada producto al crearse contiene una cantidad, un precio. </p> <p>El nombre del producto ser\u00e1 b\u00e1sico (producto1, producto2, producto3, etc.). </p> <p>La cantidad y el precio se generan autom\u00e1ticamente.</p> <p>Calcular el precio total de una lista de entre 1 y 10 productos (aleatorio).</p> <p>Mostrar un ticket con todo lo vendido y el precio final.</p>"},{"location":"ud07/ud07ac/#actividad-04","title":"Actividad 04","text":"<p>Desarrollar un sistema de gesti\u00f3n de pacientes. Tendremos un archivador d\u00f3nde iremos guardando todas las fichas de los pacientes. Las fichas contienen la siguiente informaci\u00f3n: nombre, apellidos y edad.</p> <p>Todas las fichas que vayamos creando, se podr\u00e1n guardar o eliminar del archivador. Al archivador tambi\u00e9n le podremos pedir un listado. Este listado consistir\u00e1 en visualizar por pantalla el n\u00famero de fichas guardadas, as\u00ed como el contenido de las fichas.</p> <p>La clase <code>GestionPacientes</code> tiene un m\u00e9todo <code>main</code> en el que se crea un archivador, dos o tres fichas que se guardar\u00e1n en el archivador, se listar\u00e1 el contenido, se eliminar\u00e1 alguna ficha y se volver\u00e1 a listar su contenido. Todas las clases se guardar\u00e1n en el paquete <code>gestionpacientes</code>.</p>"},{"location":"ud07/ud07ac/#actividad-05","title":"Actividad 05","text":"<p>Crear una estructura <code>Map</code> llamada divisas, que almacene pares de moneda y valor al cambio en euros. Por ejemplo D\u00f3lar: 0,81\u20ac.</p> <ul> <li>A\u00f1adir los siguientes pares moneda/valor al Map divisas:</li> </ul> Moneda Valor en \u20ac D\u00f3lar Americano 0.81 Franco Suizo 0.85 Libra Esterlina 1.14 Corona Danesa 0.13 Peso Mexicano 0.04 D\u00f3lar Singapur 0.62 Real Brasil 0.24 <ul> <li> <p>Mostrar el valor de la Libra Esterlina.</p> </li> <li> <p>Mostrar todas las divisas con las que se opera y su valor.</p> </li> <li> <p>Indicar el n\u00famero de divisas del Map.</p> </li> <li> <p>Eliminar la divisa Real Brasil y mostrar los datos del Map.</p> </li> <li> <p>Mostrar si existe la divisa Peso Mexicano.</p> </li> <li> <p>Mostrar si existe la divisa Euro.</p> </li> <li> <p>Mostrar si existe el valor al cambio 0.85 \u20ac.</p> </li> <li> <p>Mostrar si existe el valor al cambio 0.33 \u20ac.</p> </li> <li> <p>Indicar si el Map divisas est\u00e1 vac\u00edo.</p> </li> <li> <p>Borra todos los componentes del Map divisas.</p> </li> <li> <p>Volver a indicar si el Map divisas est\u00e1 vac\u00edo.</p> </li> </ul>"},{"location":"ud07/ud07pi/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li> <p>Curso Java. Programaci\u00f3n gen\u00e9rica. ArrayList I. V\u00eddeo 161</p> </li> <li> <p>Curso Java. Programaci\u00f3n gen\u00e9rica  ArrayList II. V\u00eddeo 162</p> </li> <li> <p>Curso Java  Programaci\u00f3n gen\u00e9rica. ArrayList III  Iteradores. V\u00eddeo 163</p> </li> <li> <p>Curso Java. Programaci\u00f3n gen\u00e9rica. Qu\u00e9 es  Por qu\u00e9 utilizarla. V\u00eddeo 164</p> </li> <li> <p>Curso Java. Colecciones I. V\u00eddeo 179</p> </li> <li> <p>Curso Java. Colecciones II. V\u00eddeo 180</p> </li> <li> <p>Curso Java. Colecciones III. M\u00e9todos equals y hashCode. V\u00eddeo 181</p> </li> <li> <p>Curso Java. Colecciones IV. M\u00e9todos  equals y hashCode II. V\u00eddeo 182</p> </li> <li> <p>Curso Java. Colecciones V  Iteradores. V\u00eddeo 183</p> </li> <li> <p>Curso Java. Colecciones VI  LinkedList I. V\u00eddeo 184</p> </li> <li> <p>Curso Java. Colecciones VII. LinkedList II. V\u00eddeo 185</p> </li> <li> <p>Curso Java. Colecciones VIII  TreeSet I. V\u00eddeo 186</p> </li> <li> <p>Curso Java. Colecciones IX. TreeSet II. V\u00eddeo 187</p> </li> <li> <p>Curso Java. Colecciones X  TreeSet III. V\u00eddeo 188</p> </li> <li> <p>Curso Java. Colecciones XI  Mapas. V\u00eddeo 189</p> </li> </ul>"},{"location":"ud07/ud07re/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li> <p>Wikipedia</p> </li> <li> <p>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</p> </li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>Apuntes Lionel</li> <li>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</li> </ul>"},{"location":"ud08/ud0801/","title":"8.1 Relaciones entre clases","text":"<p>Cuando estudiaste el concepto de clase, \u00e9sta fue descrita como una especie de mecanismo de definici\u00f3n (plantillas), en el que se basar\u00eda el entorno de ejecuci\u00f3n a la hora de construir un objeto: un mecanismo de definici\u00f3n de objetos.</p> <p>Por tanto, a la hora de dise\u00f1ar un conjunto de clases para modelar el conjunto de informaci\u00f3n cuyo tratamiento se desea automatizar, es importante establecer apropiadamente las posibles relaciones que puedan existir entre unas clases y otras.</p> <p>En algunos casos es posible que no exista relaci\u00f3n alguna entre unas clases y otras, pero lo m\u00e1s habitual es que s\u00ed exista: una clase puede ser una especializaci\u00f3n (relaci\u00f3n entre dos clases donde una de ellas, la subclase, es una versi\u00f3n m\u00e1s especializada que la otra, la superclase, compartiendo caracter\u00edsticas en com\u00fan pero a\u00f1adiendo ciertas caracter\u00edsticas espec\u00edficas que la especializan). El punto de vista inverso ser\u00eda la generalizaci\u00f3n (relaci\u00f3n entre dos clases donde una de ellas, la superclase, es una versi\u00f3n m\u00e1s gen\u00e9rica que la otra, la subclase, compartiendo caracter\u00edsticas en com\u00fan pero sin las propiedades espec\u00edficas que caracterizan a la subclase). Es decir, que entre unas clases y otras habr\u00e1 que definir cu\u00e1l es su relaci\u00f3n (si es que existe alguna).</p> <p>Se pueden distinguir diversos tipos de relaciones entre clases:</p> <ul> <li>Clientela. Cuando una clase utiliza objetos de otra clase (por ejemplo al pasarlos como par\u00e1metros a trav\u00e9s de un m\u00e9todo).</li> <li>Composici\u00f3n. Cuando alguno de los atributos de una clase es un objeto de otra clase.</li> <li>Anidamiento. Cuando se definen clases en el interior de otra clase.</li> <li>Herencia. Cuando una clase comparte determinadas caracter\u00edsticas con otra (clase base), a\u00f1adi\u00e9ndole alguna funcionalidad espec\u00edfica (especializaci\u00f3n).</li> </ul> <p>La relaci\u00f3n de clientela la llevas utilizando desde que has empezado a programar en Java, pues desde tu clase principal (clase con m\u00e9todo <code>main</code> ) has estado declarando, creando y utilizando objetos de otras clases. Por ejemplo, si utilizas un objeto <code>String</code> dentro de la clase principal de tu programa, \u00e9ste ser\u00e1 cliente de la clase <code>String</code> (como suceder\u00e1 con pr\u00e1cticamente cualquier programa que se escriba en Java). Es la relaci\u00f3n fundamental y m\u00e1s habitual entre clases (la utilizaci\u00f3n de unas clases por parte de otras) y, por supuesto, la que m\u00e1s vas a utilizar t\u00fa tambi\u00e9n; de hecho, ya la has estado utilizando y lo seguir\u00e1s haciendo.</p> <p>La relaci\u00f3n de composici\u00f3n es posible que ya la hayas tenido en cuenta si has definido clases que conten\u00edan (ten\u00edan como atributos) otros objetos en su interior, lo cual es bastante habitual. Por ejemplo, si escribes una clase donde alguno de sus atributos es un objeto de tipo <code>String</code> , ya se est\u00e1 produciendo una relaci\u00f3n de tipo composici\u00f3n (tu clase \"tiene\" un <code>String</code> , es decir, est\u00e1 compuesta por un objeto <code>String</code> y por algunos elementos m\u00e1s).</p> <p>La relaci\u00f3n de anidamiento (o anidaci\u00f3n) es quiz\u00e1 menos habitual, pues implica declarar unas clases dentro de otras (clases internas o anidadas). En algunos casos puede resultar \u00fatil para tener un nivel m\u00e1s de encapsulamiento (ocultamiento del estado de un objeto, de sus datos miembro o atributos) de manera que s\u00f3lo se puede cambiar mediante las operaciones (m\u00e9todos) definidas para ese objeto. Cada objeto est\u00e1 aislado del exterior de manera que se protegen los datos contra su modificaci\u00f3n por quien no tenga derecho a acceder a ellos, eliminando efectos secundarios y colaterales no deseados. Este modo de proceder permite que el usuario de una clase pueda obviar la implementaci\u00f3n de los m\u00e9todos y propiedades para concentrarse s\u00f3lo en c\u00f3mo usarlos. Por otro lado se evita que el usuario pueda cambiar su estado de manera imprevista e incontrolada, y oculta informaci\u00f3n (efecto que se consigue gracias a la encapsulaci\u00f3n: se evita la visibilidad de determinados miembros de una clase al resto del c\u00f3digo del programa para de ese modo comunicarse con los objetos de la clase \u00fanicamente a trav\u00e9s de su interfaz/m\u00e9todos).</p> <p>En el caso de la relaci\u00f3n de herencia tambi\u00e9n la has visto ya, pues seguro que has utilizado unas clases que derivaban de otras, sobre todo, en el caso de los objetos que forman parte de las interfaces gr\u00e1ficas. Lo m\u00e1s probable es que hayas tenido que declarar clases que derivaban de alg\u00fan componente gr\u00e1fico (<code>JFrame</code>, <code>JDialog</code>, etc.).</p> <p>Podr\u00eda decirse que tanto la composici\u00f3n como la anidaci\u00f3n son casos particulares de clientela, pues en realidad en todos esos casos una clase est\u00e1 haciendo uso de otra (al contener atributos que son objetos de la otra clase, al definir clases dentro de otras clases, al utilizar objetos en el paso de par\u00e1metros, al declarar variables locales utilizando otras clases, etc.).</p> <p>A lo largo de la unidad, ir\u00e1s viendo distintas posibilidades de implementaci\u00f3n de clases haciendo uso de todas estas relaciones, centr\u00e1ndonos especialmente en el caso de la herencia, que es la que permite establecer las relaciones m\u00e1s complejas.</p>"},{"location":"ud08/ud0801/#composicion","title":"Composici\u00f3n","text":"<p>Cuando en un sistema de informaci\u00f3n, una determinada entidad <code>A</code> contiene a otra <code>B</code> como una de sus partes, se suele decir que se est\u00e1 produciendo una relaci\u00f3n de composici\u00f3n. Es decir, el objeto de la clase <code>A</code> contiene a uno o varios objetos de la clase <code>B</code>.</p> <p>Por ejemplo, si describes una entidad <code>Pa\u00eds</code> compuesta por una serie de atributos, entre los cuales se encuentra una lista de comunidades aut\u00f3nomas, podr\u00edas decir que los objetos de la clase <code>Pa\u00eds</code> contienen varios objetos de la clase <code>ComunidadAutonoma</code>. Por otro lado, los objetos de la clase <code>ComunidadAutonoma</code> podr\u00edan contener como atributos objetos de la clase <code>Provincia</code>, la cual a su vez tambi\u00e9n podr\u00eda contener objetos de la clase <code>Municipio</code>.</p> <p>Como puedes observar, la composici\u00f3n puede encadenarse todas las veces que sea necesario hasta llegar a objetos b\u00e1sicos del lenguaje o hasta tipos primitivos que ya no contendr\u00e1n otros objetos en su interior. \u00c9sta es la forma m\u00e1s habitual de definir clases: mediante otras clases ya definidas anteriormente. Es una manera eficiente y sencilla de gestionar la reutilizaci\u00f3n de todo el c\u00f3digo ya escrito. Si se definen clases que describen entidades distinguibles y con funciones claramente definidas, podr\u00e1n utilizarse cada vez que haya que representar objetos similares dentro de otras clases.</p> <p>Anotaci\u00f3n</p> <p>La composici\u00f3n se da cuando una clase contiene alg\u00fan atributo que es una referencia a un objeto de otra clase.</p> <p>Una forma sencilla de plantearte si la relaci\u00f3n que existe entre dos clases A y B es de composici\u00f3n podr\u00eda ser mediante la expresi\u00f3n idiom\u00e1tica \"tiene un\": \"la clase A tiene uno o varios objetos de la clase B\", o visto de otro modo: \"Objetos de la clase B pueden formar parte de la clase A\". </p> Algunos ejemplos ... <ul> <li>Un coche tiene un motor y tiene cuatro ruedas.</li> <li>Una persona tiene un nombre, una fecha de nacimiento, una cuenta bancaria asociada para ingresar la n\u00f3mina, etc.</li> <li>Un cocodrilo bajo investigaci\u00f3n cient\u00edfica que tiene un n\u00famero de dientes determinado, una edad, unas coordenadas de ubicaci\u00f3n geogr\u00e1fica (medidas con GPS), etc.</li> </ul> Recuperando algunos ejemplos de clases que ya hemos utilizado anteriormente ... <ul> <li>Una clase <code>Rectangulo</code> podr\u00eda contener en su interior dos objetos de la clase <code>Punto</code> para almacenar los v\u00e9rtices inferior izquierdo y superior derecho.</li> <li>Una clase <code>Empleado</code> podr\u00eda contener en su interior un objeto de la clase <code>DNI</code> para almacenar su DNI/NIF, y otro objeto de la clase <code>CuentaBancaria</code> para guardar la cuenta en la que se realizan los ingresos en n\u00f3mina.</li> </ul> <p>\u00bfPodr\u00eda decirse que la relaci\u00f3n que existe entre la clase <code>Ave</code> y la clase <code>Loro</code> es una relaci\u00f3n de composici\u00f3n?</p> <p>No. Aunque claramente existe alg\u00fan tipo de relaci\u00f3n entre ambas, no parece que sea la de composici\u00f3n. No parece que se cumpla la expresi\u00f3n \"tiene un\": \"Un loro tiene un ave\". Se cumplir\u00eda m\u00e1s bien una expresi\u00f3n del tipo \"es un\": \"Un loro es un ave\". Algunos objetos que cumplir\u00edan la relaci\u00f3n de composici\u00f3n podr\u00edan ser <code>Pico</code> o <code>Alas</code>, pues \"un loro tiene un pico y dos alas\", del mismo modo que \"un ave tiene pico y dos alas\". Este tipo de relaci\u00f3n parece m\u00e1s de herencia (un loro es un tipo de ave).</p>"},{"location":"ud08/ud0801/#herencia","title":"Herencia","text":"<p>El mecanismo que permite crear clases bas\u00e1ndose en otras que ya existen es conocido como herencia. Como ya has visto en unidades anteriores, Java implementa la herencia mediante la utilizaci\u00f3n de la palabra reservada <code>extends</code>.</p> <p>El concepto de herencia es algo bastante simple y sin embargo muy potente: cuando se desea definir una nueva clase y ya existen clases que, de alguna manera, implementan parte de la funcionalidad que se necesita, es posible crear una nueva clase derivada de la que ya tienes. Al hacer esto se posibilita la reutilizaci\u00f3n de todos los atributos y m\u00e9todos de la clase que se ha utilizado como base (clase madre o superclase), sin la necesidad de tener que escribirlos de nuevo.</p> <p>Una subclase hereda todos los miembros de su clase madre (atributos, m\u00e9todos y clases internas). Los constructores no se heredan, aunque se pueden invocar desde la subclase.</p> Algunos ejemplos ... <ul> <li>Un coche es un veh\u00edculo (heredar\u00e1 atributos como la velocidad m\u00e1xima o m\u00e9todos como parar y arrancar).</li> <li>Un empleado es una persona (heredar\u00e1 atributos como el nombre o la fecha de nacimiento).</li> <li>Un rect\u00e1ngulo es una figura geom\u00e9trica en el plano (heredar\u00e1 m\u00e9todos como el c\u00e1lculo de la superficie o de su per\u00edmetro).</li> <li>Un cocodrilo es un reptil (heredar\u00e1 atributos como por ejemplo el n\u00famero de dientes).</li> </ul> <p>En este caso la expresi\u00f3n idiom\u00e1tica que puedes usar para plantearte si el tipo de relaci\u00f3n entre dos clases A y B es de herencia podr\u00eda ser \"es un\": \"la clase B es un tipo espec\u00edfico de la clase A\" (especializaci\u00f3n), o visto de otro modo: \"la clase A es un caso general de la clase B\" (generalizaci\u00f3n).</p> Recuperando algunos ejemplos de clases que ya hemos utilizado anteriormente ... <ul> <li>Una ventana en una aplicaci\u00f3n gr\u00e1fica puede ser una clase que herede de <code>JFrame</code> (componente <code>Swing</code>: <code>javax.swing.JFrame</code>), de esta manera esa clase ser\u00e1 un marco que dispondr\u00e1 de todos los m\u00e9todos y atributos de <code>JFrame</code> m\u00e1s aquellos que t\u00fa decidas incorporarle al rellenarlo de componentes gr\u00e1ficos.</li> <li>Una caja de di\u00e1logo puede ser un tipo de <code>JDialog</code> (otro componente <code>Swing</code>: <code>javax.swing.JDialog</code>).</li> </ul> <p>En Java, la clase <code>Object</code> (dentro del paquete <code>java.lang</code>) define e implementa el comportamiento com\u00fan a todas las clases (incluidas aquellas que t\u00fa escribas). Como recordar\u00e1s, ya se dijo que en Java cualquier clase deriva en \u00faltima instancia de la clase <code>Object</code>.</p> <p>Todas las clases tienen una clase madre, que a su vez tambi\u00e9n posee una superclase, y as\u00ed sucesivamente hasta llegar a la clase <code>Object</code> . De esta manera, se construye lo que habitualmente se conoce como una jerarqu\u00eda de clases, que en el caso de Java tendr\u00eda a la clase <code>Object</code> en la ra\u00edz.</p> <p>Anotaci\u00f3n</p> <p>Cuando escribas una clase en Java, puedes hacer que herede de una determinada clase madre (mediante el uso de <code>extends</code>) o bien no indicar ninguna herencia. En tal caso, aunque no indiques expl\u00edcitamente ning\u00fan tipo de herencia, el compilador asumir\u00e1 entonces de manera impl\u00edcita que tu clase hereda de la clase <code>Object</code>, que define e implementa el comportamiento com\u00fan a todas las clases.</p>"},{"location":"ud08/ud0801/#herencia-o-composicion","title":"\u00bfHerencia o composici\u00f3n?","text":"<p>Cuando escribas tus propias clases, debes intentar tener claro en qu\u00e9 casos utilizar la composici\u00f3n y cu\u00e1ndo la herencia:</p> <ul> <li>Composici\u00f3n: cuando una clase est\u00e1 formada por objetos de otras clases. En estos casos se incluyen objetos de esas clases, pero no necesariamente se comparten caracter\u00edsticas con ellos (no se heredan caracter\u00edsticas de esos objetos, sino que directamente se utilizar\u00e1n sus atributos y sus m\u00e9todos). Esos objetos incluidos no son m\u00e1s que atributos miembros de la clase que se est\u00e1 definiendo.</li> <li>Herencia: cuando una clase cumple todas las caracter\u00edsticas de otra. En estos casos la clase derivada es una especializaci\u00f3n (o particularizaci\u00f3n, extensi\u00f3n o restricci\u00f3n) de la clase base. Desde otro punto de vista se dir\u00eda que la clase base es una generalizaci\u00f3n de las clases derivadas.</li> </ul> Ejemplo <p>Imagina que dispones de una clase Punto (ya la has utilizado en otras ocasiones) y decides definir una nueva clase llamada C\u00edrculo. Dado que un punto tiene como atributos sus coordenadas en plano (x1, y1), decides que es buena idea aprovechar esa informaci\u00f3n e incorporarla en la clase Circulo que est\u00e1s escribiendo. Para ello utilizas la herencia, de manera que al derivar la clase C\u00edrculo de la clase Punto, tendr\u00e1s disponibles los atributos x1 e y1. Ahora solo faltar\u00eda a\u00f1adirle algunos atributos y m\u00e9todos m\u00e1s como por ejemplo el radio del c\u00edrculo, el c\u00e1lculo de su \u00e1rea y su per\u00edmetro, etc. </p> <p>En principio parece que la idea pueda funcionar pero es posible que m\u00e1s adelante, si contin\u00faas construyendo una jerarqu\u00eda de clases, observes que puedas llegar a conclusiones incongruentes al suponer que un c\u00edrculo es una especializaci\u00f3n de un punto (un tipo de punto). \u00bfTodas aquellas figuras que contengan uno o varios puntos deber\u00edan ser tipos de punto? \u00bfY si tienes varios puntos? \u00bfC\u00f3mo accedes a ellos? \u00bfUn rect\u00e1ngulo tambi\u00e9n tiene sentido que herede de un punto? No parece muy buena idea.</p> <p>Parece que en este caso habr\u00eda resultado mejor establecer una relaci\u00f3n de composici\u00f3n. Anal\u00edzalo detenidamente: \u00bfcu\u00e1l de estas dos situaciones te suena mejor?</p> <ol> <li>\"Un c\u00edrculo es un punto (su centro)\", y por tanto heredar\u00e1 las coordenadas x1 e y1 que tiene todo punto. Adem\u00e1s tendr\u00e1 otras caracter\u00edsticas espec\u00edficas como el radio o m\u00e9todos como el c\u00e1lculo de la longitud de su per\u00edmetro o de su \u00e1rea.</li> <li>\"Un c\u00edrculo tiene un punto (su centro)\", junto con algunos atributos m\u00e1s como por ejemplo el radio. Tambi\u00e9n tendr\u00e1 m\u00e9todos para el c\u00e1lculo de su \u00e1rea o de la longitud de su per\u00edmetro.</li> </ol> <p>Parece que en este caso la composici\u00f3n refleja con mayor fidelidad la relaci\u00f3n que existe entre ambas clases. Normalmente suele ser suficiente con plantearse las preguntas \"\u00bfB es un tipo de A?\" o \"\u00bfB contiene elementos de tipo A?\".</p>"},{"location":"ud08/ud0802/","title":"8.2 Composici\u00f3n","text":""},{"location":"ud08/ud0802/#sintaxis-de-la-composicion","title":"Sintaxis de la composici\u00f3n","text":"<p>Para indicar que una clase contiene objetos de otra clase no es necesaria ninguna sintaxis especial. Cada uno de esos objetos no es m\u00e1s que un atributo y, por tanto, debe ser declarado como tal:</p> Java<pre><code>class &lt;nombreClase&gt; {\n  [modificadores] &lt;NombreClase1&gt; nombreAtributo1;\n  [modificadores] &lt;NombreClase2&gt; nombreAtributo2;\n  &lt;NombreClase3&gt;[] listado;\n  ...    \n}\n</code></pre> <p>En unidades anteriores has trabajado con la clase <code>Punto</code>, que defin\u00eda las coordenadas de un punto en el plano, y con la clase <code>Rectangulo</code>, que defin\u00eda una figura de tipo rect\u00e1ngulo tambi\u00e9n en el plano a partir de dos de sus v\u00e9rtices (inferior izquierdo y superior derecho). Tal y como hemos formalizado ahora los tipos de relaciones entre clases, parece bastante claro que aqu\u00ed tendr\u00edas un caso de composici\u00f3n: \"un rect\u00e1ngulo contiene puntos\". Por tanto, podr\u00edas ahora redefinir los atributos de la clase <code>Rectangulo</code> (cuatro n\u00fameros reales) como dos objetos de tipo <code>Punto</code>:</p> Java<pre><code>class Rectangulo {\n  private Punto vertice1;\n  private Punto vertice2;\n  ...\n}\n</code></pre> <p>Ahora los m\u00e9todos de esta clase deber\u00e1n tener en cuenta que ya no hay cuatro atributos de tipo <code>double</code>, sino dos atributos de tipo <code>Punto</code> (cada uno de los cuales contendr\u00e1 en su interior dos atributos de tipo <code>double</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Intenta reescribir los siguientes los m\u00e9todos de la clase <code>Rectangulo</code> teniendo en cuenta ahora su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>):</p> <ul> <li> <p>M\u00e9todo <code>calcularSuperfice</code>, que calcula y devuelve el \u00e1rea de la superficie encerrada por la figura.</p> </li> <li> <p>M\u00e9todo <code>calcularPerimetro</code>, que calcula y devuelve la longitud del per\u00edmetro de la figura.</p> </li> </ul> <p>SOLUCI\u00d3N En ambos casos la interfaz no se ve modificada en absoluto (desde fuera su funcionamiento es el mismo), pero internamente deber\u00e1s tener en cuenta que ya no existen los atributos <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, de tipo <code>double</code>, sino los atributos <code>vertice1</code> y <code>vertice2</code> de tipo <code>Punto</code>.</p> Java<pre><code>public class Punto {\n    private double x;\n    private double y;\n\n    public Punto(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public void setX(double x) {\n        this.x = x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public void setY(double y) {\n        this.y = y;\n    }\n}\n</code></pre> <p>En la siguiente presentaci\u00f3n puedes observar detalladamente el proceso completo de elaboraci\u00f3n de la clase <code>Rectangulo</code> haciendo uso de la clase <code>Punto</code>:</p> <p>1) Objetos de tipo <code>Rectangulo</code> compuesto por objetos de tipo <code>Punto</code>:</p> <p>  2) Clase <code>Rectangulo</code> y su m\u00e9todo <code>calcularSuperficie</code>:  </p> Java<pre><code>public class Rectangulo {\n    // Atributos de objeto\n    private Punto vertice1;  // V\u00e9rtice inferior izquierdo\n    private Punto vertice2;  // V\u00e9rtice superior derecho\n\n    public double calcularSuperficie (){\n        // c\u00e1lculo de la base\n        double base = vertice2.obtenerX() - vertice1.obtenerX();\n        // c\u00e1lculo de la altura\n        double altura = vertice2.obtenerY() - vertice1.obtenerY();\n        // c\u00e1lculo del \u00e1rea\n        double area = base * altura;\n        return area;   // valor de retorno\n    }\n}\n</code></pre>"},{"location":"ud08/ud0802/#uso-de-la-composicion","title":"Uso de la composici\u00f3n","text":""},{"location":"ud08/ud0802/#preservacion-de-la-ocultacion","title":"Preservaci\u00f3n de la ocultaci\u00f3n","text":"<p>Como ya has observado, la relaci\u00f3n de composici\u00f3n no tiene m\u00e1s misterio a la hora de implementarse que simplemente declarar atributos de las clases que necesites dentro de la clase que est\u00e9s dise\u00f1ando.</p> <p>Ahora bien, cuando escribas clases que contienen objetos de otras clases (lo cual ser\u00e1 lo m\u00e1s habitual) deber\u00e1s tener un poco de precauci\u00f3n con aquellos m\u00e9todos que devuelvan informaci\u00f3n acerca de los atributos de la clase (m\u00e9todos consultores o de tipo get). </p> <p>Como ya viste en la unidad dedicada a la creaci\u00f3n de clases, lo normal suele ser declarar los atributos como privados (o protegidos, como veremos un poco m\u00e1s adelante) para ocultarlos a los posibles clientes de la clase (otros objetos que en el futuro har\u00e1n uso de la clase). Para que otros objetos puedan acceder a la informaci\u00f3n contenida en los atributos, o al menos a una parte de ella, deber\u00e1n hacerlo a trav\u00e9s de m\u00e9todos que sirvan de interfaz, de manera que s\u00f3lo se podr\u00e1 tener acceso a aquella informaci\u00f3n que el creador de la clase haya considerado oportuna. Del mismo modo, los atributos solamente ser\u00e1n modificados desde los m\u00e9todos de la clase, que decidir\u00e1n c\u00f3mo y bajo qu\u00e9 circunstancias deben realizarse esas modificaciones. Con esa metodolog\u00eda de acceso se ten\u00eda perfectamente separada la parte de manipulaci\u00f3n interna de los atributos de la interfaz con el exterior.</p> <p>Hasta ahora los m\u00e9todos de tipo get devolv\u00edan tipos primitivos, es decir, copias del contenido (a veces con alg\u00fan tipo de modificaci\u00f3n o de formato) que hab\u00eda almacenado en los atributos, pero los atributos segu\u00edan \"a salvo\" como elementos privados de la clase. Pero, a partir de este momento, al tener objetos dentro de las clases y no s\u00f3lo tipos primitivos, es posible que en un determinado momento interese devolver un objeto completo.</p> <p>Cuidado al devolver atributos de tipo objeto</p> <p>Ahora bien, cuando vayas a devolver un objeto habr\u00e1s de obrar con mucha precauci\u00f3n. Si en un m\u00e9todo de la clase devuelve directamente un objeto que es un atributo, estar\u00e1s ofreciendo directamente una referencia a un objeto atributo que probablemente has definido como privado. \u00a1De esta forma est\u00e1s volviendo a hacer p\u00fablico un atributo que inicialmente era privado! </p> <p>Para evitar ese tipo de situaciones (ofrecer al exterior referencias a objetos privados) puedes optar por diversas alternativas, procurando siempre evitar la devoluci\u00f3n directa de un atributo que sea un objeto:</p> <p>\u200b   1) Una opci\u00f3n podr\u00eda ser devolver siempre tipos primitivos.</p> <p>\u200b   2) Dado que esto no siempre es posible, o como m\u00ednimo poco pr\u00e1ctico, otra posibilidad es crear un nuevo objeto que sea una copia del atributo que quieres devolver y utilizar ese objeto como valor de retorno. Es decir, crear una copia del objeto especialmente para devolverlo. De esta manera, el c\u00f3digo cliente de ese m\u00e9todo podr\u00e1 manipular a su antojo ese nuevo objeto, pues no ser\u00e1 una referencia al atributo original, sino un nuevo objeto con el mismo contenido.</p> <p>\u200b   3) Por \u00faltimo, debes tener en cuenta que es posible que en algunos casos s\u00ed se necesite realmente la referencia al atributo original (algo muy habitual en el caso de atributos est\u00e1ticos). En tales casos, no habr\u00e1 problema en devolver directamente el atributo para que el c\u00f3digo llamante (cliente) haga el uso que estime oportuno de \u00e9l.</p> <p>Evitar la devoluci\u00f3n de un atributo objeto</p> <p>Debes evitar por todos los medios la devoluci\u00f3n de un atributo que sea un objeto, pues estar\u00edas dando directamente una referencia al atributo, visible y manipulable desde fuera; salvo que se trate de un caso en el que deba ser as\u00ed.</p> <p>Para entender estas situaciones un poco mejor, podemos volver a la clase <code>Rectangulo</code> y observar sus nuevos m\u00e9todos de tipo get.</p> Revisa con cuidado el siguiente ejemplo <p>Dada la clase <code>Rectangulo</code>, escribe sus nuevos m\u00e9todos <code>getVertice1</code> y <code>getVertice2</code> para que devuelvan los v\u00e9rtices inferior izquierdo y superior derecho del rect\u00e1ngulo (objetos de tipo <code>Punto</code>), teniendo en cuenta su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>):</p> <p>SOLUCI\u00d3N (no correcta) Los m\u00e9todos de obtenci\u00f3n de v\u00e9rtices devolver\u00e1n objetos de la clase <code>Punto</code>:</p> Java<pre><code>public Punto getVertice1 (){\n    return vertice1;\n}\n\npublic Punto getVertice2 (){\n    return vertice2;\n}\n</code></pre> <p>Esto funcionar\u00eda perfectamente, pero deber\u00edas tener cuidado con este tipo de m\u00e9todos que devuelven directamente una referencia a un objeto atributo que probablemente has definido como privado. Cuidado!! est\u00e1s de alguna manera haciendo p\u00fablico un atributo que fue declarado como privado.</p> <p>SOLUCI\u00d3N (correcta) Para evitar que esto suceda bastar\u00eda con crear un nuevo objeto que fuera una copia del atributo que se desea devolver (en este caso un objeto de la clase <code>Punto</code>).</p> <p>Aqu\u00ed tienes la soluci\u00f3n para la nueva clase <code>Rectangulo</code>:</p> Java<pre><code>class Rectangulo {\n    private Punto vertice1;\n    private Punto vertice2;\n\n    public double calcularSuperficie() {\n        double area, base, altura; // Variables locales\n        base = vertice2.getX() - vertice1.getX(); // Antes era x2 - x1\n        altura = vertice2.getY() - vertice1.getY(); // Antes era y2 - y1\n        area = base * altura;\n        return area;\n    }\n\n    public double CalcularPerimetro() {\n        double perimetro, base, altura; // Variables locales\n        base = vertice2.getX() - vertice1.getX(); // Antes era x2 - x1\n        altura = vertice2.getY() - vertice1.getY(); // Antes era y2 - y1\n        perimetro = 2 * base + 2 * altura;\n        return perimetro;\n    }\n\n    /*\n    * AS\u00cd NO!!\n    *\n    *public Punto getVertice1mal() {\n    *    return vertice1;\n    *}\n    *\n    *public Punto getVertice2mal() {\n    *    return vertice2;\n    *}  \n    */\n\n    //Mejor de este modo:\n    public Punto getVertice1() {\n        // Creaci\u00f3n de un nuevo punto extrayendo sus atributos:\n        double x, y;\n        Punto p;\n        x = this.vertice1.getX();\n        y = this.vertice1.getY();\n        p = new Punto(x, y);\n        return p;\n    }\n\n    // O, mucho mejor, as\u00ed:\n    public Punto getVertice2() {\n        // Utilizando el constructor copia de Punto (si es que est\u00e1 definido)\n\n        // Punto p;\n        // p = new Punto(this.vertice2); \n        // return p;\n\n        // o m\u00e1s corto:\n        // Uso del constructor copia\n        return new Punto(this.vertice2);\n    }\n\n    public Rectangulo(Punto vertice1, Punto vertice2) {\n        this.vertice1 = vertice1;\n        this.vertice2 = vertice2;\n    }\n\n    public static void main(String[] args) {\n        Punto puntoA = new Punto(0, 0);\n        Punto puntoB = new Punto(5, 5);\n\n        Rectangulo rectA = new Rectangulo(puntoA, puntoB);\n        System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());  //20\n\n        puntoA.setX(4);\n        puntoA.setY(4);\n\n        Rectangulo rectB = new Rectangulo(puntoA, puntoB);\n        System.out.println(\"Creo un nuevo rectangulo, pero cambia el Per\u00edmetro del anterior\");\n        System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());  //20\n        System.out.println(\"Per\u00edmetro del rectanculo B: \" + rectB.CalcularPerimetro());  //4\n    }\n}\n</code></pre> <p>De esta manera, se devuelve un punto totalmente nuevo que podr\u00e1 ser manipulado sin ning\u00fan temor por parte del c\u00f3digo cliente de la clase pues es una copia para \u00e9l.</p>"},{"location":"ud08/ud0802/#llamadas-a-constructores","title":"Llamadas a constructores","text":"<p>Otro factor que debes considerar, a la hora de escribir clases que contengan como atributos objetos de otras clases, es su comportamiento a la hora de instanciarse. Durante el proceso de creaci\u00f3n de un objeto (constructor) de la clase contenedora habr\u00e1 que tener en cuenta tambi\u00e9n la creaci\u00f3n (llamadas a constructores) de aquellos objetos que son contenidos.</p> <p>A tener en cuenta</p> <p>El constructor de la clase contenedora debe invocar a los constructores de las clases de los objetos contenidos.</p> <p>En este caso hay que tener cuidado con las referencias a objetos que se pasan como par\u00e1metros para rellenar el contenido de los atributos. Es conveniente hacer una copia de esos objetos y utilizar esas copias para los atributos pues si se utiliza la referencia que se ha pasado como par\u00e1metro, el c\u00f3digo cliente de la clase podr\u00eda tener acceso a ella sin necesidad de pasar por la interfaz de la clase (volver\u00edamos a dejar abierta una puerta p\u00fablica a algo que quiz\u00e1 sea privado).</p> <p>Adem\u00e1s, si el objeto par\u00e1metro que se pas\u00f3 al constructor formaba parte de otro objeto, esto podr\u00eda ocasionar un desagradable efecto colateral si esos objetos son modificados en el futuro desde el c\u00f3digo cliente de la clase, ya que no sabes de d\u00f3nde provienen esos objetos, si fueron creados especialmente para ser usados por el nuevo objeto creado o si pertenecen a otro objeto que podr\u00eda modificarlos m\u00e1s tarde. Es decir, correr\u00edas el riesgo de estar \"compartiendo\" esos objetos con otras partes del c\u00f3digo, sin ning\u00fan tipo de control de acceso y con las nefastas consecuencias que eso podr\u00eda tener: cualquier cambio de ese objeto afectar\u00eda a partes del programa supuestamente independientes, que entienden ese objeto como suyo.</p> <p>A tener en cuenta</p> <p>En el fondo, los objetos no son m\u00e1s que variables de tipo referencia a la zona de memoria en la que se encuentra toda la informaci\u00f3n del objeto en s\u00ed mismo. Esto es, puedes tener un \u00fanico objeto y m\u00faltiples referencias a \u00e9l. Pero s\u00f3lo se trata de un objeto, y cualquier modificaci\u00f3n desde una de sus referencias afectar\u00eda a todas las dem\u00e1s, pues estamos hablando del mismo objeto.</p> <p>Recuerda tambi\u00e9n que s\u00f3lo se crean objetos cuando se llama a un constructor (uso de <code>new</code>). Si realizas asignaciones o pasos de par\u00e1metros, no se est\u00e1n copiando o pasando copias de los objetos, sino simplemente de las referencias, y por tanto se tratar\u00e1 siempre del mismo objeto. </p> <p>Se trata de un efecto similar al que suced\u00eda en los m\u00e9todos de tipo get, pero en este caso en sentido contrario (en lugar de que nuestra clase \"regale\" al exterior uno de sus atributos objeto mediante una referencia, en esta ocasi\u00f3n se \"adue\u00f1a\" de un par\u00e1metro objeto que probablemente pertenezca a otro objeto y que es posible que en el futuro haga uso de \u00e9l).</p> <p>Para entender mejor estos posibles efectos podemos continuar con el ejemplo de la clase <code>Rectangulo</code> que contiene en su interior dos objetos de la clase <code>Punto</code>. En los constructores del rect\u00e1ngulo habr\u00e1 que incluir todo lo necesario para crear dos instancias de la clase <code>Punto</code> evitando las referencias a par\u00e1metros (haciendo copias).</p> Revisa con cuidado el siguiente ejemplo <p>Intenta reescribir los constructores de la clase <code>Rectangulo</code> teniendo en cuenta ahora su nueva estructura de atributos (dos objetos de la clase <code>Punto</code>, en lugar de cuatro elementos de tipo <code>double</code>): 1\u00ba) Un constructor sin par\u00e1metros (para sustituir al constructor por defecto) que haga que los valores iniciales de las esquinas del rect\u00e1ngulo sean (0,0) y (1,1). 2\u00ba) Un constructor con cuatro par\u00e1metros, <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>, que cree un rect\u00e1ngulo con los v\u00e9rtices (<code>x1</code>, <code>y1</code>) y (<code>x2</code>, <code>y2</code>). 3\u00ba) Un constructor con dos par\u00e1metros, <code>punto1</code>, <code>punto2</code>, que rellene los valores iniciales de los atributos del rect\u00e1ngulo con los valores proporcionados a trav\u00e9s de los par\u00e1metros. 4\u00ba) Un constructor con dos par\u00e1metros, <code>base</code> y <code>altura</code>, que cree un rect\u00e1ngulo donde el v\u00e9rtice inferior derecho est\u00e9 ubicado en la posici\u00f3n (0,0) y que tenga una base y una altura tal y como indican los dos par\u00e1metros proporcionados. 5\u00ba) Un constructor copia.</p> <p>SOLUCI\u00d3N Durante el proceso de creaci\u00f3n de un objeto (constructor) de la clase contenedora (en este caso <code>Rectangulo</code>) hay que tener en cuenta tambi\u00e9n la creaci\u00f3n (llamada a constructores) de aquellos objetos que son contenidos (en este caso objetos de la clase <code>Punto</code>). 1\u00ba) En el caso del primer constructor, habr\u00e1 que crear dos puntos con las coordenadas (0,0) y (1,1) y asignarlos a los atributos correspondientes (<code>vertice1</code> y <code>vertice2</code>):</p> <p>Java<pre><code>public Rectangulo (){\n    this.vertice1 = new Punto (0,0);\n    this.vertice2 = new Punto (1,1);\n}\n</code></pre>  2\u00ba) Para el segundo constructor habr\u00e1 que crear dos puntos con las coordenadas x1, y1, x2, y2 que han sido pasadas como par\u00e1metros:</p> <p>Java<pre><code>public Rectangulo (double x1, double y1, double x2, double y2){\n    this.vertice1 = new Punto (x1, y1);\n    this.vertice2 = new Punto (x2, y2);\n}\n</code></pre>  3\u00ba) En el caso del tercer constructor puedes utilizar directamente los dos puntos que se pasan como par\u00e1metros para construir los v\u00e9rtices del rect\u00e1ngulo.</p> Java<pre><code>public Rectangulo (Punto vertice1, Punto vertice2) {\n    this.vertice1 = vertice1;\n    this.vertice2 = vertice2;\n}\n</code></pre> <p>Ahora bien, esto podr\u00eda ocasionar un efecto colateral no deseado si esos objetos de tipo <code>Punto</code> son modificados en el futuro desde el c\u00f3digo cliente del constructor (no sabes si esos puntos fueron creados especialmente para ser usados por el rect\u00e1ngulo o si pertenecen a otro objeto que podr\u00eda modificarlos m\u00e1s tarde).</p> <p>Por tanto, para este caso quiz\u00e1 fuera recomendable crear dos nuevos puntos a imagen y semejanza de los puntos que se han pasado como par\u00e1metros. Para ello tendr\u00edas dos opciones:</p> <p>a) Llamar al constructor de la clase <code>Punto</code> con los valores de los atributos (x, y).</p> <p>Java<pre><code>public Rectangulo(Punto vertice1, Punto vertice2) {\n    this.vertice1 = new Punto(vertice1.getX(), vertice1.getY());\n    this.vertice2 = new Punto(vertice2.getX(), vertice2.getY());\n}\n</code></pre>  b) Llamar al constructor copia de la clase <code>Punto</code>, si es que se dispone de \u00e9l.</p> <p>Java<pre><code>public Rectangulo (Punto vertice1, Punto vertice2) {\n    this.vertice1 = new Punto (vertice1);\n    this.vertice2 = new Punto (vertice2);\n}\n</code></pre>  4\u00ba) Para el cuarto caso, el caso del constructor que recibe como par\u00e1metros la base y la altura, habr\u00e1 que crear sendos v\u00e9rtices con valores (0,0) y (0 + base, 0 + altura), o lo que es lo mismo: (0,0) y (base, altura).</p> <p>Java<pre><code>public Rectangulo(double base, double altura) {\n    this.vertice1 = new Punto(0,0);\n    this.vertice2 = new Punto(base, altura);\n}\n</code></pre>  5\u00ba) Quedar\u00eda finalmente por implementar el constructor copia, quinto caso:</p> Java<pre><code>public Rectangulo (Rectangulo r) {\n    this.vertice1 = new Punto (r.getVertice1());\n    this.vertice2 = new Punto (r.getVertice2());\n}\n</code></pre> <p>En este caso nuevamente volvemos a clonar los atributos <code>vertice1</code> y <code>vertice2</code> del objeto <code>r</code> que se ha pasado como par\u00e1metro para evitar tener que compartir esos atributos en los dos rect\u00e1ngulos. As\u00ed ahora el m\u00e9todo <code>main</code> que comprueba la clase <code>Rectangulo</code> funciona correctamente:</p> Java<pre><code>public static void main(String[] args) {\n    Punto puntoA = new Punto(0, 0);\n    Punto puntoB = new Punto(5, 5);\n\n    Rectangulo rectA = new Rectangulo(puntoA, puntoB);\n    System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n\n    puntoA.setX(4);\n    puntoA.setY(4);\n\n    Rectangulo rectB = new Rectangulo(puntoA, puntoB);\n    System.out.println(\"Creo un nuevo rectangulo, pero cambia el Per\u00edmetro del anterior\");\n    System.out.println(\"Per\u00edmetro del rectanculo A: \" + rectA.CalcularPerimetro());//20\n    System.out.println(\"Per\u00edmetro del rectanculo B: \" + rectB.CalcularPerimetro());//4\n}\n</code></pre>"},{"location":"ud08/ud0802/#clases-anidadas-o-internas","title":"Clases anidadas o internas","text":"<p>En algunos lenguajes, es posible definir una clase dentro de otra clase (clases internas):</p> Java<pre><code>class ClaseContenedora {\n  // Cuerpo de la clase\n  ...\n  class ClaseInterna {\n    // Cuerpo de la clase interna\n    ...\n  }\n}\n</code></pre> <p>Se pueden distinguir varios tipos de clases internas:</p> <ul> <li> <p>Clases internas est\u00e1ticas (o clases anidadas), declaradas con el modificador <code>static</code>.</p> <p>Estas clases anidadas, como miembros de una clase que son (miembros de <code>ClaseContenedora</code>), pueden ser declaradas con los modificadores <code>public</code>, <code>protected</code>, <code>private</code> o de <code>paquete</code>, como el resto de miembros.</p> </li> <li> <p>Clases internas miembro, conocidas habitualmente como clases internas. Declaradas al m\u00e1ximo nivel de la clase contenedora y no est\u00e1ticas.</p> <p>Estas clases internas (no est\u00e1ticas) tienen acceso a otros miembros de la clase dentro de la que est\u00e1 definida aunque sean privados (se trata en cierto modo de un miembro m\u00e1s de la clase), mientras que las anidadas (est\u00e1ticas) no.</p> <p>Las clases internas se utilizan en algunos casos para: - Agrupar clases que s\u00f3lo tiene sentido que existan en el entorno de la clase en la que han sido definidas, de manera que se oculta su existencia al resto del c\u00f3digo. - Incrementar el nivel de encapsulaci\u00f3n y ocultamiento. - Proporcionar un c\u00f3digo fuente m\u00e1s legible y f\u00e1cil de mantener (el c\u00f3digo de las clases internas y anidadas est\u00e1 m\u00e1s cerca de donde es usado).</p> </li> <li> <p>Clases internas locales, que se declaran en el interior de un bloque de c\u00f3digo (normalmente dentro de un m\u00e9todo).</p> </li> <li> <p>Clases an\u00f3nimas, similares a las internas locales, pero sin nombre (s\u00f3lo existir\u00e1 un objeto de ellas y, al no tener nombre, no tendr\u00e1n constructores). Se suelen usar en la gesti\u00f3n de eventos en los interfaces gr\u00e1ficos.</p> </li> </ul> Java<pre><code>class ClaseContenedora {\n  ...\n  static class ClaseAnidadaEstatica {\n     ...\n  }\n  class ClaseInterna {\n    ...\n  }\n}\n</code></pre> <p>Nota</p> <p>En Java es posible definir clases internas y anidadas, permitiendo todas esas posibilidades. Aunque para los ejemplos con los que vas a trabajar no las vas a necesitar por ahora. </p> Ejemplo de ClaseContenedora y ClaseInterna <p>Java<pre><code>public class ClaseContenedora {\n    private int valorExterno;\n\n    // Constructor de la clase contenedora\n    public ClaseContenedora(int valorExterno) {\n        this.valorExterno = valorExterno;\n    }\n\n    // M\u00e9todo de la clase contenedora para imprimir el valor externo\n    public void imprimirValorExterno() {\n        System.out.println(\"Valor externo: \" + valorExterno);\n    }\n\n    // Clase interna dentro de la clase contenedora\n    public class ClaseInterna {\n        private int valorInterno;\n\n        // Constructor de la clase interna\n        public ClaseInterna(int valorInterno) {\n            this.valorInterno = valorInterno;\n        }\n\n        // M\u00e9todo de la clase interna para imprimir el valor interno y externo\n        public void imprimirValores() {\n            System.out.println(\"Valor externo: \" + valorExterno);\n            System.out.println(\"Valor interno: \" + valorInterno);\n        }\n    }\n}\n</code></pre> Java<pre><code>public class Ejemplo {\n    public static void main(String[] args) {\n        // Crear una instancia de la clase contenedora\n        ClaseContenedora contenedor = new ClaseContenedora(5);\n\n        // Crear una instancia de la clase interna utilizando la instancia de la clase contenedora\n        ClaseContenedora.ClaseInterna interna = contenedor.new ClaseInterna(10);\n\n        // Llamar al m\u00e9todo para imprimir el valor interno y externo desde la clase interna\n        interna.imprimirValores();\n    }\n}\n</code></pre></p>"},{"location":"ud08/ud0803/","title":"8.3 Herencia","text":"<p>Como ya has estudiado, la herencia es el mecanismo que permite definir una nueva clase a partir de otra, pudiendo a\u00f1adir nuevas caracter\u00edsticas, sin tener que volver a escribir todo el c\u00f3digo de la clase base.</p> <p>La clase de la que se hereda suele ser llamada clase base, clase madre o superclase (de la que hereda otra clase, y se heredar\u00e1n todas aquellas caracter\u00edsticas que la clase madre permita). A la clase que hereda se le suele llamar clase hija, clase derivada o subclase (que hereda de otra clase, y se heredan todas aquellas caracter\u00edsticas que la clase madre permita).</p> <p>Una clase derivada puede ser a su vez clase madre de otra que herede de ella y as\u00ed sucesivamente dando lugar a una jerarqu\u00eda de clases, excepto aquellas que est\u00e9n en la parte de arriba de la jerarqu\u00eda (s\u00f3lo ser\u00e1n clases madre) o en la parte de abajo (s\u00f3lo ser\u00e1n clases hijas). </p> <p>Una clase hija no tiene acceso a los miembros privados de su clase madre, tan solo a los p\u00fablicos (como cualquier parte del c\u00f3digo tendr\u00eda) y a los protegidos (a los que s\u00f3lo tienen acceso las clases derivadas y las del mismo paquete). Aquellos miembros que sean privados en la clase base tambi\u00e9n habr\u00e1n sido heredados, pero el acceso a ellos estar\u00e1 restringido al propio funcionamiento de la superclase y s\u00f3lo se podr\u00e1 acceder a ellos si la superclase ha dejado alg\u00fan medio indirecto para hacerlo (por ejemplo a trav\u00e9s de alg\u00fan m\u00e9todo). </p> <p>Todos los miembros de la superclase, tanto atributos como m\u00e9todos, son heredados por la subclase. Algunos de estos miembros heredados podr\u00e1n ser redefinidos o sobrescritos (overriden) y tambi\u00e9n podr\u00e1n a\u00f1adirse nuevos miembros. De alguna manera podr\u00eda decirse que est\u00e1s \"ampliando\" la clase base con caracter\u00edsticas adicionales o modificando algunas de ellas (proceso de especializaci\u00f3n).</p> <p>A tener en cuenta</p> <p>Una clase derivada extiende la funcionalidad de la clase base sin tener que volver a escribir el c\u00f3digo de la clase base.</p>"},{"location":"ud08/ud0803/#sintaxis-de-la-herencia","title":"Sintaxis de la herencia","text":"<p>En Java la herencia se indica mediante la palabra reservada <code>extends</code>:</p> Java<pre><code>[modificador] class ClaseMadre {\n  // Cuerpo de la clase\n  ...\n}\n\n[modificador] class ClaseHija extends ClaseMadre {\n  // Cuerpo de la clase\n  ...\n}\n</code></pre> <p>Imagina que tienes una clase <code>Persona</code> que contiene atributos como <code>nombre</code>, <code>apellidos</code> y <code>fecha de nacimiento</code>:</p> Java<pre><code>public class Persona {\n  String nombre;\n  String apellidos;\n  LocalDate fechaNacim;\n  ...\n}\n</code></pre> <p>Es posible que, m\u00e1s adelante, necesites una clase <code>Alumno</code> que compartir\u00e1 esos atributos (dado que todo alumno es una persona, pero con algunas caracter\u00edsticas espec\u00edficas que lo especializan). En tal caso tendr\u00edas la posibilidad de crear una clase <code>Alumno</code> que repitiera todos esos atributos o bien heredar de la clase <code>Persona</code>:</p> Java<pre><code>public class Alumno extends Persona {\n  String grupo;\n  double notaMedia;\n  ...\n}\n</code></pre> <p>A partir de ahora, un objeto de la clase <code>Alumno</code> contendr\u00e1 los atributos <code>grupo</code> y <code>notaMedia</code> (propios de la clase <code>Alumno</code>), pero tambi\u00e9n <code>nombre</code>, <code>apellidos</code> y <code>fechaNacim</code> (propios de su clase base <code>Persona</code> y que por tanto ha heredado).</p> Revisa con cuidado el siguiente ejemplo <p>Imagina que tambi\u00e9n necesitas una clase <code>Profesor</code>, que contar\u00e1 con atributos como nombre, apellidos, fecha de nacimiento, salario y especialidad. \u00bfC\u00f3mo crear\u00edas esa nueva clase y qu\u00e9 atributos le a\u00f1adir\u00edas?</p> <p>SOLUCI\u00d3N Est\u00e1 claro que un <code>Profesor</code> es otra especializaci\u00f3n de <code>Persona</code>, al igual que lo era <code>Alumno</code>, as\u00ed que podr\u00edas crear otra clase derivada de <code>Persona</code> y as\u00ed aprovechar los atributos gen\u00e9ricos (nombre, apellidos, fecha de nacimiento) que posee todo objeto de tipo <code>Persona</code>. Tan solo faltar\u00eda a\u00f1adirle sus atributos espec\u00edficos (salario y especialidad):</p> Java<pre><code>public class Profesor extends Persona {\n    String especialidad;\n    double salario;\n    ...\n}\n</code></pre>"},{"location":"ud08/ud0803/#acceso-a-miembros-heredados","title":"Acceso a miembros heredados","text":"<p>Como ya has visto anteriormente, no es posible acceder a miembros privados de una superclase. Para poder acceder a ellos podr\u00edas pensar en hacerlos p\u00fablicos, pero entonces estar\u00edas dando la opci\u00f3n de acceder a ellos a cualquier objeto externo y es probable que tampoco sea eso lo deseable. Para ello se invent\u00f3 el modificador <code>protected</code> (protegido) que permite el acceso desde clases heredadas, pero no desde fuera de las clases (estrictamente hablando, desde fuera del paquete), que ser\u00edan como miembros privados.</p> <p>En la unidad dedicada a la utilizaci\u00f3n de clases ya estudiaste los posibles modificadores de acceso que pod\u00eda tener un miembro: sin modificador (acceso de paquete), p\u00fablico, privado o protegido.</p> <p>Aqu\u00ed tienes de nuevo el resumen:</p> modificador Misma clase Mismo paquete Subclase Otro paquete <code>public</code> \u2714 \u2714 \u2714 \u2714 <code>protected</code> \u2714 \u2714 \u2714 \u274c Sin modificador (<code>package</code>) \u2714 \u2714 \u274c \u274c <code>private</code> \u2714 \u274c \u274c \u274c <p>Los modificadores de acceso son excluyentes</p> <p>S\u00f3lo se puede utilizar uno de ellos en la declaraci\u00f3n de un atributo.</p> <p>Si en el ejemplo anterior de la clase <code>Persona</code> se hubieran definido sus atributos como <code>private</code>:</p> Java<pre><code>public class Persona {\n  private String nombre;\n  private String apellidos;\n  ...\n}\n</code></pre> <p>Al definir la clase <code>Alumno</code> como heredera de <code>Persona</code>, no habr\u00edas tenido acceso a esos atributos, pudiendo ocasionar un grave problema de operatividad al intentar manipular esa informaci\u00f3n. Por tanto, en estos casos lo m\u00e1s recomendable habr\u00eda sido declarar esos atributos como <code>protected</code> o bien sin modificador (para que tambi\u00e9n tengan acceso a ellos otras clases del mismo paquete, si es que se considera oportuno):</p> Java<pre><code>public class Persona {\n  protected String nombre;\n  protected String apellidos;\n  ...\n}\n</code></pre> <p>Privacidad de atributos</p> <p>S\u00f3lo en aquellos casos en los que se desea expl\u00edcitamente que un miembro de una clase no pueda ser accesible desde una clase derivada deber\u00eda utilizarse el modificador <code>private</code>. En el resto de casos es recomendable utilizar <code>protected</code>, o bien no indicar modificador (acceso a nivel de paquete).</p> Revisa con cuidado el siguiente ejemplo <p>Reescribe las clases <code>Alumno</code> y <code>Profesor</code> utilizando el modificador protected para sus atributos del mismo modo que se ha hecho para su superclase <code>Persona</code>.</p> <p>SOLUCI\u00d3N 1) Clase <code>Alumno</code>. Se trata simplemente de a\u00f1adir el modificador de acceso protected a los nuevos atributos que a\u00f1ade la clase: Java<pre><code>public class Alumno extends Persona {\n    protected String grupo;\n    protected double notaMedia;\n    ...\n}\n</code></pre></p> <p>2) Clase <code>Profesor</code> (exactamente igual que en la clase <code>Alumno</code>): Java<pre><code>public class Profesor extends Persona {\n    protected String especialidad;\n    protected double salario;\n    ...\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#utilizacion-de-miembros-heredados","title":"Utilizaci\u00f3n de miembros heredados","text":""},{"location":"ud08/ud0803/#atributos","title":"Atributos","text":"<p>Los atributos heredados por una clase son, a efectos pr\u00e1cticos, iguales que aquellos que sean definidos espec\u00edficamente en la nueva clase derivada.</p> <p>En el ejemplo anterior la clase <code>Persona</code> dispon\u00eda de tres atributos y la clase <code>Alumno</code>, que heredaba de ella, a\u00f1ad\u00eda dos atributos m\u00e1s. Desde un punto de vista funcional podr\u00edas considerar que la clase <code>Alumno</code> tiene cinco atributos: tres por ser <code>Persona</code> (nombre, apellidos, fecha de nacimiento) y otros dos m\u00e1s por ser <code>Alumno</code> (grupo y nota media).</p> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, implementa m\u00e9todos get y set en las clases <code>Alumno</code> y <code>Profesor</code> para trabajar con sus cinco atributos (tres heredados m\u00e1s dos espec\u00edficos).</p> <p>SOLUCI\u00d3N</p> <p>1) Clase <code>Alumno</code>.Se trata de heredar de la clase <code>Persona</code> y por tanto utilizar con normalidad sus atributos heredados como si pertenecieran a la propia clase (de hecho se puede considerar que le pertenecen, dado que los ha heredado). Java<pre><code>import java.time.LocalDate;\n\npublic class Alumno extends Persona {\n\n    protected String grupo;\n    protected double notaMedia;\n\n    // M\u00e9todo getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    public String getGrupo() {\n        return grupo;\n    }\n\n    public double getNotaMedia() {\n        return notaMedia;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public void setGrupo(String grupo) {\n        this.grupo = grupo;\n    }\n\n    public void setNotaMedia(double notaMedia) {\n        this.notaMedia = notaMedia;\n    }\n}\n</code></pre></p> <p>Si te fijas, puedes utilizar sin problema la referencia <code>this</code> a la propia clase con esos atributos heredados, pues pertenecen a la clase: <code>this.nombre</code>, <code>this.apellidos</code>, etc.</p> <p>2) Clase <code>Profesor</code>.Seguimos exactamente el mismo procedimiento que con la clase <code>Alumno</code>. Java<pre><code>import java.time.LocalDate;\n\npublic class Profesor extends Persona {\n    String especialidad;\n    double salario;\n\n    // M\u00e9todos getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n    }\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    public String getEspecialidad() {\n        return especialidad;\n    }\n\n    public double getSalario() {\n        return salario;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n    }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n\n    public void setSalario(double salario) {\n        this.salario = salario;\n    }\n\n    public void setESpecialidad(String especialidad) {\n        this.especialidad = especialidad;\n    }\n}\n</code></pre></p> <p>Una conclusi\u00f3n que puedes extraer de este c\u00f3digo es que has tenido que escribir los m\u00e9todos <code>get</code> y <code>set</code> para los tres atributos heredados, pero \u00bfno habr\u00eda sido posible definir esos seis m\u00e9todos en la clase base y as\u00ed estas dos clases derivadas hubieran tambi\u00e9n heredado esos m\u00e9todos? La respuesta es afirmativa y de hecho es como lo vas a hacer a partir de ahora. De esa manera te habr\u00edas evitado tener que escribir seis m\u00e9todos en la clase <code>Alumno</code> y otros seis en la clase <code>Profesor</code>. </p> <p>As\u00ed que, recuerda! Se pueden heredar tanto los atributos como los m\u00e9todos.</p> <p>Aqu\u00ed tienes un ejemplo de c\u00f3mo podr\u00edas haber definido la clase <code>Persona</code> para que luego se hubieran podido heredar de ella sus m\u00e9todos (y no s\u00f3lo sus atributos):</p> <p>SOLUCI\u00d3N IMPLEMENTADA CORRECTAMENTE (I) Java<pre><code>import java.time.LocalDate;\n\npublic class Persona {\n    protected String nombre;\n    protected String apellidos;\n    protected LocalDate fechaNacimiento;\n\n    // M\u00e9todos getXXXXX\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getApellidos() {\n        return apellidos;\n}\n\n    public LocalDate getFechaNacimiento() {\n        return this.fechaNacimiento;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void setApellidos(String apellidos) {\n        this.apellidos = apellidos;\n        }\n\n    public void setFechaNacimiento(LocalDate fechaNacimiento) {\n        this.fechaNacimiento = fechaNacimiento;\n    }\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#metodos","title":"M\u00e9todos","text":"<p>As\u00ed que, visto el ejemplo del punto anterior, del mismo modo que se heredan los atributos, tambi\u00e9n se heredan los m\u00e9todos, convirti\u00e9ndose a partir de ese momento en otros m\u00e9todos m\u00e1s de la clase derivada, junto a los que hayan sido definidos espec\u00edficamente.</p> <p>En el ejemplo de la clase <code>Persona</code>, si dispusi\u00e9ramos de m\u00e9todos get y set para cada uno de sus tres atributos (nombre, apellidos, fechaNacim), tendr\u00edas seis m\u00e9todos que podr\u00edan ser heredados por sus clases derivadas. Podr\u00edas decir entonces que la clase <code>Alumno</code>, derivada de <code>Persona</code>, tiene diez m\u00e9todos:</p> <ul> <li>Seis por ser Persona (<code>getNombre</code>, <code>getApellidos</code>, <code>getFechaNacim</code>, <code>setNombre</code>, <code>setApellidos</code>, <code>setFechaNacim</code>).</li> <li>Oros cuatro m\u00e1s por ser Alumno (<code>getGrupo</code>, <code>setGrupo</code>, <code>getNotaMedia</code>, <code>setNotaMedia</code>).</li> </ul> <p>Sin embargo, solo tendr\u00edas que definir esos cuatro \u00faltimos (los espec\u00edficos) pues los gen\u00e9ricos ya los has heredado de la superclase.</p> Revisa con cuidado el siguiente ejemplo Java<pre><code>public class Profesor extends Persona {\n    String especialidad;\n    double salario;\n\n    // M\u00e9todos getXXXXX\n    public String getEspecialidad() {\n        return especialidad;\n    }\n\n    public double getSalario() {\n        return salario;\n    }\n\n    // M\u00e9todos setXXXXX\n    public void setSalario(double salario) {\n        this.salario = salario;\n    }\n\n    public void setESpecialidad(String especialidad) {\n        this.especialidad = especialidad;\n    }\n}    \n</code></pre>"},{"location":"ud08/ud0803/#redefinicion-de-metodos-heredados","title":"Redefinici\u00f3n de m\u00e9todos heredados","text":"<p>Una clase puede redefinir algunos de los m\u00e9todos que ha heredado de su clase base. El nuevo m\u00e9todo (especializado) sustituye al heredado. Esto se conoce como sobrescritura de m\u00e9todos.</p> <p>En cualquier caso, aunque un m\u00e9todo sea sobrescrito o redefinido, a\u00fan es posible acceder a \u00e9l a trav\u00e9s de la referencia <code>super</code>, aunque s\u00f3lo se podr\u00e1 acceder a m\u00e9todos de la clase madre y no a m\u00e9todos de clases superiores en la jerarqu\u00eda de herencia.</p> <p>Accesibilidad de los m\u00e9todos redefinidos</p> <p>Los m\u00e9todos redefinidos pueden ampliar su accesibilidad con respecto a la que ofrezca el m\u00e9todo original de la superclase, pero nunca restringirla. Por ejemplo, si un m\u00e9todo es declarado como protected o de paquete en la clase base, podr\u00eda ser redefinido como public en una clase derivada. </p> <p>M\u00e9todos est\u00e1ticos</p> <p>Los m\u00e9todos est\u00e1ticos o de clase no pueden ser sobrescritos. Los originales de la clase base permanecen inalterables a trav\u00e9s de toda la jerarqu\u00eda de herencia.</p> <p>En el ejemplo de la clase <code>Alumno</code>, podr\u00edan redefinirse algunos de los m\u00e9todos heredados. Por ejemplo, imagina que el m\u00e9todo getApellidos devuelva la cadena \"Alumno: \" junto con los apellidos del alumno. En tal caso habr\u00eda que reescribir ese m\u00e9todo para realizara esa modificaci\u00f3n:</p> Ejemplo: m\u00e9todo obtener atributo apellidos de <code>Alumno</code> Java<pre><code>public String getApellidos () {\n    return \"Alumno: \" + apellidos;\n}\n</code></pre> <p>Cuando sobrescribas un m\u00e9todo heredado en Java puedes (no es necesario) incluir la anotaci\u00f3n <code>@Override</code>. Esto indicar\u00e1 al compilador que tu intenci\u00f3n es sobrescribir el m\u00e9todo de la clase madre. De este modo, si te equivocas (por ejemplo, al escribir el nombre del m\u00e9todo) y no lo est\u00e1s realmente sobrescribiendo, el compilador producir\u00e1 un error y as\u00ed podr\u00e1s darte cuenta del fallo. En el caso del ejemplo anterior quedar\u00eda:</p> Ejemplo: m\u00e9todo obtener atributo apellidos de <code>Alumno</code> sobreescrito Java<pre><code>@Override\npublic String getApellidos () {\n    return \"Alumno: \" + apellidos;\n}\n</code></pre> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code> que has utilizado anteriormente, redefine el m\u00e9todo <code>getNombre</code> para que devuelva la cadena \"Alumno: \", junto con el nombre del alumno, si se trata de un objeto de la clase <code>Alumno</code> o bien \"Profesor: \", junto con el nombre del profesor, si se trata de un objeto de la clase <code>Profesor</code>.</p> <p>SOLUCI\u00d3N 1) Clase <code>Alumno</code>.Al heredar de la clase <code>Persona</code> tan solo es necesario escribir m\u00e9todos para los nuevos atributos (m\u00e9todos especializados de acceso a los atributos especializados), pues los m\u00e9todos gen\u00e9ricos (de acceso a los atributos gen\u00e9ricos) ya forman parte de la clase al haberlos heredado. Esos son los m\u00e9todos que se implementaron en el ejercicio anterior (<code>getGrupo</code>, <code>setGrupo</code>, etc.).</p> <p>Ahora bien, hay que escribir otro m\u00e9todo m\u00e1s, pues tienes que redefinir el m\u00e9todo <code>getNombre</code> para que tenga un comportamiento un poco diferente al <code>getNombre</code> que se hereda de la clase base <code>Persona</code>: Java<pre><code>// M\u00e9todo getNombre\n@Override\npublic String getNombre (){\n    return \"Alumno: \" + this.nombre;\n}\n</code></pre></p> <p>En este caso podr\u00eda decirse que se \"renuncia\" al m\u00e9todo heredado para redefinirlo con un comportamiento m\u00e1s especializado y acorde con la clase derivada.</p> <p>2) Clase <code>Profesor</code>.Seguimos exactamente el mismo procedimiento que con la clase Alumno (redefinici\u00f3n del m\u00e9todo <code>getNombre</code>). Java<pre><code>// M\u00e9todo getNombre\n@Override\npublic String getNombre() {\n    return \"Profesor: \" + this.nombre;\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#ampliacion-de-metodos-heredados","title":"Ampliaci\u00f3n de m\u00e9todos heredados","text":"<p>Hasta ahora, has visto que para redefinir o sustituir un m\u00e9todo de una superclase es suficiente con crear otro m\u00e9todo en la subclase que tenga el mismo nombre que el m\u00e9todo que se desea sobrescribir. Pero, en otras ocasiones, puede que lo que necesites no sea sustituir completamente el comportamiento del m\u00e9todo de la superclase, sino simplemente ampliarlo.</p> <p>Para poder hacer esto necesitas poder preservar el comportamiento antiguo (el de la superclase) y a\u00f1adir el nuevo (el de la subclase). Para ello, puedes invocar desde el m\u00e9todo \"ampliador\" de la clase derivada al m\u00e9todo \"ampliado\" de la clase superior (teniendo ambos m\u00e9todos el mismo nombre). \u00bfC\u00f3mo se puede conseguir eso? Puedes hacerlo mediante el uso de la referencia <code>super</code>.</p> <p>La palabra reservada <code>super</code> es una referencia a la clase madre de la clase en la que te encuentres en cada momento (es algo similar a <code>this</code>, que representaba una referencia a la clase actual). De esta manera, podr\u00edas invocar a cualquier m\u00e9todo de tu superclase (si es que se tiene acceso a \u00e9l).</p> Ejemplo: m\u00e9todo mostrarDatos de <code>Alumno</code> <p>Imagina que la clase <code>Persona</code> dispone de un m\u00e9todo que permite mostrar el contenido de algunos datos personales de los objetos de este tipo (nombre, apellidos, etc.). Por otro lado, la clase <code>Alumno</code> tambi\u00e9n necesita un m\u00e9todo similar, pero que muestre tambi\u00e9n su informaci\u00f3n especializada (grupo, nota media, etc.). \u00bfC\u00f3mo podr\u00edas aprovechar el m\u00e9todo de la superclase para no tener que volver a escribir su contenido en la subclase?</p> <p>SOLUCI\u00d3N Podr\u00eda hacerse de una manera tan sencilla como la siguiente: Java<pre><code>public void mostrarDatos () {\n  super.mostrarDatos();  // Llamada al m\u00e9todo \"mostrar\" de la superclase\n  // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n  System.out.printf (\"Grupo: %s\\n\", this.grupo);\n  System.out.printf (\"Nota media: %5.2f\\n\", this.notaMedia);\n}\n</code></pre></p> <p>Este tipo de ampliaciones de m\u00e9todos resultan especialmente \u00fatiles por ejemplo en el caso de los constructores, donde se podr\u00eda ir llamando a los constructores de cada superclase encadenadamente hasta el constructor de la clase en la c\u00faspide de la jerarqu\u00eda (el constructor de la clase <code>Object</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Dadas las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, define un m\u00e9todo mostrar para la clase <code>Persona</code>, que muestre el contenido de los atributos (datos personales) de un objeto de la clase <code>Persona</code>. A continuaci\u00f3n, define sendos m\u00e9todos mostrar especializados para las clases <code>Alumno</code> y <code>Profesor</code> que \"ampl\u00eden\" la funcionalidad del m\u00e9todo mostrar original de la clase Persona.</p> <p>SOLUCI\u00d3N 1) M\u00e9todo mostrar de la clase <code>Persona</code>. Java<pre><code>public void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n}\n</code></pre></p> <p>2) M\u00e9todo mostrar de la clase <code>Alumno</code>. Llamamos al m\u00e9todo mostrar de su clase madre (<code>Persona</code>) y luego a\u00f1adimos la funcionalidad espec\u00edfica para la subclase <code>Alumno</code>: Java<pre><code>public void mostrarDatos() {\n    super.mostrarDatos();  // Llamada al m\u00e9todo \"mostrarDatos\" de la superclase\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Grupo:\", this.grupo);\n    System.out.printf (\"%-18s%-5.2f\\n\", \"Nota media:\", this.notaMedia);\n}\n</code></pre></p> <p>3) M\u00e9todo mostrar de la clase <code>Profesor</code>. Llamamos al m\u00e9todo mostrar de su clase madre (<code>Persona</code>) y luego a\u00f1adimos la funcionalidad espec\u00edfica para la subclase <code>Profesor</code>: Java<pre><code>public void mostrarDatos() {\n    super.mostrarDatos();\n\n    System.out.printf (\"%-18s%s\\n\", \"Especialidad:\", this.especialidad);\n    System.out.printf (\"%-18s%-7.2f \u20ac\\n\", \"Salario:\", this.salario);\n}\n</code></pre></p>"},{"location":"ud08/ud0803/#constructores-y-herencia","title":"Constructores y herencia","text":"<p>Recuerda que cuando estudiaste los constructores viste que un constructor de una clase puede llamar a otro constructor de la misma clase, previamente definido, a trav\u00e9s de la referencia <code>this</code>. En estos casos, la utilizaci\u00f3n de <code>this</code> s\u00f3lo pod\u00eda hacerse en la primera l\u00ednea de c\u00f3digo del constructor. </p> <p>Como ya has visto, un constructor de una clase derivada puede hacer algo parecido para llamar al constructor de su clase base mediante el uso de la palabra <code>super</code>. De esta manera, el constructor de una clase derivada puede llamar primero al constructor de su superclase para que inicialice los atributos heredados y posteriormente se inicializar\u00e1n los atributos espec\u00edficos de la clase: los no heredados.</p> <p>A tener en cuenta al utilizar <code>super</code> en un constructor</p> <p>Nuevamente, esta llamada tambi\u00e9n debe ser la primera sentencia de un constructor (con la \u00fanica excepci\u00f3n de que exista una llamada a otro constructor de la clase mediante <code>this</code>). </p> <p>Si no se incluye una llamada a <code>super()</code> dentro del constructor, el compilador incluye autom\u00e1ticamente una llamada al constructor por defecto de clase base (llamada a <code>super()</code>). Esto da lugar a una llamada en cadena de constructores de superclase hasta llegar a la clase m\u00e1s alta de la jerarqu\u00eda (que en Java es la clase <code>Object</code>).</p> <p>En el caso del constructor por defecto (el que crea el compilador si el programador no ha escrito ninguno), el compilador a\u00f1ade lo primero de todo, antes de la inicializaci\u00f3n de los atributos a sus valores por defecto, una llamada al constructor de la clase base mediante la referencia <code>super</code>.</p> <p>A la hora de destruir un objeto (m\u00e9todo <code>finalize</code>) es importante llamar a los finalizadores en el orden inverso a como fueron llamados los constructores (primero se liberan los recursos de la clase derivada y despu\u00e9s los de la clase base mediante la llamada <code>super.finalize()</code>).</p> Constructor de <code>Alumno</code> que hereda parte del constructor de <code>Persona</code> <p>Si la clase <code>Persona</code> tuviera un constructor de este tipo:</p> Java<pre><code>public Persona (String nombre, String apellidos, LocalDate fechaNacim) {\n    this.nombe = nombre;\n    this.apellidos = apellidos;\n    this.fechaNacim = new LocalDate (fechaNacim);\n}\n</code></pre> <p>Podr\u00edas llamarlo desde un constructor de una clase derivada (por ejemplo <code>Alumno</code>) de la siguiente forma:</p> Java<pre><code>public Alumno (String nombre, String apellidos, LocalDate fechaNacim, String grupo, double notaMedia) {\n    super (nombre, apellidos, fechaNacim);\n    this.grupo = grupo;\n    this.notaMedia = notaMedia;\n}\n</code></pre> <p>En realidad se trata de otro recurso m\u00e1s para optimizar la reutilizaci\u00f3n de c\u00f3digo, en este caso el del constructor, que aunque no es heredado, s\u00ed puedes invocarlo para no tener que reescribirlo.</p>"},{"location":"ud08/ud0803/#la-clase-object-en-java","title":"La clase <code>Object</code> en Java","text":"<p>Todas las clases en Java son descendentes (directos o indirectos) de la clase Object. Esta clase define los estados y comportamientos b\u00e1sicos que deben tener todos los objetos. Entre estos comportamientos, se encuentran:</p> <ul> <li>La posibilidad de compararse.</li> <li>La capacidad de convertirse a cadenas.</li> <li>La habilidad de devolver la clase del objeto.</li> </ul> <p>Entre los m\u00e9todos que incorpora la clase <code>Object</code> y que por tanto hereda cualquier clase en Java tienes:</p> <p>Principales m\u00e9todos de la clase <code>Object</code>:</p> M\u00e9todo Descripci\u00f3n <code>Object()</code> Constructor. <code>clone()</code> M\u00e9todo clonador: crea y devuelve una copia del objeto (\"clona\" el objeto). <code>boolean equals(Object obj)</code> Indica si el objeto pasado como par\u00e1metro es igual a este objeto. <code>void finalize()</code> M\u00e9todo llamado por el recolector de basura cuando \u00e9ste considera que no queda ninguna referencia a este objeto en el entorno de ejecuci\u00f3n. <code>int hashCode()</code> Devuelve un c\u00f3digo hash para el objeto. <code>toString()</code> Devuelve una representaci\u00f3n del objeto en forma de String. <p>La clase <code>Object</code> representa la superclase que se encuentra en la c\u00faspide de la jerarqu\u00eda de herencia en Java. Cualquier clase (incluso las que t\u00fa implementes) acaban heredando de ella.</p>"},{"location":"ud08/ud0803/#herencia-multiple","title":"Herencia m\u00faltiple","text":"<p>En determinados casos podr\u00edas considerar la posibilidad de que se necesite heredar de m\u00e1s de una clase, para as\u00ed disponer de los miembros de dos (o m\u00e1s) clases disjuntas (que no derivan una de la otra). La herencia m\u00faltiple permite hacer eso: recoger las distintas caracter\u00edsticas (atributos y m\u00e9todos) de clases diferentes formando una nueva clase derivada de varias clases base.</p> <p>El problema en estos casos es la posibilidad que existe de que se produzcan ambig\u00fcedades; as\u00ed, si tuvi\u00e9ramos miembros con el mismo identificador en clases base diferentes, en tal caso, \u00bfqu\u00e9 miembro se hereda? Para evitar esto, los compiladores suelen solicitar que ante casos de ambig\u00fcedad, se especifique de manera expl\u00edcita la clase de la cual se quiere utilizar un determinado miembro que pueda ser ambiguo.</p> <p>Ahora bien, la posibilidad de herencia m\u00faltiple no est\u00e1 disponible en todos los lenguajes orientados a objetos.</p> <p>...\u00bflo estar\u00e1 en Java?</p> <p>... no existe la herencia m\u00faltiple de clases.</p> <p> </p>"},{"location":"ud08/ud0804/","title":"8.4 Clases abstractas","text":"<p>En determinadas ocasiones, es posible que necesites definir una clase que represente un concepto lo suficientemente abstracto como para que nunca vayan a existir instancias de ella (objetos). \u00bfTendr\u00eda eso sentido? \u00bfQu\u00e9 utilidad podr\u00eda tener?</p> <p>Imagina una aplicaci\u00f3n para un centro educativo que utilice las clases de ejemplo <code>Alumno</code> y <code>Profesor</code>, ambas subclases de <code>Persona</code>. Es m\u00e1s que probable que esa aplicaci\u00f3n nunca llegue a necesitar objetos de la clase <code>Persona</code>, pues ser\u00edan demasiado gen\u00e9ricos como para poder ser utilizados (no contendr\u00edan suficiente informaci\u00f3n espec\u00edfica). Podr\u00edas llegar entonces a la conclusi\u00f3n de que la clase <code>Persona</code> ha resultado de utilidad como clase base para construir otras clases que hereden de ella, pero no como una clase instanciable de la cual vayan a existir objetos. A este tipo de clases se les llama clases abstractas.</p> <p>A tener en cuenta</p> <p>En algunos casos puede resultar \u00fatil disponer de clases que nunca ser\u00e1n instanciadas, sino que proporcionan un marco o modelo a seguir por sus clases derivadas dentro de una jerarqu\u00eda de herencia. Son las clases abstractas.</p> <p>La posibilidad de declarar clases abstractas es una de las caracter\u00edsticas m\u00e1s \u00fatiles de los lenguajes orientados a objetos, pues permiten dar unas l\u00edneas generales de c\u00f3mo es una clase sin tener que implementar todos sus m\u00e9todos o implementando solamente algunos de ellos. Esto resulta especialmente \u00fatil cuando las distintas clases derivadas deban proporcionar los mismos m\u00e9todos indicados en la clase base abstracta, pero su implementaci\u00f3n sea espec\u00edfica para cada subclase. </p> <p>Imagina que est\u00e1s trabajando en un entorno de manipulaci\u00f3n de objetos gr\u00e1ficos y necesitas trabajar con l\u00edneas, c\u00edrculos, rect\u00e1ngulos, etc. Estos objetos tendr\u00e1n en com\u00fan algunos atributos que representen su estado (ubicaci\u00f3n, color del contorno, color de relleno, etc.) y algunos m\u00e9todos que modelen su comportamiento (dibujar, rellenar con un color, escalar, desplazar, rotar, etc.). Algunos de ellos ser\u00e1n comunes para todos ellos (por ejemplo la ubicaci\u00f3n o el desplazamiento) y sin embargo otros (como por ejemplo dibujar) necesitar\u00e1n una implementaci\u00f3n espec\u00edfica dependiendo del tipo de objeto. Pero, en cualquier caso, todos ellos necesitan esos m\u00e9todos (tanto un c\u00edrculo como un rect\u00e1ngulo necesitan el m\u00e9todo dibujar, aunque se lleven a cabo de manera diferente). En este caso resultar\u00eda muy \u00fatil disponer de una clase abstracta objeto gr\u00e1fico donde se definir\u00edan las l\u00edneas generales (algunos atributos concretos comunes, algunos m\u00e9todos concretos comunes implementados y algunos m\u00e9todos gen\u00e9ricos comunes sin implementar) de un objeto gr\u00e1fico y m\u00e1s adelante, seg\u00fan se vayan definiendo clases especializadas (l\u00edneas, c\u00edrculos, rect\u00e1ngulos), se ir\u00e1n concretando en cada subclase aquellos m\u00e9todos que se dejaron sin implementar en la clase abstracta.</p>"},{"location":"ud08/ud0804/#declaracion-de-una-clase-abstracta","title":"Declaraci\u00f3n de una clase abstracta","text":"<p>Ya has visto que una clase abstracta es una clase que no se puede instanciar, es decir, que no se pueden crear objetos a partir de ella. La idea es permitir que otras clases deriven de ella, proporcionando un modelo gen\u00e9rico y algunos m\u00e9todos de utilidad general. Las clases abstractas se declaran mediante el modificador <code>abstract</code>:</p> Java<pre><code>[modificador_acceso] abstract class nombreClase [herencia] [interfaces] {\n  ...\n}\n</code></pre> <p>A tener en cuenta</p> <p>Una clase puede contener en su interior m\u00e9todos declarados como <code>abstract</code> (m\u00e9todos para los cuales s\u00f3lo se indica la cabecera, pero no se proporciona su implementaci\u00f3n). En tal caso, la clase tendr\u00e1 que ser necesariamente tambi\u00e9n <code>abstract</code>. Esos m\u00e9todos tendr\u00e1n que ser posteriormente implementados en sus clases derivadas.</p> <p>Por otro lado, una clase tambi\u00e9n puede contener m\u00e9todos totalmente implementados (no abstractos), los cuales ser\u00e1n heredados por sus clases derivadas y podr\u00e1n ser utilizados sin necesidad de definirlos (pues ya est\u00e1n implementados).</p> <p>Cuando trabajes con clases abstractas debes tener en cuenta:</p> <ul> <li>Una clase abstracta s\u00f3lo puede usarse para crear nuevas clases derivadas. No se puede hacer un <code>new</code> de una clase abstracta. Se producir\u00eda un error de compilaci\u00f3n.</li> <li>Una clase abstracta puede contener m\u00e9todos totalmente definidos (no abstractos) y m\u00e9todos sin definir (m\u00e9todos abstractos).</li> </ul> Revisa con cuidado el siguiente ejemplo <p>Bas\u00e1ndote en la jerarqu\u00eda de clases de ejemplo (<code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>), que ya has utilizado en otras ocasiones, modifica lo que consideres oportuno para que <code>Persona</code> sea, a partir de ahora, una clase abstracta (no instanciable) y las otras dos clases sigan siendo clases derivadas de ella, pero s\u00ed instanciables.</p> <p>SOLUCI\u00d3N En este caso lo \u00fanico que habr\u00eda que hacer es a\u00f1adir el modificador <code>abstract</code> a la clase <code>Persona</code>. El resto de la clase permanecer\u00eda igual y las clases <code>Alumno</code> y <code>Profesor</code> no tendr\u00edan porqu\u00e9 sufrir ninguna modificaci\u00f3n.</p> Java<pre><code>public abstract class Persona {\n    protected String nombre;\n    protected String apellidos;\n    protected LocalDate fechaNacimiento;\n    ...\n}\n</code></pre> <p>A partir de ahora no podr\u00e1n existir objetos de la clase <code>Persona</code>. El compilador generar\u00eda un error.</p> Clases abstractas en la API <p>Localiza en la API de Java alg\u00fan ejemplo de clase abstracta.</p> <p>Existen una gran cantidad de clases abstractas en la API de Java. Aqu\u00ed tienes un par de ejemplos:</p> <ul> <li>La clase <code>AbstractList</code>: Java<pre><code>public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {\n    // ...\n\n    // M\u00e9todos abstractos\n    public abstract E get(int index);\n    public abstract int size();\n}\n</code></pre> De la que heredan clases instanciable como <code>Vector</code> o <code>ArrayList</code>. </li> <li>La clase <code>AbstractSequentialList</code>: Java<pre><code>public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt;{\n    // ...\n\n    // M\u00e9todos abstractos\n    public abstract ListIterator&lt;E&gt; listIterator(int index);\n}\n</code></pre> Esta clase hereda de <code>AbstractList</code>, y de esta hereda la clase <code>LinkedList</code>.    </li> </ul>"},{"location":"ud08/ud0804/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Un m\u00e9todo abstracto es un m\u00e9todo declarado en una clase para el cual esa clase no proporciona la implementaci\u00f3n. Si una clase dispone de, al menos, un m\u00e9todo abstracto se dice que es una clase abstracta. </p> <p>Implementar m\u00e9todos abstractos heredados</p> <p>Toda clase que herede (sea subclase) de una clase abstracta debe implementar todos los m\u00e9todos abstractos de su superclase o bien volverlos a declarar como abstractos (y por tanto tambi\u00e9n ser\u00eda abstracta).</p> <p>Para declarar un m\u00e9todo abstracto en Java se utiliza el modificador <code>abstract</code>. Es un m\u00e9todo cuya implementaci\u00f3n no se define, sino que se declara \u00fanicamente su interfaz (cabecera) para que su cuerpo sea implementado m\u00e1s adelante en una clase derivada.</p> <p>Un m\u00e9todo se declara como abstracto mediante el uso del modificador <code>abstract</code> (como en las clases abstractas):</p> Java<pre><code>[modificador_acceso] abstract &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones];\n</code></pre> <p>A tener en cuenta</p> <p>Cuando una clase contiene un m\u00e9todo abstracto tiene que declararse como abstracta obligatoriamente.</p> <p>Imagina que tienes una clase <code>Empleado</code> gen\u00e9rica para diversos tipos de empleado y tres clases derivadas: <code>EmpleadoFijo</code> (tiene un salario fijo m\u00e1s ciertos complementos), <code>EmpleadoTemporal</code> (salario fijo m\u00e1s otros complementos diferentes) y <code>EmpleadoComercial</code> (una parte de salario fijo y unas comisiones por cada operaci\u00f3n). La clase <code>Empleado</code> podr\u00eda contener un m\u00e9todo abstracto <code>calcularNomina</code>, pues sabes que se m\u00e9todo ser\u00e1 necesario para cualquier tipo de empleado (todo empleado cobra una n\u00f3mina). Sin embargo el c\u00e1lculo en s\u00ed de la n\u00f3mina ser\u00e1 diferente si se trata de un empleado fijo, un empleado temporal o un empleado comercial, y ser\u00e1 dentro de las clases especializadas de <code>Empleado</code> (<code>EmpleadoFijo</code> \u0327 <code>EmpleadoTemporal</code>, <code>EmpleadoComercial</code>) donde se implementen de manera espec\u00edfica el c\u00e1lculo de las mismas.</p> <p>Debes tener en cuenta al trabajar con m\u00e9todos abstractos:</p> <ul> <li>Un m\u00e9todo abstracto implica que la clase a la que pertenece tiene que ser abstracta, pero eso no significa que todos los m\u00e9todos de esa clase tengan que ser abstractos.</li> <li>Un m\u00e9todo abstracto no puede ser privado (no se podr\u00eda implementar, dado que las clases derivadas no tendr\u00edan acceso a \u00e9l).</li> <li>Los m\u00e9todos abstractos no pueden ser est\u00e1ticos, pues los m\u00e9todos est\u00e1ticos no pueden ser redefinidos (y los m\u00e9todos abstractos necesitan ser redefinidos).</li> </ul> Revisa con cuidado el siguiente ejemplo <p>Bas\u00e1ndote en la jerarqu\u00eda de clases <code>Persona</code>, <code>Alumno</code>, <code>Profesor</code>, crea un m\u00e9todo abstracto llamado <code>mostrarDatos</code> para la clase <code>Persona</code>. Dependiendo del tipo de persona (alumno o profesor) el m\u00e9todo <code>mostrarDatos</code> tendr\u00e1 que mostrar unos u otros datos personales (habr\u00e1 que hacer implementaciones espec\u00edficas en cada clase derivada). Una vez hecho esto, implementa completamente las tres clases (con todos sus atributos y m\u00e9todos) y util\u00edzalas en un peque\u00f1o programa de ejemplo que cree un objeto de tipo <code>Alumno</code> y otro de tipo <code>Profesor</code>, los rellene con informaci\u00f3n y muestre esa informaci\u00f3n en la pantalla a trav\u00e9s del m\u00e9todo mostrar. </p> <p>SOLUCI\u00d3N Dado que el m\u00e9todo <code>mostrarDatos</code> no va a ser implementado en la clase <code>Persona</code>, ser\u00e1 declarado como abstracto y no se incluir\u00e1 su implementaci\u00f3n: Java<pre><code>protected abstract void mostrarDatos ();\n</code></pre></p> <p>Recuerda que el simple hecho de que la clase <code>Persona</code> contenga un m\u00e9todo abstracto hace que la clase sea abstracta (y deber\u00e1 indicarse como tal en su declaraci\u00f3n): </p> Java<pre><code>public abstract class Persona {\n...\n</code></pre> <p>En el caso de la clase <code>Alumno</code> habr\u00e1 que hacer una implementaci\u00f3n espec\u00edfica del m\u00e9todo <code>mostrarDatos</code> y lo mismo para el caso de la clase <code>Profesor</code>.</p> <p>1) M\u00e9todo <code>mostrarDatos</code> para la clase <code>Alumno</code>: Java<pre><code>@Override\npublic void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Grupo:\", this.grupo);\n    System.out.printf (\"%-18s%-5.2f\\n\", \"Nota media:\", this.notaMedia);    \n}\n</code></pre></p> <p>2) M\u00e9todo <code>mostrarDatos</code> para la clase <code>Profesor</code>: Java<pre><code>@Override\npublic void mostrarDatos() {\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n\n    System.out.printf (\"%-18s%s\\n\", \"Nombre:\", this.nombre);\n    System.out.printf (\"%-18s%s\\n\", \"Apellidos:\", this.apellidos);\n    System.out.printf (\"%-18s%s\\n\", \"Fecha nacimiento:\", stringFecha);\n    // A continuaci\u00f3n mostramos la informaci\u00f3n \"especializada\" de esta subclase\n    System.out.printf (\"%-18s%s\\n\", \"Especialidad:\", this.especialidad);\n    System.out.printf (\"%-18s%-7.2f \u20ac\\n\", \"Salario:\", this.salario);\n}\n</code></pre></p> <p>3) Un peque\u00f1o programa de ejemplo de uso del m\u00e9todo mostrar en estas dos clases podr\u00eda ser:</p> Java<pre><code>import java.time.LocalDate;\n\npublic class EjemploUso {\n\n    public static void main(String[] args) {\n        // Declaraci\u00f3n de objetos\n        Alumno alumno;\n        Profesor profesor;\n\n        // Creaci\u00f3n de objetos (llamada a constructores)\n        alumno = new Alumno(\"Juan\", \"Torres\", LocalDate.of(1990, 10, 6), \"1DAW\", 7.5);\n\n        profesor = new Profesor(\"Antonio\", \"Campos\", LocalDate.of(1970, 8, 15), \"Informatica\", 1750);\n\n        // Utilizaci\u00f3n del m\u00e9todo mostrar\n        alumno.mostrarDatos();\n        System.out.println();\n        profesor.mostrarDatos();\n    }\n}\n</code></pre> <p>La salida debe ser algo parecido a esto:</p> Bash<pre><code>Nombre:           Juan\nApellidos:        Torres\nFecha nacimiento: 6/10/1990\nGrupo:            1DAW\nNota media:       7,50\n\nNombre:           Antonio\nApellidos:        Campos\nFecha nacimiento: 15/08/1970\nEspecialidad:     Informatica\nSalario:          1750,00 \u20ac\n</code></pre>"},{"location":"ud08/ud0804/#clases-y-metodos-finales","title":"Clases y m\u00e9todos finales","text":"<p>En unidades anteriores has visto el modificador <code>final</code>, aunque s\u00f3lo lo has utilizado por ahora para atributos y variables (por ejemplo para declarar atributos constantes, que una vez que toman un valor ya no pueden ser modificados). Pero este modificador tambi\u00e9n puede ser utilizado con clases y con m\u00e9todos (con un comportamiento que no es exactamente igual, aunque puede encontrarse cierta analog\u00eda: no se permite heredar o no se permite redefinir).</p>"},{"location":"ud08/ud0804/#clases-final","title":"Clases final","text":"<p>Una clase declarada como <code>final</code> no puede ser heredada, es decir, no puede tener clases derivadas. La jerarqu\u00eda de clases a la que pertenece acaba en ella (no tendr\u00e1 clases hijas):</p> Java<pre><code>[modificador_acceso] final class nombreClase [herencia] [interfaces]\n</code></pre>"},{"location":"ud08/ud0804/#metodos-final","title":"M\u00e9todos final","text":"<p>Un m\u00e9todo tambi\u00e9n puede ser declarado como <code>final</code>, en tal caso, ese m\u00e9todo no podr\u00e1 ser redefinido en una clase derivada:</p> Java<pre><code>[modificador_acceso] final &lt;tipo&gt; &lt;nombreMetodo&gt; ([par\u00e1metros]) [excepciones]\n</code></pre> <p>Si intentas redefinir un m\u00e9todo <code>final</code> en una subclase se producir\u00e1 un error de compilaci\u00f3n.</p> <p>Distintos contextos en los que puede aparecer el modificador <code>final</code>:</p> Lugar Funci\u00f3n Como modificador de clase. La clase no puede tener subclases. Como modificador de atributo. El atributo no podr\u00e1 ser modificado una vez que tome un valor. Sirve para definir constantes. Como modificador al declarar un m\u00e9todo El m\u00e9todo no podr\u00e1 ser redefinido en una clase derivada. Como modificador al declarar una variable referencia. Una vez que la variable tome un valor referencia (un objeto), no se podr\u00e1 cambiar. La variable siempre apuntar\u00e1 al mismo objeto, lo cual no quiere decir que ese objeto no pueda ser modificado internamente a trav\u00e9s de sus m\u00e9todos. Pero la variable no podr\u00e1 apuntar a otro objeto diferente. Como modificador en un par\u00e1metro de un m\u00e9todo El valor del par\u00e1metro (ya sea un tipo primitivo o una referencia) no podr\u00e1 modificarse dentro del c\u00f3digo del m\u00e9todo. <p>Veamos un ejemplo de cada posibilidad:</p> 1) Modificador de una clase Java<pre><code>public final class ClaseSinDescendencia { // Clase \"no heredable\"\n...\n}\n</code></pre> 2) Modificador de un atributo Java<pre><code>public class ClaseEjemplo {\n// Valor constante conocido en tiempo de compilaci\u00f3n\nfinal double PI = 3.14159265;\n\n// Valor constante conocido solamente en tiempo de ejecuci\u00f3n\nfinal int SEMILLA = (int) Math.random()*10+1;\n    ...\n}\n</code></pre> 3) Modificador de un m\u00e9todo Java<pre><code>public final metodoNoRedefinible (int parametro1) { // M\u00e9todo \"no redefinible\"\n    ...\n} \n</code></pre> 4) Modificador en una variable referencia Java<pre><code>// Referencia constante: siempre se apuntar\u00e1 al mismo objeto Alumno\n// reci\u00e9n creado, aunque este objeto pueda sufrir modificaciones.\nfinal Alumno PRIMER_ALUMNO = new Alumno (\"Pepe\", \"Torres\", 9.55);\n\n// Si la variable no es una referencia (tipo primitivo), \n// ser\u00eda una constante m\u00e1s (como un atributo constante).\nfinal int NUMERO_DIEZ = 10; // Valor constante (dentro del \u00e1mbito de vida de la variable)\n</code></pre> 5) Modificador en un par\u00e1metro de un m\u00e9todo Java<pre><code>void metodoConParametrosFijos (final int par1, final int par2) {\n    // Los par\u00e1metros \"par1\" y \"par2\" no podr\u00e1n\n    // sufrir modificaciones aqu\u00ed dentro\n    ...\n}\n</code></pre>"},{"location":"ud08/ud0805/","title":"8.5 Interfaces","text":"<p>Has visto c\u00f3mo la herencia permite definir especializaciones (o extensiones) de una clase base que ya existe sin tener que volver a repetir todo el c\u00f3digo de \u00e9sta. Este mecanismo da la oportunidad de que la nueva clase especializada (o extendida) disponga de toda la interfaz que tiene su clase base.</p> <p>Tambi\u00e9n has estudiado c\u00f3mo los m\u00e9todos abstractos permiten establecer una interfaz para marcar las l\u00edneas generales de un comportamiento com\u00fan de superclase que deber\u00edan compartir de todas las subclases.</p> <p>Si llevamos al l\u00edmite esta idea de interfaz, podr\u00edas llegar a tener una clase abstracta donde todos sus m\u00e9todos fueran abstractos. De este modo estar\u00edas dando \u00fanicamente el marco de comportamiento, sin ning\u00fan m\u00e9todo implementado, de las posibles subclases que heredar\u00e1n de esa clase abstracta. La idea de una interfaz (o interface) es precisamente \u00e9sa: disponer de un mecanismo que permita especificar cu\u00e1l debe ser el comportamiento que deben tener todos los objetos que formen parte de una determinada clasificaci\u00f3n (no necesariamente jer\u00e1rquica).</p> <p>Una interfaz consiste principalmente en una lista de declaraciones de m\u00e9todos sin implementar, que caracterizan un determinado comportamiento. Si se desea que una clase tenga ese comportamiento, tendr\u00e1 que implementar esos m\u00e9todos establecidos en la interfaz. En este caso no se trata de una relaci\u00f3n de herencia (la clase B es una especializaci\u00f3n de la clase A, o la subclase B es del tipo de la superclase A), sino m\u00e1s bien una relaci\u00f3n \"de implementaci\u00f3n de comportamientos\" (la clase B implementa los m\u00e9todos establecidos en la interfaz A, o los comportamientos indicados por A son llevados a cabo por B; pero no que B sea de clase A).</p> <p>Imagina que est\u00e1s dise\u00f1ando una aplicaci\u00f3n que trabaja con clases que representan distintos tipos de animales. Algunas de las acciones que quieres que lleven a cabo est\u00e1n relacionadas con el hecho de que algunos animales sean depredadores (por ejemplo: observar una presa, perseguirla, com\u00e9rsela, etc.) o sean presas (observar, huir, esconderse, etc.). Si creas la clase <code>Le\u00f3n</code>, esta clase podr\u00eda implementar una interfaz <code>Depredador</code>, mientras que otras clases como <code>Gacela</code> implementar\u00edan las acciones de la interfaz <code>Presa</code>. Por otro lado, podr\u00edas tener tambi\u00e9n el caso de la clase <code>Rana</code>, que implementar\u00eda las acciones de la interfaz <code>Depredador</code> (pues es cazador de peque\u00f1os insectos), pero tambi\u00e9n la de <code>Presa</code> (pues puede ser cazado y necesita las acciones necesarias para protegerse).</p>"},{"location":"ud08/ud0805/#concepto-de-interfaz","title":"Concepto de interfaz","text":"<p>Una interfaz en Java consiste esencialmente en una lista de declaraciones de m\u00e9todos sin implementar, junto con un conjunto de constantes.</p> <p>Estos m\u00e9todos sin implementar indican un comportamiento, un tipo de conducta, aunque no especifican c\u00f3mo ser\u00e1 ese comportamiento (implementaci\u00f3n), pues eso depender\u00e1 de las caracter\u00edsticas espec\u00edficas de cada clase que decida implementar esa interfaz. Podr\u00eda decirse que una interfaz se encarga de establecer qu\u00e9 comportamientos hay que tener (qu\u00e9 m\u00e9todos), pero no dice nada de c\u00f3mo deben llevarse a cabo esos comportamientos (implementaci\u00f3n). Se indica s\u00f3lo la forma, no la implementaci\u00f3n.</p> <p>En cierto modo podr\u00edas imaginar el concepto de interfaz como un gui\u00f3n que dice: \"este es el protocolo de comunicaci\u00f3n que deben presentar todas las clases que implementen esta interfaz\". Se proporciona una lista de m\u00e9todos p\u00fablicos y, si quieres dotar a tu clase de esa interfaz, tendr\u00e1s que definir todos y cada uno de esos m\u00e9todos p\u00fablicos.</p> <p>En conclusi\u00f3n</p> <p>Una interfaz se encarga de establecer unas l\u00edneas generales sobre los comportamientos (m\u00e9todos) que deber\u00edan tener los objetos de toda clase que implemente esa interfaz; es decir, que no indican lo que el objeto es (de eso se encarga la clase y sus superclases), sino acciones (capacidades) que el objeto deber\u00eda ser capaz de realizar. Es por esto que el nombre de muchas interfaces en Java termina con sufijos del tipo \"\u2010able\", \"\u2010or\", \"\u2010ente\" y cosas del estilo, que significan algo as\u00ed como capacidad o habilidad para hacer o ser receptores de algo (configurable, serializable, modificable, clonable, ejecutable, administrador, servidor, buscador, etc.), dando as\u00ed la idea de que se tiene la capacidad de llevar a cabo el conjunto de acciones especificadas en la interfaz.</p> <p>Imag\u00ednate por ejemplo la clase <code>Coche</code>, subclase de <code>Veh\u00edculo</code>. Los coches son veh\u00edculos a motor, lo cual implica una serie de acciones como, por ejemplo, arrancar el motor o detener el motor. Esa acci\u00f3n no la puedes heredar de <code>Veh\u00edculo</code>, pues no todos los veh\u00edculos tienen porqu\u00e9 ser a motor (piensa por ejemplo en una clase <code>Bicicleta</code>), y no puedes heredar de otra clase pues ya heredas de <code>Veh\u00edculo</code>. Una soluci\u00f3n podr\u00eda ser crear una interfaz <code>Arrancable</code>, que proporcione los m\u00e9todos t\u00edpicos de un objeto a motor (no necesariamente veh\u00edculos). De este modo la clase <code>Coche</code> sigue siendo subclase de <code>Veh\u00edculo</code>, pero tambi\u00e9n implementar\u00eda los comportamientos de la interfaz <code>Arrancable</code>, los cuales podr\u00edan ser tambi\u00e9n implementados por otras clases, hereden o no de <code>Veh\u00edculo</code> (por ejemplo una clase <code>Motocicleta</code> o bien una clase <code>Motosierra</code>). La clase <code>Coche</code> implementar\u00e1 su m\u00e9todo arrancar de una manera, la clase <code>Motocicleta</code> lo har\u00e1 de otra (aunque bastante parecida) y la clase <code>Motosierra</code> de otra forma probablemente muy diferente, pero todos tendr\u00e1n su propia versi\u00f3n del m\u00e9todo arrancar como parte de la interfaz <code>Arrancable</code>.</p> <p>Seg\u00fan esta concepci\u00f3n, podr\u00edas hacerte la siguiente pregunta: \u00bfpodr\u00e1 una clase implementar varias interfaces? La respuesta en este caso s\u00ed es afirmativa.</p> <p>A tener en cuenta</p> <p>Una clase puede adoptar distintos modelos de comportamiento establecidos en diferentes interfaces. Es decir una clase puede implementar varias interfaces.</p>"},{"location":"ud08/ud0805/#clase-abstracta-o-interfaz","title":"\u00bfClase abstracta o interfaz?","text":"<p>Observando el concepto de interfaz que se acaba de proponer, podr\u00eda caerse en la tentaci\u00f3n de pensar que es pr\u00e1cticamente lo mismo que una clase abstracta en la que todos sus m\u00e9todos sean abstractos.</p> <p>Es cierto que en ese sentido existe un gran parecido formal entre una clase abstracta y una interfaz, pudi\u00e9ndose en ocasiones utilizar indistintamente una u otra para obtener un mismo fin. Pero, a pesar de ese gran parecido, existen algunas diferencias, no s\u00f3lo formales, sino tambi\u00e9n conceptuales, muy importantes:</p> <ul> <li>Una clase no puede heredar de varias clases, aunque sean abstractas (herencia m\u00faltiple). Sin embargo s\u00ed puede implementar una o varias interfaces y adem\u00e1s seguir heredando de una clase. </li> <li>Una interfaz no puede definir m\u00e9todos (no implementa su contenido), tan solo los declara o enumera.</li> <li>Una interfaz puede hacer que dos clases tengan un mismo comportamiento independientemente de sus ubicaciones en una determinada jerarqu\u00eda de clases (no tienen que heredar las dos de una misma superclase, pues no siempre es posible seg\u00fan la naturaleza y propiedades de cada clase).</li> <li>Una interfaz permite establecer un comportamiento de clase sin apenas dar detalles, pues esos detalles a\u00fan no son conocidos (depender\u00e1n del modo en que cada clase decida implementar la interfaz).</li> <li>Las interfaces tienen su propia jerarqu\u00eda, diferente e independiente de la jerarqu\u00eda de clases.</li> </ul> <p>De todo esto puede deducirse que una clase abstracta proporciona una interfaz disponible s\u00f3lo a trav\u00e9s de la herencia. S\u00f3lo quien herede de esa clase abstracta dispondr\u00e1 de esa interfaz. Si una clase no pertenece a esa misma jerarqu\u00eda (no hereda de ella) no podr\u00e1 tener esa interfaz. Eso significa que para poder disponer de la interfaz podr\u00edas:</p> <ol> <li>Volver a escribirla para esa jerarqu\u00eda de clases. Lo cual no parece una buena soluci\u00f3n.</li> <li>Hacer que la clase herede de la superclase que proporciona la interfaz que te interesa, sac\u00e1ndola de su jerarqu\u00eda original y convirti\u00e9ndola en clase derivada de algo de lo que conceptualmente no deber\u00eda ser una subclase. Es decir, estar\u00edas forzando una relaci\u00f3n \"es un\" cuando en realidad lo m\u00e1s probable es que esa relaci\u00f3n no exista. Tampoco parece la mejor forma de resolver el problema.</li> </ol> <p>Sin embargo, una interfaz s\u00ed puede ser implementada por cualquier clase, permitiendo que clases que no tengan ninguna relaci\u00f3n entre s\u00ed (pertenecen a distintas jerarqu\u00edas) puedan compartir un determinado comportamiento (una interfaz) sin tener que forzar una relaci\u00f3n de herencia que no existe entre ellas.</p> <p>A partir de ahora podemos hablar de otra posible relaci\u00f3n entre clases: la de compartir un determinado comportamiento (interfaz). Dos clases podr\u00edan tener en com\u00fan un determinado conjunto de comportamientos sin que necesariamente exista una relaci\u00f3n jer\u00e1rquica entre ellas. Tan solo cuando haya realmente una relaci\u00f3n de tipo \"es un\" se producir\u00e1 herencia.</p> <p>A tener en cuenta</p> <p>Si s\u00f3lo vas a proporcionar una lista de m\u00e9todos abstractos (interfaz), sin definiciones de m\u00e9todos ni atributos de objeto, suele ser recomendable definir una interfaz antes que clase abstracta. Es m\u00e1s, cuando vayas a definir una supuesta clase base, puedes comenzar declar\u00e1ndola como interfaz y s\u00f3lo cuando veas que necesitas definir m\u00e9todos o variables miembro, puedes entonces convertirla en clase abstracta (no instanciable) o incluso en una clase instanciable.</p>"},{"location":"ud08/ud0805/#definicion-de-interfaces","title":"Definici\u00f3n de interfaces","text":"<p>La declaraci\u00f3n de una interfaz en Java es similar a la declaraci\u00f3n de una clase, aunque con algunas variaciones:</p> <ul> <li>Se utiliza la palabra reservada <code>interface</code> en lugar de <code>class</code>.</li> <li>Puede utilizarse el modificador <code>public</code>. Si incluye este modificador la interfaz debe tener el mismo nombre que el archivo <code>.java</code> en el que se encuentra (exactamente igual que suced\u00eda con las clases). Si no se indica el modificador <code>public</code>, el acceso ser\u00e1 por omisi\u00f3n o \"de paquete\" (como suced\u00eda con las clases). </li> <li>Todos los miembros de la interfaz (atributos y m\u00e9todos) son <code>public</code> de manera impl\u00edcita. No es necesario indicar el modificador <code>public</code>, aunque puede hacerse.</li> <li>Todos los atributos son de tipo <code>final</code> y <code>public</code> (tampoco es necesario especificarlo), es decir, constantes y p\u00fablicos. Hay que darles un valor inicial.</li> <li>Todos los m\u00e9todos son abstractos tambi\u00e9n de manera impl\u00edcita (tampoco hay que indicarlo). No tienen cuerpo, tan solo la cabecera.</li> </ul> <p>Como puedes observar, una interfaz consiste esencialmente en una lista de atributos finales (constantes) y m\u00e9todos abstractos (sin implementar). Su sintaxis quedar\u00eda entonces:</p> Java<pre><code>[public] interface &lt;NombreInterfaz&gt; {\n  [public] [final] &lt;tipo1&gt; &lt;atributo1&gt; = &lt;valor1&gt;;\n  [public] [final] &lt;tipo2&gt; &lt;atributo2&gt; = &lt;valor2&gt;;\n  ...\n  [public] [abstract] &lt;tipo_devuelto1&gt; &lt;nombreMetodo1&gt; ([lista_par\u00e1metros]);\n  [public] [abstract] &lt;tipo_devuelto2&gt; &lt;nombreMetodo2&gt; ([lista_par\u00e1metros]);\n  ...\n}\n</code></pre> <p>Si te fijas, la declaraci\u00f3n de los m\u00e9todos termina en punto y coma, pues no tienen cuerpo, al igual que sucede con los m\u00e9todos abstractos de las clases abstractas. El ejemplo de la interfaz <code>Depredador</code> que hemos visto antes podr\u00eda quedar entonces as\u00ed:</p> Java<pre><code>public interface Depredador {\n  void perseguir (Animal presa);\n  void cazar (Animal presa);\n  ...\n}\n</code></pre> <p>Ser\u00e1n las clases que implementen esta interfaz (<code>Le\u00f3n</code>, <code>Leopardo</code>, <code>Cocodrilo</code>, <code>Rana</code>, <code>Lagarto</code>, <code>Hombre</code>, etc.) las que definan cada uno de los m\u00e9todos por dentro.</p> Revisa con cuidado el siguiente ejemplo <p>Crea una interfaz en Java cuyo nombre sea <code>Imprimible</code> y que contenga algunos m\u00e9todos \u00fatiles para mostrar el contenido de una clase:</p> <p>SOLUCI\u00d3N 1) M\u00e9todo <code>devolverContenidoString</code>, que crea un <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve. El formato ser\u00e1 una lista de pares \"nombre=valor\" de cada atributo separado por comas y la lista completa encerrada entre llaves: \"<code>{&lt;nombre_atributo_1&gt;=&lt;valor_atributo_1&gt;, ..., &lt;nombre_atributo_n&gt;=&lt;valor_atributo_n&gt;}</code>\".</p> <p>2) M\u00e9todo <code>devolverContenidoArrayList</code>, que crea un <code>ArrayList</code> de <code>String</code> con una representaci\u00f3n de todo el contenido p\u00fablico (o que se decida que deba ser mostrado) del objeto y lo devuelve.</p> <p>3) M\u00e9todo <code>devolverContenidoHashMap</code>, similar al anterior, pero en lugar devolver en un <code>ArrayList</code> los valores de los atributos, se devuelve en una <code>HashMap</code> en forma de pares (<code>nombre</code>, <code>valor</code>). Se trata simplemente de declarar la interfaz e incluir en su interior esos tres m\u00e9todos: Java<pre><code>import java.util.ArrayList;\nimport java.util.HashMap;\n\npublic interface Imprimible {\n    String devolverContenidoString();\n    ArrayList devolverContenidoArrayList();\n    HashMap devolverContenidoHashMap();\n}\n</code></pre></p> <p>El c\u00f3mo se implementar\u00e1n cada uno de esos m\u00e9todos depender\u00e1 exclusivamente de cada clase que decida implementar esta interfaz.</p>"},{"location":"ud08/ud0805/#implementacion-de-interfaces","title":"Implementaci\u00f3n de interfaces","text":"<p>Como ya has visto, todas las clases que implementan una determinada interfaz est\u00e1n obligadas a proporcionar una definici\u00f3n (implementaci\u00f3n) de los m\u00e9todos de esa interfaz, adoptando el modelo de comportamiento propuesto por \u00e9sta.</p> <p>Dada una interfaz, cualquier clase puede especificar dicha interfaz mediante el mecanismo denominado implementaci\u00f3n de interfaces. Para ello se utiliza la palabra reservada implements:</p> Java<pre><code>class NombreClase implements NombreInterfaz {\n</code></pre> <p>De esta manera, la clase est\u00e1 diciendo algo as\u00ed como \"la interfaz indica los m\u00e9todos que debo implementar, pero voy a ser yo (la clase) quien los implemente\".</p> <p>Es posible indicar varios nombres de interfaces separ\u00e1ndolos por comas:</p> Java<pre><code>class NombreClase implements NombreInterfaz1, NombreInterfaz2,... {\n</code></pre> <p>Cuando una clase implementa una interfaz, tiene que redefinir sus m\u00e9todos nuevamente con acceso p\u00fablico. Con otro tipo de acceso se producir\u00e1 un error de compilaci\u00f3n. Es decir, que del mismo modo que no se pod\u00edan restringir permisos de acceso en la herencia de clases, tampoco se puede hacer en la implementaci\u00f3n de interfaces.</p> <p>Una vez implementada una interfaz en una clase, los m\u00e9todos de esa interfaz tienen exactamente el mismo tratamiento que cualquier otro m\u00e9todo, sin ninguna diferencia, pudiendo ser invocados, heredados, redefinidos, etc.</p> <p>En el ejemplo de los depredadores, al definir la clase <code>Le\u00f3n</code>, habr\u00eda que indicar que implementa la interfaz <code>Depredador</code>:</p> Java<pre><code>class Leon implements Depredador {\n</code></pre> <p>En realidad la definici\u00f3n completa de la clase <code>Leon</code> deber\u00eda ser:</p> Java<pre><code>class Leon extends Felino implements Depredador {\n</code></pre> <p>Orden <code>extends</code> e <code>implements</code></p> <p>El orden de <code>extends</code> e <code>implements</code> es importante, primero se define la herencia y a continuaci\u00f3n la interfaces que implementa.</p> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contenga la interfaz:</p> Java<pre><code>void perseguir (Animal presa) {\n  // Implementaci\u00f3n del m\u00e9todo perseguir para un le\u00f3n\n  ...\n}\n</code></pre> <p>En el caso de clases que pudieran ser a la vez <code>Depredador</code> y <code>Presa</code>, tendr\u00edan que implementar ambas interfaces, como podr\u00eda suceder con la clase <code>Rana</code>:</p> Java<pre><code>class Rana implements Depredador, Presa {\n</code></pre> <p>Que de manera completa quedar\u00eda:</p> Java<pre><code>class Rana extends Anfibio implements Depredador, Presa {\n</code></pre> <p>Y en su interior habr\u00eda que implementar aquellos m\u00e9todos que contengan ambas interfaces, tanto las de <code>Depredador</code> (localizar, cazar, etc.) como las de <code>Presa</code> (observar, huir, etc.).</p> Revisa con cuidado el siguiente ejemplo <p>Haz que las clases <code>Alumno</code> y <code>Profesor</code> implementen la interfaz <code>Imprimible</code> que se ha escrito en el ejercicio anterior.</p> <p>SOLUCI\u00d3N La primera opci\u00f3n que se te puede ocurrir es pensar que en ambas clases habr\u00e1 que indicar que implementan la interfaz <code>Imprimible</code> y por tanto definir los m\u00e9todos que \u00e9sta incluye: <code>devolverContenidoString</code>, <code>devolverContenidoHashMap</code> y <code>devolverContenidoArrayList</code>.</p> <p>Si las clases <code>Alumno</code> y <code>Profesor</code> no heredaran de la misma clase habr\u00eda que hacerlo obligatoriamente as\u00ed, pues no comparten superclase y precisamente para eso sirven las interfaces: para implementar determinados comportamientos que no pertenecen a la estructura jer\u00e1rquica de herencia en la que se encuentra una clase (de esta manera, clases que no tienen ninguna relaci\u00f3n de herencia podr\u00edan compartir interfaz).</p> <p>Pero en este caso podr\u00edamos aprovechar que ambas clases s\u00ed son subclases de una misma superclase (heredan de la misma) y hacer que la interfaz <code>Imprimible</code> sea implementada directamente por la superclase (<code>Persona</code>) y de este modo ahorrarnos bastante c\u00f3digo. As\u00ed no har\u00eda falta indicar expl\u00edcitamente que <code>Alumno</code> y <code>Profesor</code> implementan la interfaz <code>Imprimible</code>, pues lo estar\u00e1n haciendo de forma impl\u00edcita al heredar de una clase que ya ha implementado esa interfaz (la clase <code>Persona</code>, que es padre de ambas).</p> <p>Una vez que los m\u00e9todos de la interfaz est\u00e9n implementados en la clase <code>Persona</code>, tan solo habr\u00e1 que redefinir o ampliar los m\u00e9todos de la interfaz para que se adapten a cada clase hija espec\u00edfica (<code>Alumno</code> o <code>Profesor</code>), ahorr\u00e1ndonos tener que escribir varias veces la parte de c\u00f3digo que obtiene los atributos gen\u00e9ricos de la clase <code>Persona</code>.</p> <p>1) Clase <code>Persona</code>. Indicamos que se va a implementar la interfaz <code>Imprimible</code>:</p> Java<pre><code>public abstract class Persona implements Imprimible {\n...\n</code></pre> <p>Definimos el m\u00e9todo <code>devolverContenidoHashMap</code> a la manera de como debe ser implementado para la clase Persona. Podr\u00eda quedar, por ejemplo, as\u00ed:</p> Java<pre><code>@Override\npublic HashMap devolverContenidoHashMap() {\n    // Creamos la HashMap que va a ser devuelta\n    HashMap contenido = new HashMap();\n    // A\u00f1adimos los atributos de la clase\n    DateTimeFormatter formatoFecha = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n\n    String stringFecha = formatoFecha.format(this.fechaNacimiento);\n    contenido.put(\"nombre\", this.nombre);\n    contenido.put(\"apellidos\", this.apellidos);\n    contenido.put(\"fechaNacim\", stringFecha);\n    // Devolvemos la HashMap\n    return contenido;\n}\n</code></pre> <p>Del mismo modo, definimos tambi\u00e9n el m\u00e9todo <code>devolverContenidoArrayList</code>:</p> Java<pre><code>@Override\npublic ArrayList devolverContenidoArrayList() {\n    // Creamos la ArrayList que va a ser devuelta\n    ArrayList contenido = new ArrayList();\n    // A\u00f1adimos los atributos de la clase\n    DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"d/MM/yyyy\");\n\n    String stringFecha = formato.format(this.fechaNacim);\n    contenido.add(this.nombre);\n    contenido.add(this.apellidos);\n    contenido.add(stringFecha);\n    // Devolvemos la ArrayList\n    return contenido;\n}\n</code></pre> <p>Y por \u00faltimo el m\u00e9todo <code>devolverContenidoString</code>:</p> Java<pre><code>@Override\npublic String devolverContenidoString() {\n    DateTimeFormatter formato = DateTimeFormatter.ofPattern(\"d/MM/yyyy\");\n    String stringFecha = formato.format(this.fechaNacim);\n    String contenido = \"{\" + this.nombre + \", \" + this.apellidos + \", \" + stringFecha + \"}\";\nreturn contenido;\n}\n</code></pre> <p>2) Clase <code>Alumno</code>.</p> <p>Esta clase hereda de la clase Persona, de manera que heredar\u00e1 los tres m\u00e9todos anteriores. Tan solo habr\u00e1 que redefinirlos para que, aprovechando el c\u00f3digo ya escrito en la superclase, se a\u00f1ada la funcionalidad espec\u00edfica que aporta esta subclase.</p> Java<pre><code>public class Alumno extends Persona {\n...\n</code></pre> <p>Como puedes observar no ha sido necesario incluir el <code>implements Imprimible</code>, pues el <code>extends Persona</code> lo lleva impl\u00edcito dado que <code>Persona</code> ya implementaba ese interfaz. Lo que haremos entonces ser\u00e1 llamar al m\u00e9todo que estamos redefiniendo utilizando la referencia a la superclase <code>super</code>.</p> <p>El m\u00e9todo <code>devolverContenidoHashMap</code> podr\u00eda quedar, por ejemplo, as\u00ed:</p> Java<pre><code>@Override\npublic HashMap devolverContenidoHashMap() {\n    // Llamada al m\u00e9todo de la superclase\n    HashMap contenido = super.devolverContenidoHashMap();\n    // A\u00f1adimos los atributos espec\u00edficos de la clase\n    contenido.put(\"grupo\", this.grupo);\n    contenido.put(\"notaMedia\", this.notaMedia);\n    // Devolvemos la HashMap rellena\n    return contenido;\n}\n</code></pre> <p>3) Clase <code>Profesor</code>. En este caso habr\u00eda que proceder exactamente de la misma manera que con la clase Alumno: redefiniendo los m\u00e9todos de la interfaz <code>Imprimible</code> para a\u00f1adir la funcionalidad espec\u00edfica que aporta esta subclase, en este caso mostraremos la redifinici\u00f3n del m\u00e9todo <code>devolverContenidoArrayList()</code>:</p> Java<pre><code>@Override\npublic ArrayList devolverContenidoArrayList() {\n    // Llamada al m\u00e9todo de la superclase\n    ArrayList contenido = super.devolverContenidoArrayList();\n    // A\u00f1adimos los atributos espec\u00edficos de la clase\n    contenido.add(this.especialidad);\n    contenido.add(this.salario);\n    // Devolvemos la ArrayList\n    return contenido;\n}\n</code></pre> <p>y la redefinici\u00f3n del m\u00e9todo <code>devolverContenidoString()</code>:</p> Java<pre><code>@Override\npublic String devolverContenidoString() {\n    // Llamada al m\u00e9todo de la superclase\n    String contenido = super.devolverContenidoString();\n    //Eliminamos el \u00faltimo car\u00e1cter, que contiene una llave de cierre.\n    contenido = contenido.substring(0, contenido.length() - 1);\n    contenido = contenido + \", \" + this.especialidad + \", \" + this.salario + \"}\";\n    // Devolvemos el String creado.\n    return contenido;\n}\n</code></pre>"},{"location":"ud08/ud0805/#un-ejemplo-de-implementacion-de-interfaces-la-interfaz-series","title":"Un ejemplo de implementaci\u00f3n de interfaces: la interfaz <code>Series</code>","text":"<p>En la forma tradicional de una interfaz, los m\u00e9todos se declaran utilizando solo su tipo de devoluci\u00f3n y firma. Son, esencialmente, m\u00e9todos abstractos. Por lo tanto, cada clase que incluye dicha interfaz debe implementar todos sus m\u00e9todos.</p> <p>A tener en cuenta</p> <p>En una interfaz, los m\u00e9todos son impl\u00edcitamente p\u00fablicos.</p> <p>A tener en cuenta</p> <p>Las variables declaradas en una interfaz no son variables de instancia. En cambio, son impl\u00edcitamente public, final, y static, y deben inicializarse. Por lo tanto, son esencialmente constantes.</p> <p>Aqu\u00ed hay un ejemplo de una definici\u00f3n de interfaz. Especifica la interfaz a una clase que genera una serie de n\u00fameros.</p> Java<pre><code>public interface Series {\n  int getSiguiente(); //Retorna el siguiente n\u00famero de la serie\n  void reiniciar();   //Reinicia\n  void setComenzar(int x); //Establece un valor inicial\n}\n</code></pre> <p>Esta interfaz se declara p\u00fablica para que pueda ser implementada por c\u00f3digo en cualquier paquete.</p> <p>Los m\u00e9todos que implementan una interfaz deben declararse p\u00fablicos. Adem\u00e1s, el tipo del m\u00e9todo de implementaci\u00f3n debe coincidir exactamente con el tipo especificado en la definici\u00f3n de la interfaz.</p> Ejemplo <p>Aqu\u00ed hay un ejemplo que implementa la interfaz de <code>Series</code> mostrada anteriormente. Crea una clase llamada <code>DeDos</code>, que genera una serie de n\u00fameros, cada uno mayor que el anterior.</p> <p>SOLUCI\u00d3N Java<pre><code>class DeDos implements Series {\n    int iniciar;\n    int valor;\n\n    DeDos(){\n        iniciar = 0;\n        valor = 0;\n    }\n\n    public int getSiguiente() {\n        valor += 2;\n        return valor;\n    }\n\n    public void reiniciar() {\n        valor = iniciar;\n    }\n\n    public void setComenzar(int x) {\n        iniciar = x;\n        valor = x;\n    }\n}\n</code></pre></p> <p>Observa que los m\u00e9todos <code>getSiguiente()</code>, <code>reiniciar()</code> y <code>setComenzar()</code> se declaran utilizando el especificador de acceso p\u00fablico (<code>public</code>). Esto es necesario. Siempre que implementes un m\u00e9todo definido por una interfaz, debe implementarse como p\u00fablico porque todos los miembros de una interfaz son impl\u00edcitamente p\u00fablicos.</p> Ejemplo <p>Aqu\u00ed hay una clase que demuestra <code>DeDos</code>:</p> <p>SOLUCI\u00d3N Java<pre><code>class SeriesDemo {\n    public static void main(String[] args) {\n        DeDos ob = new DeDos();\n        for (int i=0; i&lt;5; i++){\n            System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n        }\n        System.out.println(\"\\nReiniciando\");\n        ob.reiniciar();\n        for (int i=0; i&lt;5; i++){\n            System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n        }\n        System.out.println(\"\\nIniciando en 100\");\n        ob.setComenzar(100);\n        for (int i=0; i&lt;5; i++){\n            System.out.println(\"Siguiente valor es: \" + ob.getSiguiente());\n        }\n    }\n}\n</code></pre></p> <p>Salida:</p> Bash<pre><code>Siguiente valor es: 2\nSiguiente valor es: 4\nSiguiente valor es: 6\nSiguiente valor es: 8\nSiguiente valor es: 10\nReiniciando\nSiguiente valor es: 2\nSiguiente valor es: 4\nSiguiente valor es: 6\nSiguiente valor es: 8\nSiguiente valor es: 10\nIniciando en 100\nSiguiente valor es: 102\nSiguiente valor es: 104\nSiguiente valor es: 106\nSiguiente valor es: 108\nSiguiente valor es: 110\n</code></pre> <p>Est\u00e1 permitido y es com\u00fan para las clases que implementan interfaces definir miembros adicionales propios. Por ejemplo, la siguiente versi\u00f3n de <code>DeDos</code> agrega el m\u00e9todo <code>getAnterior()</code>, que devuelve el valor anterior:</p> Ejemplo <p>Aqu\u00ed hay una clase que demuestra <code>DeDos</code>:</p> <p>SOLUCI\u00d3N Java<pre><code>class DeDos implements Series {\n    int iniciar;\n    int valor;\n    int anterior;\n\n    DeDos(){\n        iniciar = 0;\n        valor = 0;\n    }\n\n    public int getSiguiente() {\n        anterior = valor;\n        valor += 2;\n        return valor;\n    }\n\n    public void reiniciar() {\n        valor = iniciar;\n        anterior = valor-2;\n    }\n\n    public void setComenzar(int x) {\n        iniciar = x;\n        valor = x;\n        anterior = x-2;\n    }\n\n    //A\u00f1adiendo un m\u00e9todo que no est\u00e1 definido en Series\n    int getAnterior(){\n        return anterior;\n    }\n}\n</code></pre></p> <p>Observa que la adici\u00f3n de <code>getAnterior()</code> requiri\u00f3 un cambio en las implementaciones de los m\u00e9todos definidos por <code>Series</code>. Sin embargo, dado que la interfaz con esos m\u00e9todos permanece igual, el cambio es continuo y no rompe el c\u00f3digo preexistente. Esta es una de las ventajas de las interfaces.</p> <p>Como se explic\u00f3, cualquier cantidad de clases puede implementar una interfaz. Por ejemplo, aqu\u00ed hay una clase llamada <code>DeTres</code> que genera una serie que consta de m\u00faltiplos de tres:</p> Java<pre><code>public class DeTres implements Series{\n    int iniciar;\n    int valor;\n\n    DeTres(){\n        iniciar = 0;\n        valor = 0;\n    }\n\n    public int getSiguiente() {\n        valor += 3;\n        return valor;\n    }\n\n    public void reiniciar() {\n        valor = iniciar;\n    }\n\n    public void setComenzar(int x) {\n        iniciar = x;\n        valor = x;\n    }\n}\n</code></pre>"},{"location":"ud08/ud0805/#simulacion-de-la-herencia-multiple-mediante-el-uso-de-interfaces","title":"Simulaci\u00f3n de la herencia m\u00faltiple mediante el uso de interfaces","text":"<p>Almacenamiento de una interfaz</p> <p>Una interfaz no tiene espacio de almacenamiento asociado (no se van a declarar objetos de un tipo de interfaz), es decir, no tiene implementaci\u00f3n.</p> <p>En algunas ocasiones es posible que interese representar la situaci\u00f3n de que \"una clase X es de tipo A, de tipo B, y de tipo C\", siendo A, B, C clases disjuntas (no heredan unas de otras). Hemos visto que ser\u00eda un caso de herencia m\u00faltiple que Java no permite.</p> <p>Para poder simular algo as\u00ed, podr\u00edas definir tres interfaces A, B, C que indiquen los comportamientos (m\u00e9todos) que se deber\u00edan tener seg\u00fan se pertenezca a una supuesta clase A, B, o C, pero sin implementar ning\u00fan m\u00e9todo concreto ni atributos de objeto (s\u00f3lo interfaz).</p> <p>De esta manera la clase X podr\u00eda a la vez:</p> <ol> <li>Implementar las interfaces A, B, C, que la dotar\u00edan de los comportamientos que deseaba heredar de las clases A, B, C.</li> <li>Heredar de otra clase Y, que le proporcionar\u00eda determinadas caracter\u00edsticas dentro de su taxonom\u00eda o jerarqu\u00eda de objeto (atributos, m\u00e9todos implementados y m\u00e9todos abstractos).</li> </ol> <p>En el ejemplo que hemos visto de las interfaces <code>Depredador</code> y <code>Presa</code>, tendr\u00edas un ejemplo de esto: la clase <code>Rana</code>, que es subclase de <code>Anfibio</code>, implementa una serie de comportamientos propios de un <code>Depredador</code> y, a la vez, otros m\u00e1s propios de una <code>Presa</code>. Esos comportamientos (m\u00e9todos) no forman parte de la superclase <code>Anfibio</code>, sino de las interfaces. Si se decide que la clase <code>Rana</code> debe de llevar a cabo algunos otros comportamientos adicionales, podr\u00edan a\u00f1adirse a una nueva interfaz y la clase <code>Rana</code> implementar\u00eda una tercera interfaz.</p> <p>De este modo, con el mecanismo \"una herencia pero varias interfaces\", podr\u00edan conseguirse resultados similares a los obtenidos con la herencia m\u00faltiple.</p> <p>Ahora bien, del mismo modo que suced\u00eda con la herencia m\u00faltiple, puede darse el problema de la colisi\u00f3n de nombres al implementar dos interfaces que tengan un m\u00e9todo con el mismo identificador. En tal caso puede suceder lo siguiente:</p> <ul> <li>Si los dos m\u00e9todos tienen diferentes par\u00e1metros no habr\u00e1 problema aunque tengan el mismo nombre pues se realiza una sobrecarga de m\u00e9todos.</li> <li>Si los dos m\u00e9todos tienen un valor de retorno de un tipo diferente, se producir\u00e1 un error de compilaci\u00f3n (al igual que sucede en la sobrecarga cuando la \u00fanica diferencia entre dos m\u00e9todos es \u00e9sa).</li> <li>Si los dos m\u00e9todos son exactamente iguales en identificador, par\u00e1metros y tipo devuelto, entonces solamente se podr\u00e1 implementar uno de los dos m\u00e9todos. En realidad se trata de un solo m\u00e9todo pues ambos tienen la misma interfaz (mismo identificador, mismos par\u00e1metros y mismo tipo    devuelto).</li> </ul> <p>Nombres id\u00e9nticos en diferentes interfaces</p> <p>La utilizaci\u00f3n de nombres id\u00e9nticos en diferentes interfaces que pueden ser implementadas a la vez por una misma clase puede causar, adem\u00e1s del problema de la colisi\u00f3n de nombres, dificultades de legibilidad en el c\u00f3digo, pudiendo dar lugar a confusiones. Si es posible intenta evitar que se produzcan este tipo de situaciones.</p>"},{"location":"ud08/ud0805/#herencia-de-interfaces","title":"Herencia de interfaces","text":"<p>Las interfaces, al igual que las clases, tambi\u00e9n permiten la herencia. Para indicar que una interfaz hereda de otra se indica nuevamente con la palabra reservada <code>extends</code>. Pero en este caso s\u00ed se permite la herencia m\u00faltiple de interfaces. Si se hereda de m\u00e1s de una interfaz se indica con la lista de interfaces separadas por comas.</p> <p>Por ejemplo, dadas las interfaces <code>InterfazUno</code> e <code>InterfazDos</code>:</p> Java<pre><code>public interface InterfazUno {\n  // M\u00e9todos y constantes de la interfaz Uno\n}\n\npublic interface InterfazDos {\n  // M\u00e9todos y constantes de la interfaz Dos\n}\n</code></pre> <p>Podr\u00eda definirse una nueva interfaz que heredara de ambas:</p> Java<pre><code>public interface InterfazCompleja extends InterfazUno, InterfazDos {\n  // M\u00e9todos y constantes de la interfaz compleja\n} \n</code></pre> \u00bfPuede una clase implementar varias interfaces diferentes a la vez? <p>Observa el siguiente esquema UML:  Las clases <code>Kangaroo</code> y <code>Lion</code> implementan varias clases:     - <code>Kangaroo</code> : <code>Herbivore</code>, <code>TwoLeggedMammal</code> y <code>Animal</code>     - <code>Lion</code> : <code>Animal</code>, <code>FourLeggedMammal</code>, <code>Hunter</code> y <code>Carnivore</code></p> Ejemplo 5.5 <p>\u00bfPuede una interfaz heredar de varias interfaces diferentes a la vez?</p> <p>Observa el anterior esquema UML: Lass interfaces <code>Human</code> y <code>Omnivore</code> heredan de varias interfaces: - <code>Human</code> : de <code>TwoLeggedMammal</code>, <code>Omnivore</code>, <code>Mammal</code> y <code>Hunter</code> - <code>Omnivore</code> : <code>Herbivore</code> y <code>Carnivore</code>.</p> Ejemplo 5.6 <p>Supongamos una situaci\u00f3n en la que nos interesa dejar constancia de que ciertas clases deben implementar una funcionalidad te\u00f3rica determinada, diferente en cada clase afectada. Estamos hablando, pues, de la definici\u00f3n de un m\u00e9todo te\u00f3rico que algunas clases deber\u00e1n implementar. Un ejemplo real puede ser el m\u00e9todo <code>calculoImporteJubilacion()</code> aplicable, de manera diferente, a muchas tipolog\u00edas de trabajadores y, por tanto, podr\u00edamos pensar en dise\u00f1ar una clase <code>Trabajador</code> en que uno de sus m\u00e9todos fuera <code>calculoImporteJubilacion()</code>. Esta soluci\u00f3n es v\u00e1lida si estamos dise\u00f1ando una jerarqu\u00eda de clases a partir de la clase <code>Trabajador</code> de la que cuelguen las clases correspondientes a las diferentes tipolog\u00edas de trabajadores (metal\u00fargicos, hosteler\u00eda, inform\u00e1ticos, profesores...). Adem\u00e1s, disponemos del concepto de clase abstracta que cada subclase implemente obligatoriamente el m\u00e9todo <code>calculoImporteJubilacion()</code>. Pero, \u00bfy si resulta que ya tenemos las clases <code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> en otras jerarqu\u00edas de clases? La soluci\u00f3n consiste en hacer que estas clases derivaran de la clase <code>Trabajador</code>, sin abandonar la derivaci\u00f3n que pudieran tener, ser\u00eda factible en lenguajes orientados a objetos que soportaran la herencia m\u00faltiple, pero esto no es factible en el lenguaje Java. Para superar esta limitaci\u00f3n, Java proporciona las interfaces.</p> <p>Definici\u00f3n de interfaz</p> <p>Una interfaz es una maqueta contenedora de una lista de m\u00e9todos abstractos y datos miembro (de tipos primitivos o de clases). Los atributos, si existen, son impl\u00edcitamente considerados <code>static</code> y <code>final</code>. Los m\u00e9todos, si existen, son impl\u00edcitamente considerados <code>public</code>.</p> <p>Para entender en qu\u00e9 nos pueden ayudar las interface, necesitamos saber:     - Una interfaz puede ser implementada por m\u00faltiples clases, de manera similar a como una clase puede ser superclase de m\u00faltiples clases.     - Las clases que implementan una interfaz est\u00e1n obligadas a sobrescribir todos los m\u00e9todos definidos en la interfaz. Si la definici\u00f3n de alguno de los m\u00e9todos a sobrescribir coincide con la definici\u00f3n de alg\u00fan m\u00e9todo heredado, este desaparece de la clase.     - Una clase puede implementar m\u00faltiples interfaces, a diferencia de la derivaci\u00f3n, que s\u00f3lo se permite una \u00fanica clase base.     - Una interfaz introduce un nuevo tipo de dato, por la que nunca habr\u00e1 ninguna instancia, pero s\u00ed objetos usuarios de la interfaz (objetos de las clases que implementan la interfaz). Todas las clases que implementan una interfaz son compatibles con el tipo introducido por la interfaz.     - Una interfaz no proporciona ninguna funcionalidad a un objeto (ya que la clase que implementa la interfaz es la que debe definir la funcionalidad de todos los m\u00e9todos), pero en cambio proporciona la posibilidad de formar parte de la funcionalidad de otros objetos (pas\u00e1ndola por par\u00e1metro en m\u00e9todos de otras clases).     - La existencia de las interfaces posibilita la existencia de una jerarqu\u00eda de tipo (que no debe confundirse con la jerarqu\u00eda de clases) que permite la herencia m\u00faltiple.     - Una interfaz no se puede instanciar, pero s\u00ed se puede hacer referencia.     As\u00ed, si <code>I</code> es una interfaz y <code>C</code> es una clase que implementa la interfaz, se pueden declarar referencias al tipo <code>I</code> que apunten objetos de <code>C</code>:</p> Java<pre><code>I obj = new C (&lt;par\u00e1metros&gt;);\n</code></pre> <p>- Las interfaces pueden heredar de otras interfaces y, a diferencia de la derivaci\u00f3n de clases, pueden heredar de m\u00e1s de una interfaz.</p> <p>As\u00ed, si dise\u00f1amos la interfaz <code>Trabajador</code>, podemos hacer que las clases ya existentes (<code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> ...) la implementen y, por tanto, los objetos de estas clases, adem\u00e1s de ser objetos de las superclases respectivas, pasan a ser considerados objetos usuarios del tipo <code>Trabajador</code>. Con esta actuaci\u00f3n nos veremos obligados a implementar el m\u00e9todo <code>calculoImporteJubilacion()</code> a todas las clases que implementen la interfaz.</p> <p>Alguien no experimentado en la gesti\u00f3n de interfaces puede pensar: \u00bfpor qu\u00e9 tanto revuelo con las interfaces si hubi\u00e9ramos podido dise\u00f1ar directamente un m\u00e9todo llamado <code>calculoImporteJubilacion()</code> en las clases afectadas sin necesidad de definir ninguna interfaz?</p> <p>La respuesta radica en el hecho de que la declaraci\u00f3n de la interfaz lleva impl\u00edcita la declaraci\u00f3n del tipo <code>Trabajador</code> y, por tanto, podremos utilizar los objetos de todas las clases que implementen la interfaz en cualquier m\u00e9todo de cualquier clase que tenga alg\u00fan argumento referencia al tipo <code>Trabajador</code> como, por ejemplo, en un hipot\u00e9tico m\u00e9todo de una hipot\u00e9tica clase llamada <code>Hacienda</code>:</p> Java<pre><code>public void enviarBorradorIRPF(Trabajador t) {...}\n</code></pre> <p>Por el hecho de existir la interfaz <code>Trabajador</code>, todos los objetos de las clases que la implementan (<code>Profesor</code>, <code>Informatico</code>, <code>Hostelero</code> ...) se pueden pasar como par\u00e1metro en las llamadas al m\u00e9todo <code>enviarBorradorIRPF(Trabajador t)</code>.</p> <p>La sintaxis para declarar una interfaz es:</p> Java<pre><code>[public] interface &lt;NombreInterfaz&gt; [extends &lt;Nombreinterfaz1&gt;, &lt;Nombreinterfaz2&gt;...] {\n    &lt;CuerpoInterfaz&gt;\n}\n</code></pre> <p>Las interfaces tambi\u00e9n se pueden asignar a un paquete. La inexistencia del modificador de acceso p\u00fablico hace que la interfaz sea accesible a nivel del paquete.</p> <p>Para los nombres de las interfaces, se aconseja seguir el mismo criterio que para los nombres de las clases. </p> <p>Interfaces en la documentaci\u00f3n de Java</p> <p>En la documentaci\u00f3n de Java, las interfaces se identifican r\u00e1pidamente entre las clases porque est\u00e1n en cursiva.</p> <p>La sintaxis para declarar una clase que implemente una o m\u00e1s interfaces es:</p> Java<pre><code>[final] [public] class &lt;NombreClase&gt; [extends &lt;NombreClaseBase&gt;] implements &lt;NombreInterfaz1&gt;, &lt;NomInterfaz2&gt;... {\n    &lt;CuerpoDeLaClase&gt;\n}\n</code></pre> <p>Los m\u00e9todos de las interfaces a implementar en la clase deben ser obligatoriamente de acceso p\u00fablico.</p> <p>As\u00ed, por ejemplo:</p> Java<pre><code>public interface DiasSemana {\n    int LUNES = 1, MARTES = 2, MIERCOLES = 3, JUEVES = 4;\n    int VIERNES = 5, SABADO = 6, DOMINGO = 7;\n    String[] NOMBRES_DIAS = {\"\", \"lunes\", \"martes\", \"mi\u00e9rcoles\", \"jueves\", \"viernes\", \"s\u00e1bado\", \"domingo\"};\n}\n</code></pre> <p>Esta definici\u00f3n nos permite utilizar las constantes declaradas en cualquier clase que implemente la interfaz, de manera tan simple como:</p> Java<pre><code>System.out.println (DiasSemana.NOMBRES_DIAS[LUNES]);\n</code></pre> Ejemplo de dise\u00f1o de interfaz e implementaci\u00f3n en una clase <p>Se presentan un par de interfaces que incorporan datos (de tipo primitivo y de referencia en clase) y m\u00e9todos y una clase que las implementa. En la declaraci\u00f3n de la clase se ve que s\u00f3lo implementa la interfaz <code>B</code>, pero como esta interfaz deriva de la interfaz <code>A</code> resulta que la clase est\u00e1 implementando las dos interfaces.</p> Java<pre><code>import java.util.Date;\n\ninterface A {\n    Date ULTIMA_CREACION = new Date(0, 0, 1);\n    void metodoA();\n}\n\ninterface B extends A {\n    int VALOR_B = 20;\n    // 1 \u22121 \u22121900\n    void metodoB();\n}\n\npublic class Anexo5Interfaces implements B {\n    private long b;\n    private Date fechaCreacion = new Date();\n\n    public Anexo5Interfaces(int factor) {\n        b = VALOR_B * factor;\n        ULTIMA_CREACION.setTime(fechaCreacion.getTime());\n    }\n\n    @Override\n    public void metodoA() {\n        System.out.println(\"En metodoA, ULTIMA_CREACION = \" + ULTIMA_CREACION);\n    }\n\n    @Override\n    public void metodoB() {\n        System.out.println(\"En metodoB, b = \" + b);\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Inicialmente, ULTIMA_CREACION = \" + ULTIMA_CREACION);\n        Anexo5Interfaces obj = new Anexo5Interfaces(5);\n        obj.metodoA();\n        obj.metodoB();\n        A pa = obj;\n        B pb = obj;\n    }\n}\n</code></pre> <p>Si lo ejecutamos obtendremos:</p> Bash<pre><code>Inicialmente, ULTIMA_CREACION = Mon Jan 01 00:00:00 CET 1900\nEn metodoA, ULTIMA_CREACION = Thu Aug 26 16:09:47 CEST 2021\nEn metodoB, b = 100\n</code></pre> <p>El ejemplo sirve para ilustrar algunos puntos:</p> <ul> <li>Comprobamos que los datos miembro de las interfaces son <code>static</code>, ya que en el m\u00e9todo <code>main()</code> hacemos referencia al dato miembro <code>ULTIMA_CREACION</code> sin indicar ning\u00fan objeto de la clase.</li> <li>Si hubi\u00e9ramos intentado modificar los datos <code>VALOR_B</code> o <code>ULTIMA_CREACION</code> no habr\u00edamos podido porque es final, pero en cambio s\u00ed podemos modificar el contenido del objeto <code>Date</code> apuntado por <code>ULTIMA_CREACION</code>, que corresponde al momento temporal de la \u00faltima creaci\u00f3n de un objeto ya cada nueva creaci\u00f3n se actualiza su contenido.</li> <li>En las dos \u00faltimas instrucciones del m\u00e9todo <code>main()</code> vemos que podemos declarar variables <code>pa</code> y <code>pb</code> de las interfaces y utilizarlas para hacer referencia a objetos de la clase <code>EjemploInterfaz()</code>.</li> <li>\u00bfPara qu\u00e9 podr\u00eda servirnos <code>A pa = obj</code>?<ul> <li>Abstracci\u00f3n: Si solo estamos interesados en los m\u00e9todos y propiedades de la interfaz A, podemos declarar la referencia como tipo A. Esto oculta la implementaci\u00f3n espec\u00edfica de la clase y solo nos permite interactuar con los m\u00e9todos definidos en A.</li> <li>Flexibilidad: Si m\u00e1s adelante cambiamos la implementaci\u00f3n para que obj sea una instancia de otra clase que implementa A, no necesitaremos cambiar el c\u00f3digo que sigue utilizando <code>pa</code>, ya que <code>pa</code> es solo de tipo A y puede apuntar a cualquier objeto que implemente esa interfaz.</li> <li>Programaci\u00f3n Orientada a Interfaces: Es una buena pr\u00e1ctica programar en funci\u00f3n de interfaces en lugar de implementaciones concretas. Esto facilita la creaci\u00f3n de c\u00f3digo m\u00e1s modular y flexible, ya que las clases pueden intercambiarse f\u00e1cilmente siempre que implementen la misma interfaz.</li> </ul> </li> </ul>"},{"location":"ud08/ud0805/#funciones-lambda","title":"Funciones Lambda","text":"<p>Tal y como vimos en la unidad anterior, la implementaci\u00f3n de los m\u00e9todos de interfaces es muy susceptible de serlo a trav\u00e9s de funciones lambda.</p> <p>Imaginemos una clase <code>Persona</code>:</p> Java<pre><code>class Persona{\n    private String nombre;\n    private int edad;\n    ...\n}\n</code></pre> <p>Y un ArrayList <code>personas</code> formada por objetos de tipo <code>Persona</code>:</p> Java<pre><code>...\nArrayList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\npersonas.add(new Persona(\"Nacho\", 52));\npersonas.add(new Persona(\"David\", 47));\npersonas.add(new Persona(\"Pepe\", 42));\npersonas.add(new Persona(\"Maria\", 22));\npersonas.add(new Persona(\"Marta\", 4));\n...\n</code></pre> <p>Ahora queremos ordenar el <code>ArrayList</code> de <code>personas</code> de mayor a menor edad usando... Implementaci\u00f3n \"tradicional\" java: <code>Comparator</code> o<code>Comparable</code></p> Java<pre><code>...\nclass ComparadorPersona implements Comparator &lt;Persona&gt;{\n    @Override\n    public int compare(Persona p1, Persona p2){\n        return p2.getEdad() - p1.getEdad();\n    }\n}\n...\n</code></pre> Java<pre><code>...\npersonas.sort(new ComparadorPersona());\nfor (int i = 0; i &lt; personas.size(); i++){\n    System.out.println(personas.get(i));\n}\n...\n</code></pre> <p>Sin embargo, implementado con funciones Lambda seria...</p> Java<pre><code>...\npersonas.sort((p1, p2) -&gt; p2.getEdad() - p1.getEdad());\nfor (int i = 0; i &lt; personas.size(); i++){\n    System.out.println(personas.get(i));\n}\n...\n</code></pre>"},{"location":"ud08/ud0806/","title":"8.6 Polimorfismo","text":"<p>El polimorfismo es otro de los grandes pilares sobre los que se sustenta la Programaci\u00f3n Orientada a Objetos (junto con la encapsulaci\u00f3n y la herencia). Se trata nuevamente de otra forma m\u00e1s de establecer diferencias entre interfaz e implementaci\u00f3n, es decir, entre el qu\u00e9 y el c\u00f3mo. </p> <p>La encapsulaci\u00f3n te ha permitido agrupar caracter\u00edsticas (atributos) y comportamientos (m\u00e9todos) dentro de una misma unidad (clase), pudiendo darles un mayor o menor componente de visibilidad, y permitiendo separar al m\u00e1ximo posible la interfaz de la implementaci\u00f3n.</p> <p>Por otro lado la herencia te ha proporcionado la posibilidad de tratar a los objetos como pertenecientes a una jerarqu\u00eda de clases. Esta capacidad va a ser fundamental a la hora de poder manipular muchos posibles objetos de clases diferentes como si fueran de la misma clase (polimorfismo).</p> <p>El polimorfismo te va a permitir mejorar la organizaci\u00f3n y la legibilidad del c\u00f3digo as\u00ed como la posibilidad de desarrollar aplicaciones que sean m\u00e1s f\u00e1ciles de ampliar a la hora de incorporar nuevas funcionalidades. Si la implementaci\u00f3n y la utilizaci\u00f3n de las clases es lo suficientemente gen\u00e9rica y extensible ser\u00e1 m\u00e1s sencillo poder volver a este c\u00f3digo para incluir nuevos requerimientos.</p>"},{"location":"ud08/ud0806/#concepto-de-polimorfismo","title":"Concepto de polimorfismo","text":"<p>El polimorfismo consiste en la capacidad de poder utilizar una referencia a un objeto de una determinada clase como si fuera de otra clase (en concreto una subclase). Es una manera de decir que una clase podr\u00eda tener varias (poli) formas (morfismo).</p> <p>Un m\u00e9todo \"polim\u00f3rfico\" ofrece la posibilidad de ser distinguido (saber a qu\u00e9 clase pertenece) en tiempo de ejecuci\u00f3n en lugar de en tiempo de compilaci\u00f3n. Para poder hacer algo as\u00ed es necesario utilizar m\u00e9todos que pertenecen a una superclase y que en cada subclase se implementan de una forma en particular. En tiempo de compilaci\u00f3n se invocar\u00e1 al m\u00e9todo sin saber exactamente si ser\u00e1 el de una subclase u otra (pues se est\u00e1 invocando al de la superclase). S\u00f3lo en tiempo de ejecuci\u00f3n (una vez instanciada una u otra subclase) se conocer\u00e1 realmente qu\u00e9 m\u00e9todo (de qu\u00e9 subclase) es el que finalmente va a ser invocado.</p> <p>Esta forma de trabajar te va a permitir hasta cierto punto \"desentenderte\" del tipo de objeto espec\u00edfico (subclase) para centrarte en el tipo de objeto gen\u00e9rico (superclase). De este modo podr\u00e1s manipular objetos hasta cierto punto \"desconocidos\" en tiempo de compilaci\u00f3n y que s\u00f3lo durante la ejecuci\u00f3n del programa se sabr\u00e1 exactamente de qu\u00e9 tipo de objeto (subclase) se trata.</p> <p>A tener en cuenta</p> <p>El polimorfismo ofrece la posibilidad de que toda referencia a un objeto de una superclase pueda tomar la forma de una referencia a un objeto de una de sus subclases. Esto te va a permitir escribir programas que procesen objetos de clases que formen parte de la misma jerarqu\u00eda como si todos fueran objetos de sus superclases.</p> <p>A tener en cuenta</p> <p>El polimorfismo puede llevarse a cabo tanto con superclases (abstractas o no) como con interfaces.</p> Ejemplo de polimorfismo <p>Dada una superclase <code>ClaseX</code>, con un m\u00e9todo <code>m</code>, y dos subclases <code>ClaseA</code> y <code>ClaseB</code>, que redefinen ese m\u00e9todo <code>m</code>, podr\u00edas declarar un objeto <code>objetoX</code> de tipo <code>ClaseX</code> que durante la ejecuci\u00f3n podr\u00e1 ser de tipo <code>ClaseA</code> o de tipo <code>ClaseB</code> (algo desconocido en tiempo de compilaci\u00f3n). Esto significa que al invocarse el m\u00e9todo <code>m</code> de <code>ClaseX</code> (superclase), se estar\u00e1 en realidad invocando al m\u00e9todo <code>m</code> de <code>ClaseA</code> o de <code>ClaseB</code> (alguna de sus subclases). Por ejemplo:</p> Java<pre><code>// Declaraci\u00f3n de una referencia a un objeto de ClaseX\nClaseX objetoX; // Objeto de tipo X (superclase)\n...\n\n// Zona del programa donde se instancia un objeto de ClaseA (subclase) y se le asigna a la referencia objetoX.\n// La variable obj adquiere la forma de la subclase ClaseA.\nobjetoX = new ClaseA();\n...\n\n// Otra zona del programa.\n// Aqu\u00ed se instancia un objeto de ClaseB (subclase) y se le asigna a la referencia objetoX.\n// La variable obj adquiere la forma de la subclase ClaseB.\nobjetoX = new ClaseB();\n...\n\n// Zona donde se utiliza el m\u00e9todo m sin saber realmente qu\u00e9 subclase se est\u00e1 utilizando.\n// (S\u00f3lo se sabr\u00e1 durante la ejecuci\u00f3n del programa)\n\nobjetoX.m()\n// Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de ClaseA o de ClaseB).\n...\n</code></pre> <p>Imagina que est\u00e1s trabajando con las clases <code>Alumno</code> y <code>Profesor</code> y que en determinada zona del c\u00f3digo podr\u00edas tener objetos, tanto de un tipo como de otro, pero eso s\u00f3lo se sabr\u00e1 seg\u00fan vaya discurriendo la ejecuci\u00f3n del programa. En algunos casos, es posible que un determinado objeto pudiera ser de la clase <code>Alumno</code> y en otros de la clase <code>Profesor</code>, pero en cualquier caso ser\u00e1n objetos de la clase <code>Persona</code>. Eso significa que la llamada a un m\u00e9todo de la clase <code>Persona</code> (por ejemplo <code>devolverContenidoString</code>) en realidad ser\u00e1 en unos casos a un m\u00e9todo (con el mismo nombre) de la clase <code>Alumno</code> y, en otros, a un m\u00e9todo (con el mismo nombre tambi\u00e9n) de la clase <code>Profesor</code>. Esto ser\u00e1 posible hacerlo gracias a la ligadura din\u00e1mica.</p>"},{"location":"ud08/ud0806/#ligadura-dinamica","title":"Ligadura din\u00e1mica","text":"<p>La conexi\u00f3n que tiene lugar durante una llamada a un m\u00e9todo suele ser llamada ligadura (conexi\u00f3n o vinculaci\u00f3n que tiene lugar durante una llamada a un m\u00e9todo para saber qu\u00e9 c\u00f3digo debe ser ejecutado. Puede ser est\u00e1tica o din\u00e1mica, vinculaci\u00f3n o enlace (en ingl\u00e9s binding). Si esta vinculaci\u00f3n se lleva a cabo durante el proceso de compilaci\u00f3n, se le suele llamar ligadura est\u00e1tica, y la vinculaci\u00f3n que se produce en la llamada a un m\u00e9todo con la clase a la que pertenece ese m\u00e9todo se realiza en tiempo de compilaci\u00f3n. Es decir, que antes de generar el c\u00f3digo ejecutable se conoce exactamente el m\u00e9todo (a qu\u00e9 clase pertenece) que ser\u00e1 llamado, tambi\u00e9n conocido como vinculaci\u00f3n temprana. En los lenguajes tradicionales, no orientados a objetos, \u00e9sta es la \u00fanica forma de poder resolver la ligadura (en tiempo de compilaci\u00f3n). Sin embargo, en los lenguajes orientados a objetos existe otra posibilidad: la ligadura din\u00e1mica, y en donde la vinculaci\u00f3n que se produce en la llamada a un m\u00e9todo con la clase a la que pertenece ese m\u00e9todo se realiza en tiempo de ejecuci\u00f3n. Es decir, que al generar el c\u00f3digo ejecutable no se conoce exactamente el m\u00e9todo (a qu\u00e9 clase pertenece) que ser\u00e1 llamado. S\u00f3lo se sabr\u00e1 cuando el programa est\u00e9 en ejecuci\u00f3n. Tambi\u00e9n conocida como vinculaci\u00f3n tard\u00eda, enlace tard\u00edo o late binding.</p> <p>La ligadura din\u00e1mica hace posible que sea el tipo de objeto instanciado (obtenido mediante el constructor finalmente utilizado para crear el objeto) y no el tipo de la referencia (el tipo indicado en la declaraci\u00f3n de la variable que apuntar\u00e1 al objeto) lo que determine qu\u00e9 versi\u00f3n del m\u00e9todo va a ser invocada. El tipo de objeto al que apunta la variable de tipo referencia s\u00f3lo podr\u00e1 ser conocido durante la ejecuci\u00f3n del programa y por eso el polimorfismo necesita la ligadura din\u00e1mica. </p> Ejemplo de polimorfismo anterior <p>En el ejemplo anterior de la clase <code>ClaseX</code> y sus subclases <code>ClaseA</code> y <code>ClaseB</code>, la llamada al m\u00e9todo <code>m</code> s\u00f3lo puede resolverse mediante ligadura din\u00e1mica, pues es imposible saber en tiempo de compilaci\u00f3n si el m\u00e9todo <code>m</code> que debe ser invocado ser\u00e1 el definido en la subclase <code>ClaseA</code> o el definido en la subclase <code>ClaseB</code>:</p> Java<pre><code>//Llamada al m\u00e9todo m (sin saber si ser\u00e1 el m\u00e9todo m de ClaseA o de ClaseB). \nobjetoX.m() // Esta llamada ser\u00e1 resuelta en tiempo de ejecuci\u00f3n (ligadura din\u00e1mica)\n</code></pre> Revisa con cuidado el siguiente ejemplo 2 <p>Imag\u00ednate una clase que represente a un instrumento musical gen\u00e9rico (<code>Instrumento</code>) y dos subclases que representen tipos de instrumentos espec\u00edficos (por ejemplo <code>Flauta</code> y <code>Piano</code>). Todas las clases tendr\u00e1n un m\u00e9todo <code>tocarNota</code>, que ser\u00e1 espec\u00edfico para cada subclase.</p> <p>Haz un peque\u00f1o programa de ejemplo en Java que utilice el polimorfismo (referencias a la superclase que se convierten en instancias espec\u00edficas de subclases) y la ligadura din\u00e1mica (llamadas a un m\u00e9todo que a\u00fan no est\u00e1n resueltas en tiempo de compilaci\u00f3n) con estas clases que representan instrumentos musicales. Puedes implementar el m\u00e9todo <code>tocarNota</code> mediante la escritura de un mensaje en pantalla.</p> <p>SOLUCI\u00d3N La clase Instrumento podr\u00eda tener un \u00fanico m\u00e9todo (<code>tocarNota</code>):</p> Java<pre><code>public abstract class Instrumento {\n\npublic void tocarNota(String nota) {\n    System.out.format(\"Instrumento: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> <p>En el caso de las clases <code>Piano</code> y <code>Flauta</code> puede ser similar, heredando de <code>Instrumento</code> y redefiniendo el m\u00e9todo <code>tocarNota</code>:</p> Java<pre><code>public class Flauta extends Instrumento {\n\n@Override\npublic void tocarNota(String nota) {\n    System.out.format(\"Flauta: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> Java<pre><code>public class Piano extends Instrumento {\n\n@Override\npublic void tocarNota(String nota) {\n    System.out.format(\"Piano: tocar nota %s.\\n\", nota);\n}\n}\n</code></pre> <p>Creamos una clase para comprobar su funcionamiento <code>EjemploUso</code>:</p> Java<pre><code>import java.util.Scanner;\n\npublic class EjemploUso {\n\n    public static void main(String[] args) {\n        Scanner teclado = new Scanner(System.in);\n        System.out.print(\"Deseas un Piano o una Flauta (p o f)?: \");\n        char respuesta = teclado.nextLine().toLowerCase().charAt(0);\n\n        Instrumento instrumento1; // Ejemplo de objeto polim\u00f3rfico (podr\u00e1 ser Piano o Flauta)\n        if (respuesta == 'p') {\n            // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Piano)\n            instrumento1 = new Piano();\n        } else {\n            // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Flauta)\n            instrumento1 = new Flauta();\n        }\n        // Interpretamos una nota con el objeto instrumento1\n        // No sabemos si se ejecutar\u00e1 el m\u00e9todo tocarNota de Piano o de Flauta (depender\u00e1 de la ejecuci\u00f3n)\n        instrumento1.tocarNota(\"do\"); // Ejemplo de ligadura din\u00e1mica (tiempo de ejecuci\u00f3n)\n    }\n}\n</code></pre> <p>paso 1) A la hora de declarar una referencia a un objeto de tipo instrumento, utilizamos la superclase (Instrumento):</p> Java<pre><code>Instrumento instrumento1; // Ejemplo de objeto polim\u00f3rfico (podr\u00e1 ser Piano o Flauta)\n</code></pre> <p>paso 2) Sin embargo, a la hora de instanciar el objeto, utilizamos el constructor de alguna de sus subclases (Piano, Flauta, etc.): Java<pre><code>if (respuesta == 'p') {\n    // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Piano)\n    instrumento1 = new Piano();\n} else {\n    // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Flauta)\n    instrumento1 = new Flauta();\n}\n</code></pre></p> <p>paso 3) Finalmente, a la hora de invocar el m\u00e9todo <code>tocarNota</code>, no sabremos a qu\u00e9 versi\u00f3n (de qu\u00e9 subclase) de <code>tocarNota</code> se estar\u00e1 llamando, pues depender\u00e1 del tipo de objeto (subclase) que se haya instanciado. Se estar\u00e1 utilizando por tanto la ligadura din\u00e1mica: </p> Java<pre><code>// Interpretamos una nota con el objeto instrumento1\n// No sabemos si se ejecutar\u00e1 el m\u00e9todo tocarNota de Piano o de Flauta (depender\u00e1 de la ejecuci\u00f3n)\ninstrumento1.tocarNota(\"do\"); // Ejemplo de ligadura din\u00e1mica (tiempo de ejecuci\u00f3n)\n</code></pre>"},{"location":"ud08/ud0806/#limitaciones-de-la-ligadura-dinamica","title":"Limitaciones de la ligadura din\u00e1mica","text":"<p>Como has podido comprobar, el polimorfismo se basa en la utilizaci\u00f3n de referencias de un tipo m\u00e1s \"amplio\" (superclases) que los objetos a los que luego realmente van a apuntar (subclases). Ahora bien, existe una importante restricci\u00f3n en el uso de esta capacidad, pues el tipo de referencia limita cu\u00e1les son los m\u00e9todos que se pueden utilizar y los atributos a los que se pueden acceder.</p> <p>Restricci\u00f3n a tener en cuenta</p> <p>No se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. S\u00f3lo se pueden utilizar los miembros declarados en la superclase, aunque la definici\u00f3n que finalmente se utilice en su ejecuci\u00f3n sea la de la subclase.</p> Veamos un ejemplo <p>Si dispones de una clase <code>Profesor</code> que es subclase de <code>Persona</code> y declaras una variable como referencia un objeto de tipo <code>Persona</code>, aunque m\u00e1s tarde esa variable haga referencia a un objeto de tipo <code>Profesor</code> (subclase), los miembros a los que podr\u00e1s acceder sin que el compilador produzca un error ser\u00e1n los miembros de <code>Profesor</code> que hayan sido heredados de <code>Persona</code> (superclase). De este modo, se garantiza que los m\u00e9todos que se intenten llamar van a existir cualquiera que sea la subclase de <code>Persona</code> a la que se apunte desde esa referencia.</p> <p>En el ejemplo de las clases <code>Persona</code>, <code>Profesor</code> y <code>Alumno</code>, el polimorfismo nos permitir\u00eda declarar variables de tipo <code>Persona</code> y m\u00e1s tarde hacer con ellas referencia a objetos de tipo <code>Profesor</code> o <code>Alumno</code>, pero no deber\u00edamos intentar acceder con esa variable a m\u00e9todos que sean espec\u00edficos de la clase <code>Profesor</code> o de la clase <code>Alumno</code>, tan solo a m\u00e9todos que sabemos que van a existir seguro en ambos tipos de objetos (m\u00e9todos de la superclase <code>Persona</code>).</p> Revisa con cuidado el siguiente ejemplo <p>Haz un peque\u00f1o programa en Java en el que se declare una variable de tipo <code>Persona</code>, se pidan algunos datos sobre esa persona (nombre, apellidos y si es alumno o si es profesor), y se muestren nuevamente esos datos en pantalla, teniendo en cuenta que esa variable no puede ser instanciada como un objeto de tipo <code>Persona</code> (es una clase abstracta) y que tendr\u00e1s que instanciarla como <code>Alumno</code> o como <code>Profesor</code>. Recuerda que para poder recuperar sus datos necesitar\u00e1s hacer uso de la ligadura din\u00e1mica y que tan solo deber\u00edas acceder a m\u00e9todos que sean de la superclase.</p> <p>SOLUCI\u00d3N Si tuvi\u00e9ramos diferentes variables referencia a objetos de las clases <code>Alumno</code> y <code>Profesor</code> tendr\u00edas algo as\u00ed:</p> Java<pre><code>Alumno objA;\nProfesor objP;\n...\n// Si se dan ciertas condiciones el objeto ser\u00e1 de tipo Alumno y lo tendr\u00e1s en objA\nSystem.out.printf (\"Nombre: %s\\n\", objA.getNombre());\n// Si se dan otras condiciones el objeto ser\u00e1 de tipo Profesor y lo tendr\u00e1s en objP\nSystem.out.printf (\"Nombre: %s\\n\", objP.getNombre());\n</code></pre> <p>Pero si pudieras tratar de una manera m\u00e1s gen\u00e9rica la situaci\u00f3n, podr\u00edas intentar algo as\u00ed:</p> Java<pre><code>Persona obj;\n// Si se dan ciertas condiciones el objeto ser\u00e1 de tipo Alumno y por tanto lo instanciar\u00e1s como tal\nobj = new Alumno (&lt;par\u00e1metros&gt;);\n// Si se otras condiciones el objeto ser\u00e1 de tipo Profesor y por tanto lo instanciar\u00e1s como tal\nobj = new Profesor (&lt;par\u00e1metros&gt;);\n</code></pre> <p>De esta manera la variable obj podr\u00eda contener una referencia a un objeto de la superclase <code>Persona</code> de subclase <code>Alumno</code> o bien de subclase <code>Profesor</code> (polimorfismo).</p> <p>Esto significa que independientemente del tipo de subclase que sea (<code>Alumno</code> o <code>Profesor</code>), podr\u00e1s invocar a m\u00e9todos de la superclase <code>Persona</code> y durante la ejecuci\u00f3n se resolver\u00e1n como m\u00e9todos de alguna de sus subclases:</p> Java<pre><code>//En tiempo de compilaci\u00f3n no se sabr\u00e1 de qu\u00e9 subclase de Persona ser\u00e1 obj.\n//Habr\u00e1 que esperar la ejecuci\u00f3n para que el entorno lo sepa e invoque al m\u00e9todo adecuado.\nSystem.out.format(\"Contenido del objeto: %s\\n\", obj.devolverContenidoString());\n</code></pre> <p>Por \u00faltimo recuerda que debes de proporcionar constructores a las subclases <code>Alumno</code> y <code>Profesor</code> que sean \"compatibles\" con algunos de los constructores de la superclase <code>Persona</code>, pues al llamar a un constructor de una subclase, su formato debe coincidir con el de alg\u00fan constructor de la superclase (como debe suceder en general con cualquier m\u00e9todo que sea invocado utilizando la ligadura din\u00e1mica).</p> <p>Constructor \"compatible\" para <code>Alumno</code>:</p> Java<pre><code>public Alumno(String nombre, String apellidos, LocalDate fechaNacim){\n    super(nombre, apellidos, fechaNacim);\n}\n</code></pre> <p>y el constructor \"compatible\" para <code>Profesor</code>:</p> Java<pre><code>public Profesor(String nombre, String apellidos, LocalDate fechaNacim) {\n    super(nombre, apellidos, fechaNacim);\n}\n</code></pre> <p>Aqu\u00ed tienes el ejemplo completo de la clase <code>EjemploUso</code>:</p> Java<pre><code>import java.time.LocalDate;\nimport java.util.Scanner;\n\npublic class EjemploUso {\n\npublic static void main(String[] args) {\n    Persona obj;\n    Scanner teclado = new Scanner(System.in);\n    System.out.print(\"Deseas crear un Profesor o un Alumno ('p' o 'a')?: \");\n    char respuesta = teclado.nextLine().toLowerCase().charAt(0);\n\n    if (respuesta == 'a') {\n        // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Alumno)\n        obj = new Alumno(\"Alumno\", \"Apellidos\", LocalDate.of(1977, 3, 8));\n    } else {\n        // Ejemplo de objeto polim\u00f3rfico (en este caso va adquirir forma de Profesor)\n        obj = new Profesor(\"Profe\", \"Apellidos\", LocalDate.of(1977, 3, 8));\n    }\n    System.out.format(\"Contenido del objeto: %s\\n\", obj.devolverContenidoString());\n}\n}\n</code></pre>"},{"location":"ud08/ud0806/#interfaces-y-polimorfismo","title":"Interfaces y polimorfismo","text":"<p>Es posible tambi\u00e9n llevar a cabo el polimorfismo mediante el uso de interfaces. Un objeto puede tener una referencia cuyo tipo sea una interfaz, pero para que el compilador te lo permita, la clase cuyo constructor se utilice para crear el objeto deber\u00e1 implementar esa interfaz (bien por si misma o bien porque la implemente alguna superclase). Un objeto cuya referencia sea de tipo interfaz s\u00f3lo puede utilizar aquellos m\u00e9todos definidos en la interfaz, es decir, que no podr\u00e1n utilizarse los atributos y m\u00e9todos espec\u00edficos de su clase, tan solo los de la interfaz.</p> <p>Las referencias de tipo interfaz permiten unificar de una manera bastante estricta la forma de utilizarse de objetos que pertenezcan a clases muy diferentes (pero que todas ellas implementan la misma interfaz). De este modo podr\u00edas hacer referencia a diferentes objetos que no tienen ninguna relaci\u00f3n jer\u00e1rquica entre s\u00ed utilizando la misma variable (referencia a la interfaz). Lo \u00fanico que los distintos objetos tendr\u00edan en com\u00fan es que implementan la misma interfaz. </p> <p>A tener en cuenta</p> <p>En este caso s\u00f3lo podr\u00e1s llamar a los m\u00e9todos de la interfaz y no a los espec\u00edficos de las clases.</p> Ejemplo <p>Si ten\u00edas una variable de tipo referencia a la interfaz <code>Arrancable</code>, podr\u00edas instanciar objetos de tipo <code>Coche</code> o <code>Motosierra</code> y asignarlos a esa referencia (teniendo en cuenta que ambas clases no tienen una relaci\u00f3n de herencia). Sin embargo, tan solo podr\u00e1s usar en ambos casos los m\u00e9todos y los atributos de la interfaz <code>Arrancable</code> (por ejemplo <code>arrancar</code>) y no los de <code>Coche</code> o los de <code>Motosierra</code> (s\u00f3lo los gen\u00e9ricos, nunca los espec\u00edficos).</p> <p>En el caso de las clases <code>Persona</code>, <code>Alumno</code> y <code>Profesor</code>, podr\u00edas declarar, por ejemplo, variables del tipo <code>Imprimible</code>:</p> Java<pre><code>Imprimible obj; // Imprimible es una interfaz y no una clase\n</code></pre> <p>Con este tipo de referencia podr\u00edas luego apuntar a objetos tanto de tipo <code>Profesor</code> como de tipo <code>Alumno</code>, pues ambos implementan la interfaz <code>Imprimible</code>:</p> Java<pre><code>// En algunas circunstancias podr\u00eda suceder esto:\nobj = new Alumno (nombre, apellidos, fecha, grupo, nota); // Polimorfismo con interfaces\n...\n\n// En otras circunstancias podr\u00eda suceder esto:\nobj = new Profesor (nombre, apellidos, fecha, especialidad, salario); // Polimorfismo con interfaces\n...\n</code></pre> <p>Y m\u00e1s adelante hacer uso de la ligadura din\u00e1mica:</p> Java<pre><code>// Llamadas s\u00f3lo a m\u00e9todos de la interfaz\nString contenido;\ncontenido = obj.devolverContenidoString(); // Ligadura din\u00e1mica con interfaces\n</code></pre>"},{"location":"ud08/ud0806/#conversion-de-objetos","title":"Conversi\u00f3n de objetos","text":"<p>Como ya has visto, en principio no se puede acceder a los miembros espec\u00edficos de una subclase a trav\u00e9s de una referencia a una superclase. Si deseas tener acceso a todos los m\u00e9todos y atributos espec\u00edficos del objeto subclase tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting) que convierta la referencia m\u00e1s general (superclase) en la del tipo espec\u00edfico del objeto (subclase).</p> <p>Para que puedas realizar conversiones entre distintas clases es obligatorio que exista una relaci\u00f3n de herencia entre ellas (una debe ser clase derivada de la otra). Se realizar\u00e1 una conversi\u00f3n impl\u00edcita o autom\u00e1tica de subclase a superclase siempre que sea necesario, pues un objeto de tipo subclase siempre contendr\u00e1 toda la informaci\u00f3n necesaria para ser considerado un objeto de la superclase.</p> <p>Ahora bien, la conversi\u00f3n en sentido contrario (de superclase a subclase) debe hacerse de forma expl\u00edcita y seg\u00fan el caso podr\u00eda dar lugar a errores por falta de informaci\u00f3n (atributos) o de m\u00e9todos. En tales casos se produce una excepci\u00f3n de tipo <code>ClassCastException</code>. </p> <p>Por ejemplo, imagina que tienes una clase <code>Animal</code> y una clase <code>Marmota</code>, subclase de <code>Animal</code>:</p> Java<pre><code>class Animal {\n    public String nombre;\n}\n\nclass Marmota extends Animal {\n    public double peso;\n}\n</code></pre> <p>A continuaci\u00f3n declaras una variable referencia a la clase <code>Animal</code> (superclase) pero sin embargo le asignas una referencia a un objeto de la clase <code>Marmota</code> (subclase) haciendo uso del polimorfismo:</p> Java<pre><code>Animal obj; // Referencia a objetos de la clase Animal\nobj = new Marmota(); // Referencia a objetos clase Animal, pero apunta realmente a objeto clase Marmota (polimorfismo)\n</code></pre> <p>El objeto que acabas de crear como instancia de la clase <code>Marmota</code> (subclase de <code>Animal</code>) contiene m\u00e1s informaci\u00f3n que la que la referencia <code>obj</code> te permite en principio acceder sin que el compilador genere un error (pues es de clase <code>Animal</code>). En concreto los objetos de la clase <code>Marmota</code> disponen de <code>nombre</code> y <code>peso</code>, mientras que los objetos de la clase <code>Animal</code> s\u00f3lo de <code>nombre</code>. Para acceder a esa informaci\u00f3n adicional de la clase especializada (<code>peso</code>) tendr\u00e1s que realizar una conversi\u00f3n expl\u00edcita (casting):</p> Java<pre><code>// Casting del tipo Animal al tipo Marmota (funcionar\u00e1 bien porque el objeto es realmente del tipo B)\nSystem.out.printf (\"obj.peso=%f\\n\", ((Marmota) obj).peso);\n</code></pre> <p>Sin embargo si se hubiera tratado de una instancia de la clase <code>Animal</code> y hubieras intentado acceder al miembro <code>peso</code>, se habr\u00eda producido una excepci\u00f3n de tipo <code>ClassCastException</code>:</p> Java<pre><code>Animal obj; // Referencia a objetos de la clase Animal\nobj = new Animal (); // Referencia a objetos de la clase Animal, y apunta realmente a un objeto de la clase Animal\n\n// Casting del tipo Animal al tipo Besugo (puede dar problemas porque el objeto es realmente del tipo Animal):\n// Funciona (la clase Animal tiene nombre)\nSystem.out.printf (\"obj.nombre=%s\\n\", ((Marmota) obj).nombre);\n\n// \u00a1Error en ejecuci\u00f3n! (la clase Animal no tiene peso). Producir\u00e1 una ClassCastException.\nSystem.out.printf (\"obj.peso=%f\\n\", ((Marmota) obj).peso);\n</code></pre>"},{"location":"ud08/ud08ac/","title":"Actividades","text":""},{"location":"ud08/ud08ac/#ejercicios-herencia","title":"Ejercicios Herencia","text":""},{"location":"ud08/ud08ac/#ejercicio01","title":"Ejercicio01","text":"<p>paquete: <code>_01_centroestudios</code>.</p> <p>Dise\u00f1ar una jerarqu\u00eda de clases para modelizar las aulas de un centro de estudios.</p> <p>De un <code>Aula</code> se conoce el <code>c\u00f3digo</code> (num\u00e9rico), la <code>longitud</code> y la <code>anchura</code>. Se desea un m\u00e9todo que devuelva la capacidad del aula sabiendo que esta se calcula a partir de la superficie a raz\u00f3n de 1 alumnos por cada 1.4 metros cuadrados de superficie.</p> <p>Adem\u00e1s de las aulas, digamos normales, existen aulas de inform\u00e1tica y aulas de m\u00fasica. En las aulas de m\u00fasica se necesita conocer si tienen o no piano. De las aulas de inform\u00e1tica se conoce el n\u00famero de ordenadores y su capacidad no se calcula en funci\u00f3n de la superficie, sino a raz\u00f3n de dos alumnos por ordenador.</p> <p>Implementar el m\u00e9todo <code>toString</code> de cada una de las clases dise\u00f1adas para que devuelva:</p> <ul> <li> <p>En las aulas normales, el <code>c\u00f3digo</code> y la <code>superficie</code> y la <code>capacidad</code>.</p> </li> <li> <p>En las aulas de m\u00fasica e inform\u00e1tica el texto ir\u00e1 precedido por \"Aula de m\u00fasica\" o \"Aula de inform\u00e1tica\", seg\u00fan corresponda.</p> </li> </ul> <p>Crea tambi\u00e9n una clase <code>TestAula</code> para probar las clases generadas.</p>"},{"location":"ud08/ud08ac/#ejercicio02","title":"Ejercicio02","text":"<p>paquete: <code>_02_videojuegos</code></p> <p>Un sal\u00f3n de VideoJuegos dispone de ordenadores en los que los clientes pueden jugar. Adem\u00e1s de jugar en el establecimiento, la empresa alquila y vende juegos.</p> <p>a) Dise\u00f1ar la clase <code>Juego</code> siguiendo las siguientes especificaciones: </p> <ul> <li>Atributos protected: <code>titulo</code> (String), <code>fabricante</code> (String), <code>a\u00f1o</code> (int).</li> <li>Constructor <code>public Juego(String t, String f, int a)</code>.</li> <li>Consultores de todos los atributos.</li> <li><code>public String toString()</code>, que devuelve un String con los datos del Juego.</li> <li><code>public boolean equals(Object o)</code>: Dos juegos son iguales si tienen el mismo t\u00edtulo, fabricante y a\u00f1o.</li> <li><code>public int compareTo(Object o)</code>: Un juego es menor que otro si su t\u00edtulo es menor. A igual t\u00edtulo, si su fabricante es menor. A igual t\u00edtulo y fabricante, si su a\u00f1o es menor.</li> </ul> <p>b) Dise\u00f1ar las clases <code>JuegoEnAlquiler</code> y <code>JuegoEnVenta</code> (y otras si se considera oportuno), sabiendo que, adem\u00e1s de los atributos descritos anteriormente, tienen.</p> <ul> <li> <p><code>precio</code>.</p> </li> <li> <p><code>n\u00ba de copias disponibles</code>.</p> </li> <li> <p><code>JuegoEnAlquiler</code>.</p> <ul> <li> <p>tiene un atributo que indica el n\u00famero de d\u00edas que se alquila. </p> </li> <li> <p>constructor que recibe todos sus datos.</p> </li> <li> <p>tiene un m\u00e9todo <code>alquilar</code> que decrementa el n\u00famero de copias disponibles.</p> </li> <li>tiene un m\u00e9todo <code>devolver</code> que incrementa el n\u00famero de copias disponibles.</li> <li><code>toString()</code> devuelve todos los datos del <code>JuegoEnAlquiler</code>.</li> </ul> </li> <li> <p><code>JuegoEnVenta</code></p> <ul> <li>constructor que recibe todos sus datos.</li> <li>tiene un m\u00e9todo <code>vender</code>, que decrementa el n\u00famero de copias disponibles.</li> <li><code>toString()</code> devuelve todos los datos del <code>JuegoEnVenta</code>.</li> </ul> </li> </ul> <p>c) Crea tambi\u00e9n una clase <code>TestJuego</code> para probar objetos de las clases <code>JuegoEnAlquiler</code> y <code>JuegoEnVenta</code>.</p>"},{"location":"ud08/ud08ac/#ejercicio03","title":"Ejercicio03","text":"<p>paquete: <code>_03_fnmt</code></p> <p>La Fabrica Nacional de Moneda y Timbre quiere almacenar cierta informaci\u00f3n t\u00e9cnica del dinero (billetes y monedas) que emite. En concreto, le interesa:</p> <ul> <li>Valor: Valor de la moneda o billete, en euros. (<code>double</code>).</li> <li>A\u00f1o de emisi\u00f3n: A\u00f1o en que fue emitida la moneda o billete. (<code>int</code>).</li> <li>De las monedas, <ul> <li>Di\u00e1metro: Di\u00e1metro de la moneda, en mil\u00edmetros. (<code>double</code>).</li> <li>Peso: Peso de la moneda, en gramos (<code>double</code>).</li> </ul> </li> <li>De los billetes,<ul> <li>Altura del billete, en mm (<code>double</code>).</li> <li>Anchura del billete, en mm (<code>double</code>).</li> </ul> </li> </ul> <p>a) Dise\u00f1ar la clase abstracta <code>Dinero</code> y sus subclases <code>Moneda</code> y <code>Billete</code>, desarrollando:</p> <ul> <li>Constructores que reciban los datos necesarios para inicializar los atributos de la clase correspondiente.</li> <li><code>equals</code>: Dos monedas o billetes son iguales si tienen el mismo a\u00f1o de emisi\u00f3n y valor.</li> <li><code>compareTo</code>: Es menor (mayor) el de menor (mayor) a\u00f1o, a igual a\u00f1o es menor (mayor) el de menor (mayor) valor.</li> <li><code>toString</code>: Que muestre todos los datos del billete o moneda. Los billetes ir\u00e1n precedidos por el texto \"BILLETE\" y las monedas por el texto \"MONEDA\".</li> </ul> <p>b) Dise\u00f1ar la clase <code>TestDinero</code> para probar las clases desarrolladas. Crear objetos de las clases <code>Moneda</code> y <code>Billete</code> y mostrarlos por pantalla.</p>"},{"location":"ud08/ud08ac/#ejercicio04","title":"Ejercicio04","text":"<p>paquete: <code>_04_centrocomercial</code></p> <p>Un centro comercial quiere mostrar cierta informaci\u00f3n sobre los televisores que vende. Los televisores pueden ser de dos tipos: de tubo o LCD. En concreto, de cada televisor le interesa mostrar:</p> <ul> <li>Marca (<code>String</code>).</li> <li>Modelo (<code>String</code>).</li> <li>Precio en euros.</li> <li>Pulgadas de la pantalla (<code>double</code>).</li> <li>Resoluci\u00f3n: La resoluci\u00f3n se mide de forma distinta en los televisores de tubo que en los televisores LCD.</li> <li>En los TV de tubo se mide en lineas.</li> <li>En los TV LCD se mide pixels horizontales x pixels verticales.</li> </ul> <p>a) Dise\u00f1ar la clase <code>Televisor</code> con los atributos y m\u00e9todos comunes a los dos tipos de televisores y sus subclases <code>TVTubo</code> y <code>TVLCD</code> con los atributos y m\u00e9todos que sea necesario:</p> <ul> <li>Constructor de cada clase que permita inicializar todos los datos de la clase.</li> <li><code>equals</code>: Dos televisiones son iguales si son de la misma marca y modelo.</li> <li><code>compareTo</code>: Se considera menor (mayor) la de menor (mayor) marca. A igual marca, menor (mayor) la de menor (mayor) modelo.</li> <li><code>public String resulucion()</code>: Devuelve un texto con la resoluci\u00f3n del televisor, como por ejemplo \"420 lineas\" o \"800 x 600 pixels\" dependiendo del tipo de televisor.</li> <li><code>public String toString()</code>: Devuelve un texto con la marca, modelo, precio, pulgadas y resoluci\u00f3n.</li> </ul> <p>b) Dise\u00f1ar la clase <code>TestTV</code> para probar las clases dise\u00f1adas. Crear algunos objetos de las clases <code>TVTubo</code> y <code>TVLCD</code> y mostrarlos por pantalla.</p>"},{"location":"ud08/ud08ac/#ejercicio05","title":"Ejercicio05","text":"<p>paquete: <code>_05_preguntas</code></p> <p>De cada pareja de afirmaciones indica cu\u00e1l es la verdadera:</p> <p>a) Se dice que instanciamos una clase cuando creamos objetos de dicha clase.    b) Se dice que instanciamos una clase cuando creamos una subclase de dicha clase.</p> <p>c) Si una clase es abstracta no se puede instanciar.    d) Si una clase es abstracta no se puede heredar de ella.</p> <p>e) Una clase abstracta tiene que tener m\u00e9todos abstractos.  f) Una clase puede ser abstracta y no tener m\u00e9todos abstractos.</p> <p>g) Si una clase tiene m\u00e9todos abstractos tiene que ser abstracta.   h) Una clase puede tener m\u00e9todos abstractos y no ser abstracta.</p> <p>i) Si una clase es abstracta sus subclases no pueden ser abstractas.    j) Una clase abstracta puede tener subclases que tambi\u00e9n sean abstractas.</p> <p>k) Si un m\u00e9todo es abstracto en una clase, tiene que ser no abstracto en la subclase, o bien, la subclase tiene que ser tambi\u00e9n abstracta.  l) Si un m\u00e9todo es abstracto en una clase, no puede ser abstracto en las subclases.</p> <p>m) Si un m\u00e9todo se define final se tiene que reescribir en las subclases.   n) Si un m\u00e9todo se define final no se puede reescribir en las subclases.</p> <p>o) Una clase puede tener un m\u00e9todo final y no ser una clase final.  p) Si una clase tiene un m\u00e9todo final tiene que ser una clase final.</p> <p>q) Si una clase se define final no se pueden definir subclases de ella. r) Si una clase se define final no se puede instanciar.</p> <p>s) Un m\u00e9todo definido final y abstract resultar\u00eda in\u00fatil, puesto que nunca se podr\u00eda implementar en las subclases.  t) Un m\u00e9todo definido final y abstract podr\u00eda resultar \u00fatil.</p> <p>u) Una clase definida final y abstract resultar\u00eda in\u00fatil, puesto que no se podr\u00eda instanciar ni heredar de ella.    v) Una clase definida final y abstract podr\u00eda resultar \u00fatil.</p>"},{"location":"ud08/ud08ac/#ejercicio06","title":"Ejercicio06","text":"<p>paquete: <code>_06_preguntas2</code></p> <p>Dada las siguientes definiciones de clases:</p> Java<pre><code>public class Persona {\n    private String nombre;\n    private int edad;\n\n    public Persona (){\n        this.nombre = \"\";\n        this.edad = 0;\n    }\n\n    public Persona(String n, int e){\n        this.nombre = n;\n        this.edad = e;\n    }\n\n    public String toString(){\n        return \"Nombre: \" + nombre + \"Edad \" + edad;\n    }\n\n    public final String getNombre (){\n        return nombre;\n    }\n\n    public final int getEdad(){\n        return edad;\n    }\n}\n</code></pre> Java<pre><code>class Estudiante extends Persona {\n    private double creditos;\n\n    public Estudiante(String n, int e, double c){\n        super(n,e);\n        this.creditos = c;\n    }\n\n    public String toString(){\n        return super.toString() + \"\\nCreditos: \"+ creditos;\n    }\n}\n</code></pre> Java<pre><code>class Empleado extends Persona {\n    private double salario;\n\n    public Empleado(String n, int e, double s){\n        super(n,e);\n        this.salario = s;\n    }\n\n    public String toString(){\n        return \"Nombre: \"+ this.nombre +\n        \"\\nSalario: \"+ this.salario;\n    }\n}\n</code></pre> Java<pre><code>class Test{\n    public static void main(String[] args) {\n        Estudiante e = new Estudiante(\"pepe\",18,100);\n        System.out.println(e.toString());\n    }\n}\n</code></pre> <p>Responde a las siguientes cuestiones justificando las respuestas. </p> <p>\u200b   a) \u00bfEs necesario el uso de <code>this</code> en el constructor de la clase <code>Estudiante</code>?</p> <p>\u200b   b) \u00bfEs necesario el uso de <code>super</code> en el m\u00e9todo <code>toString</code> de la clase <code>Estudiante</code>?</p> <p>\u200b   c) Si quit\u00e1semos el constructor de la clase <code>Estudiante</code> \u00bfdar\u00eda un error de compilaci\u00f3n?</p> <p>\u200b   d) En el m\u00e9todo <code>toString</code> de la clase <code>Empleado</code> \u00bfpor qu\u00e9 es incorrecto el acceso que se hace al atributo <code>nombre</code>? \u00bfC\u00f3mo se tendr\u00eda que definir <code>nombre</code> en la clase <code>Persona</code> para evitar el error?</p> <p>\u200b   e) \u00bfQu\u00e9 consecuencia tiene que algunos m\u00e9todos de la clase <code>Persona</code> se hayan definido <code>final</code>?</p> <p>\u200b   f) Si el m\u00e9todo <code>toString</code> no se hubiera definido en ninguna de las tres clases \u00bfdar\u00eda error el <code>sout</code> del m\u00e9todo <code>main</code>?</p>"},{"location":"ud08/ud08ac/#ejercicios-polimorfismo","title":"Ejercicios Polimorfismo","text":""},{"location":"ud08/ud08ac/#ejercicio07","title":"Ejercicio07","text":"<p>paquete: <code>_07_obra</code></p> <p>Dada la siguiente jerarqu\u00eda de clases:</p> Java<pre><code>public interface Montador{\n    void montar(String x);\n    void desmontar(String x);\n}\n\npublic class Obrero{\n    public Obrero(){System.out.println(\"Se crea Obrero\");}\n    public void saludar(){System.out.println(\"Hola, soy Obrero\");}\n    ...\n}\n\npublic class Carpintero extends Obrero implements Montador {\n    public Carpintero(){System.out.println(\"Se crea Carpintero\");}\n    public void montar(String x) {System.out.println(\"Montando \" + x);}\n    public void desmontar(String x) {System.out.println(\"Desmontando \" + x);}\n    public void clavar() {...}\n}\n\npublic class Alba\u00f1il extends Obrero {\n    public Alba\u00f1il() {\n        super();\n        System.out.println(\"Se crea Alba\u00f1il\");\n    }\n    public void levantarMuro(){ \n        System.out.println(\"Levantando muro \u2026\");\n    }\n}\n</code></pre> <p>a) Indicar qu\u00e9 l\u00edneas del siguiente fragmento de programa producir\u00e1n errores de compilaci\u00f3n,</p> Java<pre><code>public static void main(String[] args){\n    Montador m1 = new Carpintero();\n    Montador m2 = new Alba\u00f1il();\n    Obrero o1 = new Carpintero();\n    Obrero o2 = new Alba\u00f1il();\n    o1.montar(\"Mesa\");\n    o2.levantarMuro();\n    m1.saludar();\n    m1.montar(\"Silla\");\n    ((Alba\u00f1il)o2).levantarMuro();\n    ((Alba\u00f1il)o1).levantarMuro();\n}\n</code></pre> <p>b) Una vez eliminadas las l\u00edneas con error, indicar cu\u00e1l ser\u00eda la salida por pantalla del programa.</p> <p>c) \u00bfSer\u00eda correcta la instrucci\u00f3n siguiente?\"</p> Java<pre><code>Alba\u00f1il a = new Alba\u00f1il();\nSystem.out.println(a.toString());\n</code></pre>"},{"location":"ud08/ud08ac/#ejercicio08","title":"Ejercicio08","text":"<p>paquete: <code>_08_preguntas3</code></p> <p>Las clases siguientes implementan una jerarqu\u00eda de herencia</p> Java<pre><code>class Base {\n    String metodo1() {return \"Base.metodo1()\";}\n    String metodo2(String s) {return \"Base.metodo1(\" + s + \")\";}\n}\n\npublic interface TipoI{\n    String metodoIn2(String s);\n    String metodoIn3();\n}\n\nclass Derivada extends Base implements TipoI{\n    public String metodoIn2(String s) {return \"Derivada.metodoIn2()\";}\n    public String metodoIn3() {return \"Derivada.metodoIn3()\";}\n    String metodo1() {return \"Derivada.metodo1()\";}\n}\n\nclass Derivada2 extends Derivada{\n    String metodo2 (String s) {return \"Derivada2.metodo2(\" + s + \")\";}\n    String metodo4() {return \"Derivada2.metodo4()\";}\n}\n</code></pre> <p>Sea la clase <code>CuestionHerencia</code> que usa las anteriores:</p> Java<pre><code>public class CuestionHerencia{\n    public static void main (String a[]){\n        String tmp;\n        Derivada derivada;\n        Derivada2 derivada2;\n        Base base;\n\n        derivada2 = new Derivada2(); \n        base = derivada2;\n        tmp = derivada2.metodo1(); \n        System.out.println(\"1) \"+tmp);\n        tmp = derivada2.metodoIn2(\"EDA!!\"); \n        System.out.println(\"2) \"+tmp);\n        tmp = base.metodo1();\n        System.out.println(\"3) \"+tmp);\n        tmp = base.metodo2(\"EDA!!\"); \n        System.out.println(\"4) \"+tmp);\n        tmp = derivada2.metodoIn3();\n        System.out.println(\"5) \"+tmp);\n        tmp = derivada2.metodo4();\n        System.out.println(\"6) \"+tmp);\n        tmp = base.metodo3();\n        System.out.println(\"7) \"+tmp);\n        derivada = new Derivada();\n        derivada2 = new Derivada2();\n        base = new Base();\n        Distinta ref = new Distinta();\n        tmp = ref.prueba(derivada2); \n        System.out.println(\"8) \"+tmp);\n        tmp = ref.prueba(derivada); \n        System.out.println(\"9) \"+tmp);\n        tmp = ref.prueba(base); \n        System.out.println(\"10) \"+tmp); \n    }\n}\n</code></pre> <p>\u200b   a) Se\u00f1alar los errores existentes.</p> <p>\u200b   b) Una vez corregido el programa, escribir la salida por pantalla resultado de su ejecuci\u00f3n.</p>"},{"location":"ud08/ud08ac/#ejercicio09","title":"Ejercicio09","text":"<p>paquete: <code>_09_supermercado</code></p> <p>Pr\u00e1ctica con interfaces y polimorfismo.</p> <p>Supermercado. Creaci\u00f3n de Interfaces </p> <p>Sup\u00f3n que debe crear distintas clases Java para describir los productos que vende un supermercado. </p> <p>Para unificar el c\u00f3digo de los distintos programadores del equipo debes crear las siguientes Interfaces Java para describir algunas caracter\u00edsticas de los productos:</p> <ul> <li>Interfaz <code>EsLiquido</code> : Esta interfaz indica que los objetos creados a partir de la clase ser\u00e1n l\u00edquidos, y tendr\u00e1 los siguientes m\u00e9todos: </li> </ul> Java<pre><code>public void setVolumen(double v); \npublic double getVolumen(); \npublic void setTipoEnvase(String env); \npublic String getTipoEnvase();\n</code></pre> <ul> <li>Interfaz <code>EsAlimento</code> : Esta interfaz indica que los objetos creados a partir de la clase ser\u00e1n alimentos, y tendr\u00e1 los siguientes m\u00e9todos: </li> </ul> Java<pre><code>public void setCaducidad(LocalDate fc); \npublic LocalDate getCaducidad(); \npublic int getCalorias();\n</code></pre> <ul> <li>Interfaz <code>ConDescuento</code> : Esta interfaz indicar\u00e1 que el producto tiene descuento e incluir\u00e1 los siguientes m\u00e9todos: </li> </ul> Java<pre><code>public void setDescuento(double des); \npublic double getDescuento(); \npublic double getPrecioDescuento();\n</code></pre> <p>Creaci\u00f3n de clases de productos. Se pide que programes las siguientes clases de productos, implementando las interfaces que sean necesarias.</p> <p>a) Clase <code>Detergente</code> : Define una botella de detergente (debes tener en cuenta que este producto puede tener descuento).</p> <p>Sus propiedades principales ser\u00e1n: marca (String) y precio (double).</p> <p>Incluye otras propiedades seg\u00fan sea necesario a la hora de implementar las interfaces. </p> <ul> <li>Constructor: programa un constructor que reciba como par\u00e1metros una marca y un precio. </li> <li>M\u00e9todos set y get: programa m\u00e9todos set y get para la marca y el precio.</li> <li>M\u00e9todos de las interfaces: implementa los m\u00e9todos de las interfaces. </li> <li>M\u00e9todo <code>toString</code>: programa el m\u00e9todo toString con todas las caracter\u00edsticas del producto. </li> </ul> <p>b) Clase <code>Cereales</code> : Define el producto caja de cereales (este producto no tiene descuentos).</p> <p>Las propiedades del producto ser\u00e1n <code>marca</code>, <code>precio</code> y <code>tipo</code> de cereal (String).</p> <ul> <li>Programa un constructor que reciba como par\u00e1metros las tres propiedades anteriores. </li> <li>Programa los m\u00e9todos set y get para dichas propiedades. </li> <li>Implementa los m\u00e9todos de las interfaces implementadas (si es necesario a\u00f1ade m\u00e1s propiedades a la clase).</li> </ul> <p>A tener en cuenta</p> <p>Las calor\u00edas ser\u00e1n las siguientes:     - 5 si el cereal es espelta,  - 8 si es ma\u00edz,  - 12 si es trigo, y  - 15 en los dem\u00e1s casos.</p> <ul> <li>Programa el m\u00e9todo <code>toString</code> para devolver una cadena con todas las caracter\u00edsticas del producto.</li> </ul> <p>c) Clase <code>Vino</code> : Esta clase describir\u00e1 el producto botella de vino (este producto es susceptible de tener descuento).</p> <p>El producto tendr\u00e1 como propiedades la marca, el tipo de vino, los grados de alcohol y el precio.</p> <ul> <li>Programa al igual que los productos anteriores un constructor con estas cuatro propiedades como par\u00e1metros.</li> <li>Programa tambi\u00e9n los m\u00e9todos set, get, toString y los m\u00e9todos de las interfaces. A\u00f1ada nuevas propiedades si es necesario. </li> </ul> <p>A tener en cuenta</p> <p>Las calor\u00edas se calcular\u00e1n multiplicando por 10 la graduaci\u00f3n alcoh\u00f3lica.</p> <p>d ) Programa de <code>TestSupermercado</code> : Realiza un programa de prueba donde crees varios productos de cada clase. Haz un ejemplo de polimorfismo creando un ArrayList de productos alimenticios y calculando la suma de sus calor\u00edas.</p>"},{"location":"ud08/ud08ac/#ejercicio10","title":"Ejercicio10","text":"<p>paquete: <code>_10_facultad</code></p> <p>Realizar una aplicaci\u00f3n para la gesti\u00f3n de la informaci\u00f3n de las personas vinculadas a una Facultad, que se pueden clasificar en tres tipos: estudiantes, profesores y personal de servicio.</p> <p>A continuaci\u00f3n, se detalla qu\u00e9 tipo de informaci\u00f3n debe gestionar esta aplicaci\u00f3n:</p> <ul> <li>Por cada <code>Persona</code>, se debe conocer, al menos, su nombre y apellidos, su n\u00famero de identificaci\u00f3n y su estado civil.</li> <li>Con respecto a los <code>Empleados</code>, sean del tipo que sean, hay que saber su a\u00f1o de incorporaci\u00f3n a la facultad y qu\u00e9 n\u00famero de despacho tienen asignado.</li> <li>En cuanto a los <code>Estudiantes</code>, se requiere almacenar el curso en el que est\u00e1n matriculados.</li> <li>Por lo que se refiere a los <code>Profesores</code>, es necesario gestionar a qu\u00e9 departamento pertenecen (lenguajes, matem\u00e1ticas, arquitectura, ...).</li> <li>Sobre el <code>Personal de servicio</code>, hay que conocer a qu\u00e9 secci\u00f3n est\u00e1n asignados (biblioteca, decanato, secretar\u00eda, ...).</li> </ul> <p>El ejercicio consiste, en primer lugar, en definir la jerarqu\u00eda de clases de esta aplicaci\u00f3n. A continuaci\u00f3n, debe programar las clases definidas en las que, adem\u00e1s de los constructores, hay que desarrollar los m\u00e9todos correspondientes a las siguientes acciones:</p> <ul> <li>Cambio del estado civil de una persona.</li> <li>Reasignaci\u00f3n de despacho a un empleado.</li> <li>Matriculaci\u00f3n de un estudiante en un nuevo curso.</li> <li>Cambio de departamento de un profesor.</li> <li>Traslado de secci\u00f3n de un empleado del personal de servicio.</li> <li>Imprimir toda la informaci\u00f3n de cada tipo de individuo.</li> </ul> <p>En el m\u00e9todo <code>main</code> crear un array de personas. Crear diferentes instancias de las subclases e insertarlas en el array. Probar los diferentes m\u00e9todos desarrollados.</p>"},{"location":"ud08/ud08ac/#ejercicio11","title":"Ejercicio11","text":"<p>paquete: <code>_11_trabajadores</code></p> <p>Crea una clase <code>Empleado</code> y una subclase <code>Encargado</code>. Los encargados reciben un 10% m\u00e1s de sueldo base que un empleado normal. Implementa dichas clases en el paquete objetos y sobrescribe el m\u00e9todo <code>getSueldo()</code> para ambas clases.</p>"},{"location":"ud08/ud08ac/#ejercicio12","title":"Ejercicio12","text":"<p>paquete: <code>_12_juego</code></p> <p>a) Crear la clase <code>Dado</code>, la cual desciende de la clase <code>Sorteo</code>. La clase <code>Dado</code>, en la llamada <code>lanzar()</code> mostrar\u00e1 un n\u00famero aleatorio del 1 al 6. </p> <p>b) Crear la clase <code>Moneda</code>, la cual desciende de la clase <code>Sorteo</code>. Esta clase en la llamada al m\u00e9todo <code>lanzar()</code> mostrar\u00e1 las palabras cara o cruz. </p> <p>c) Realizar una clase con un m\u00e9todo <code>main</code> que compruebe todo lo realizado.</p>"},{"location":"ud08/ud08ac/#ejercicio13","title":"Ejercicio13","text":"<p>paquete: <code>_13_alimento</code></p> <p>a) Realiza una clase <code>Huevo</code> con un atributo <code>tama\u00f1o</code> (<code>S</code>, <code>M</code>, <code>L</code>, <code>XL</code>) con el m\u00e9todo <code>toString</code>. </p> <p>b) La clase <code>Huevo</code> est\u00e1 compuesta por dos clases internas, una <code>Clara</code> y otra <code>Yema</code>. Ambas clases tienen un atributo <code>color</code> y el m\u00e9todo <code>toString</code>. </p> <p>c) Realiza un m\u00e9todo <code>main</code> en el que se cree un objeto de tipo <code>Huevo</code>, <code>Clara</code> y <code>Yema</code>, se le asigne valor a sus atributos y se muestren los valores.</p>"},{"location":"ud08/ud08ac/#ejercicios-lionel","title":"Ejercicios Lionel","text":""},{"location":"ud08/ud08ac/#ejercicio14-astros","title":"Ejercicio14 - Astros","text":"<p>paquete: <code>_14_astros</code></p> <p>Define una jerarqu\u00eda de clases que permita almacenar datos sobre los planetas y sat\u00e9lites (lunas) que forman parte del sistema solar.</p> <p>Algunos atributos que necesitaremos almacenar son: </p> <ul> <li>Masa del cuerpo.</li> <li>Di\u00e1metro medio.</li> <li>Per\u00edodo de rotaci\u00f3n sobre su propio eje.</li> <li>Per\u00edodo de traslaci\u00f3n alrededor del cuerpo que orbitan.</li> <li>Distancia media a ese cuerpo.</li> <li>etc.</li> </ul> <p>Define las clases necesarias conteniendo: </p> <ul> <li>Constructores. </li> <li>M\u00e9todos para recuperar y almacenas atributos.</li> <li>M\u00e9todo para mostrar la informaci\u00f3n del objeto. </li> </ul> <p>Define un m\u00e9todo, que dado un objeto del sistema solar (planeta o sat\u00e9lite), imprima toda la informaci\u00f3n que se dispone sobre el mismo (adem\u00e1s de su lista de sat\u00e9lites si los tuviera).</p> <p>El diagrama UML ser\u00eda:</p> <p></p> <p>Posible soluci\u00f3n</p> <p>Una posible soluci\u00f3n ser\u00eda crear una lista de objetos, insertar los planetas y sat\u00e9lites (directamente mediante c\u00f3digo o solicit\u00e1ndolos por pantalla) y luego mostrar un peque\u00f1o men\u00fa que permita al usuario imprimir la informaci\u00f3n del astro que elija.</p>"},{"location":"ud08/ud08ac/#ejercicio15-mascotas","title":"Ejercicio15 - Mascotas","text":"<p>paquete: <code>_15_mascotas</code></p> <p>Implementa una clase llamada <code>Inventario</code> que utilizaremos para almacenar referencias a todos los animales existentes en una tienda de mascotas. </p> <p>Esta clase debe cumplir con los siguientes requisitos: </p> <ul> <li>En la tienda existir\u00e1n 4 tipos de animales: perros, gatos, loros y canarios. </li> <li>Los animales deben almacenarse en un <code>ArrayList</code> privado dentro de la clase <code>Inventario</code>. </li> <li>La clase debe permitir realizar las siguientes acciones:<ul> <li>Mostrar la lista de animales (solo tipo y nombre, 1 l\u00ednea por animal).</li> <li>Mostrar todos los datos de un animal concreto.</li> <li>Mostrar todos los datos de todos los animales.</li> <li>Insertar animales en el inventario. </li> <li>Eliminar animales del inventario. </li> <li>Vaciar el inventario. </li> </ul> </li> </ul> <p>Implementa las dem\u00e1s clases necesarias para usar la clase <code>Inventario</code>.</p> <p>El diagrama UML ser\u00eda:</p> <p></p>"},{"location":"ud08/ud08ac/#ejercicio16-banco","title":"Ejercicio16 - Banco","text":"<p>paquete: <code>_16_banco</code></p> <p>Vamos a hacer una aplicaci\u00f3n que simule el funcionamiento de un banco.</p> <p>Crea una clase <code>CuentaBancaria</code> con los atributos: iban y saldo. Implementa m\u00e9todos para:</p> <ul> <li>Consultar los atributos. </li> <li>Ingresar dinero.</li> <li>Retirar dinero.</li> <li>Traspasar dinero de una cuenta a otra.</li> </ul> <p>Para los tres \u00faltimos m\u00e9todos puede utilizarse internamente un m\u00e9todo privado m\u00e1s general llamado <code>a\u00f1adir(...)</code> que a\u00f1ada una cantidad (positiva o negativa) al saldo.</p> <p>Tambi\u00e9n habr\u00e1 un atributo com\u00fan a todas las instancias llamado interesAnualBasico, que en principio puede ser constante.</p> <p>La clase tiene que ser abstracta y debe tener un m\u00e9todo <code>calcularIntereses()</code> que se dejar\u00e1 sin implementar.</p> <p>Tambi\u00e9n puede ser \u00fatil implementar un m\u00e9todo para mostrar los datos de la cuenta.</p> <p>De esta clase heredar\u00e1n dos subclases: <code>CuentaCorriente</code> y <code>CuentaAhorro</code>. La diferencia entre ambas ser\u00e1 la manera de calcular los intereses:</p> <ul> <li>A la primera se le incrementar\u00e1 el saldo teniendo en cuenta el inter\u00e9s anual b\u00e1sico.</li> <li>La segunda tendr\u00e1 una constante de clase llamada saldoMinimo. Si no se llega a este saldo el inter\u00e9s ser\u00e1 la mitad del inter\u00e9s b\u00e1sico. Si se supera el saldo m\u00ednimo el inter\u00e9s aplicado ser\u00e1 el doble del inter\u00e9s anual b\u00e1sico.</li> </ul> <p>Implementa una clase principal con funci\u00f3n main para probar el funcionamiento de las tres clases: Crea varias cuentas bancarias de distintos tipos, pueden estar en un ArrayList si lo deseas; prueba a realizar ingresos, retiradas y transferencias; calcula los intereses y mu\u00e9stralos por pantalla; etc.</p> <p>El diagrama UML ser\u00eda:</p> <p></p>"},{"location":"ud08/ud08ac/#ejercicio17-empresa-y-empleados","title":"Ejercicio17 - Empresa y empleados","text":"<p>paquete: <code>_17_empresaempleados</code></p> <p>Vamos a implementar dos clases que permitan gestionar datos de empresas y sus empleados.</p> <p>Los empleados tienen las siguientes caracter\u00edsticas:</p> <ul> <li>Un empleado tiene nombre, DNI, sueldo bruto (mensual), edad, tel\u00e9fono y direcci\u00f3n.</li> <li>El nombre y DNI de un empleado no pueden variar.</li> <li>Es obligatorio que todos los empleados tengan al menos definido su nombre, DNI y el sueldo bruto. Los dem\u00e1s datos no son obligatorios.</li> <li>Ser\u00e1 necesario un m\u00e9todo para imprimir por pantalla la informaci\u00f3n de un empleado.</li> <li>Ser\u00e1 necesario un m\u00e9todo para calcular el sueldo neto de un empleado. El sueldo neto se calcula descontando del sueldo bruto un porcentaje que depende del IRPF. El porcentaje del IRPF depende del sueldo bruto anual del empleado (sueldo bruto x 12 pagas).(*)</li> </ul> Sueldo bruto anual IRPF Inferior a 12.000 \u20ac 20% De 12.000 a 25.000 \u20ac 30% M\u00e1s de 25.000 \u20ac 40% <p>Por ejemplo, un empleado con un sueldo bruto anual de 17.000 \u20ac tendr\u00e1 un 30% de IRPF. Para calcular su sueldo neto mensual se descontar\u00e1 un 30% a su sueldo bruto mensual.</p> <p>Las empresas tienen las siguientes caracter\u00edsticas:</p> <ul> <li>Una empresa tiene nombre y CIF (datos que no pueden variar), adem\u00e1s de tel\u00e9fono, direcci\u00f3n y empleados. Cuando se crea una nueva empresa esta carece de empleados.</li> <li>Ser\u00e1n necesarios m\u00e9todos para:</li> <li>A\u00f1adir y eliminar empleados a la empresa.</li> <li>Mostrar por pantalla la informaci\u00f3n de todos los empleados.</li> <li>Mostrar por pantalla el DNI, sueldo bruto y neto de todos los empleados.</li> <li>Calcular la suma total de sueldos brutos de todos los empleados.</li> <li>Calcular la suma total de sueldos netos de todos los empleados.</li> </ul> <p>Implementa las clases Empleado y Empresa con los atributos oportunos, un constructor, los getters/setters oportunos y los m\u00e9todos indicados. Puedes a\u00f1adir m\u00e1s m\u00e9todos si lo ves necesario. Estas clases no deben realizar ning\u00fan tipo de entrada por teclado.</p> <p>Implementa tambi\u00e9n una clase Programa con una funci\u00f3n main para realizar pruebas: Crear una o varias empresas, crear empleados, a\u00f1adir y eliminar empleados a las empresas, listar todos los empleados, mostrar el total de sueldos brutos y netos, etc.</p> <p>(*)</p> <p>El IRPF realmente es m\u00e1s complejo pero se ha simplificado para no complicar demasiado este ejercicio.</p>"},{"location":"ud08/ud08ac/#ejercicio18-vehiculos","title":"Ejercicio18 - Veh\u00edculos","text":"<p>paquete: <code>_18_vehiculos</code></p> <p>Aconsejable</p> <p>Realizar el dise\u00f1o UML antes de empezar a programar.</p> <p>Debes crear varias clases para un software de una empresa de transporte. Implementa la jerarqu\u00eda de clases necesaria para cumplir los siguientes criterios:</p> <ul> <li>Los veh\u00edculos de la empresa de transporte pueden ser terrestres, acu\u00e1ticos y a\u00e9reos. Los veh\u00edculos terrestres pueden ser coches y motos. Los veh\u00edculos acu\u00e1ticos pueden ser barcos y submarinos. Los veh\u00edculos a\u00e9reos pueden ser aviones y helic\u00f3pteros.</li> <li>Todos los veh\u00edculos tienen matr\u00edcula y modelo (datos que no pueden cambiar). La matr\u00edcula de los coches terrestres deben estar formadas por 4 n\u00fameros y 3 letras. La de los veh\u00edculos acu\u00e1ticos por entre 3 y 10 letras. La de los veh\u00edculos a\u00e9reos por 4 letras y 6 n\u00fameros.</li> <li>Los veh\u00edculos terrestres tienen un n\u00famero de ruedas (dato que no puede cambiar).</li> <li>Los veh\u00edculos acu\u00e1ticos tienen eslora (dato que no puede cambiar).</li> <li>Los veh\u00edculos a\u00e9reos tienen un n\u00famero de asientos (dato que no puede cambiar).</li> <li>Los coches pueden tener aire acondicionado o no tenerlo.</li> <li>Las motos tienen un color.</li> <li>Los barcos pueden tener motor o no tenerlo.</li> <li>Los submarinos tienen una profundidad m\u00e1xima.</li> <li>Los aviones tienen un tiempo m\u00e1ximo de vuelo.</li> <li>Los helic\u00f3pteros tienen un n\u00famero de h\u00e9lices.</li> <li>No se permiten veh\u00edculos gen\u00e9ricos, es decir, no se deben poder instanciar objetos que sean veh\u00edculos sin m\u00e1s. Pero debe ser posible instanciar veh\u00edculos terrestres, acu\u00e1ticos o a\u00e9reos gen\u00e9ricos (es decir, que no sean coches, motos, barcos, submarinos, aviones o helic\u00f3pteros).</li> <li>El dise\u00f1o debe obligar a que todas las clases de veh\u00edculos tengan un m\u00e9todo imprimir() que imprima por pantalla la informaci\u00f3n del veh\u00edculo en una sola l\u00ednea.</li> </ul> <p>Implementa todas las clases necesarias con: atributos, constructor con par\u00e1metros, getters/setters y el m\u00e9todo imprimir. Utiliza abstracci\u00f3n y herencia de la forma m\u00e1s apropiada.</p> <p>Implementa tambi\u00e9n una clase Programa para hacer algunas pruebas: Instancia varios veh\u00edculos de todo tipo (coches, motos, barcos, submarinos, aviones y helic\u00f3pteros) as\u00ed como veh\u00edculos genericos (terrestres, acu\u00e1ticos y a\u00e9reos). Crea un ArrayList y a\u00f1ade todos los veh\u00edculos. Recorre la lista y llama al m\u00e9todo imprimir de todos los veh\u00edculos.</p>"},{"location":"ud08/ud08ac/#ejercicio19-figuras","title":"Ejercicio19 - Figuras","text":"<p>paquete: <code>_19_figuras</code></p> <p>Implementa una interface llamada <code>iFigura2D</code> que declare los m\u00e9todos:</p> <ul> <li><code>double perimetro()</code>: Para devolver el per\u00edmetro de la figura.</li> <li><code>double area()</code>: Para devolver el \u00e1rea de la figura.</li> <li><code>void escalar(double escala)</code>: Para escalar la figura (aumentar o disminuir su tama\u00f1o). Solo hay que multiplicar los atributos de la figura por la escala (&gt; 0).</li> <li><code>void imprimir()</code>: Para mostrar la informaci\u00f3n de la figura (atributos, per\u00edmetro y \u00e1rea) en una sola l\u00ednea.</li> </ul> <p>Existen 4 tipos de figuras.</p> <ul> <li>Cuadrado: Sus cuatro lados son iguales.</li> <li>Rect\u00e1ngulo: Tiene ancho y alto.</li> <li>Tri\u00e1ngulo: Tiene ancho y alto.</li> <li>C\u00edrculo: Tiene radio.</li> </ul> <p>Crea las 4 clases de figuras de modo que implementen la interface iFigura2D. Define sus m\u00e9todos.</p> <p>Crea una clase ProgramaFiguras con un main en el que realizar las siguientes pruebas:</p> <p>\u200b   a) Crea un ArrayList figuras.</p> <p>\u200b   b) A\u00f1ade figuras de varios tipos.</p> <p>\u200b   c) Muestra la informaci\u00f3n de todas las figuras.</p> <p>\u200b   d) Escala todas las figuras con escala = 2.</p> <p>\u200b   e) Muestra de nuevo la informaci\u00f3n de todas las figuras.</p> <p>\u200b   f) Escala todas las figuras con escala = 0.1.</p> <p>\u200b   g) Muestra de nuevo la informaci\u00f3n de todas las figuras.</p>"},{"location":"ud08/ud08pi/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li>Curso Java. Herencia I. V\u00eddeo 40</li> <li>Curso Java. Herencia II. V\u00eddeo 41</li> <li>Curso Java. Herencia III. Dise\u00f1ando la herencia. V\u00eddeo 42</li> <li>Curso Java. Polimorfismo y enlazado din\u00e1mico. V\u00eddeo 43</li> <li>Curso Java. Casting de objetos. Clases y m\u00e9todos final. V\u00eddeo 44</li> <li>Curso Java. Clases Abstractas I. V\u00eddeo 45</li> <li>Curso Java. Clases Abstractas II. V\u00eddeo 46</li> <li>Curso Java. Modificadores de acceso. Clase Object. V\u00eddeo 47</li> <li>Curso Java. Interfaces y clases internas. Interfaces I. V\u00eddeo 49</li> <li>Curso Java. Interfaces y clases internas Interfaces II. V\u00eddeo 50</li> <li>Curso Java. Interfaces y clases internas Interfaces III. V\u00eddeo 51</li> <li>Curso Java. Interfaces y clases internas Interfaces IV. V\u00eddeo 52</li> <li>Curso Java. Interfaces y clases internas. Clases internas I. V\u00eddeo 53</li> <li>Curso Java. Interfaces y clases internas. Clases internas II. V\u00eddeo 54</li> </ul>"},{"location":"ud08/ud08re/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>Apuntes Lionel</li> </ul>"},{"location":"ud09/ud0901/","title":"9.1 Introducci\u00f3n","text":"<p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos.</p> <p>Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.</p> <p>Las bases de datos relacionales permiten organizar los datos en tablas y esas tablas y datos se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>Base de datos relacional</p> <p>Una base de datos relacional se puede definir de una manera simple como aquella que presenta la informaci\u00f3n en tablas con filas y columnas.</p> <p>Una tabla es una serie de filas y columnas , en la que cada fila es un registro y cada columna es un campo. Un campo representa un dato de los elementos almacenados en la tabla (NSS, nombre, etc.). Cada registro representa un elemento de la tabla (la persona Jose, la persona Carmen, etc.)</p> <p>No se permite que pueda aparecer dos o m\u00e1s veces el mismo registro, por lo que uno o m\u00e1s campos de la tabla forman lo que se conoce como clave primaria (atributo que se elige como identificador en una tabla, de manera que no haya dos registros iguales, sino que se diferencien al menos en esa clave). Por ejemplo, en el caso de una tabla que guarda datos de personas, el n\u00famero de la seguridad social, podr\u00eda elegirse como clave primaria, pues sabemos que aunque haya dos personas llamadas, por ejemplo, Juan P\u00e9rez P\u00e9rez, estamos seguros de que su n\u00famero de seguridad social ser\u00e1 distinto).</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS) , gestiona el modo en que los datos se almacenan, mantienen y recuperan.</p> <p>En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p> <p>Tradicionalmente, la programaci\u00f3n de bases de datos ha sido como una Torre de Babel: gran cantidad de productos de bases de datos en el mercado, y cada uno \u201chablando\u201d en su lenguaje privado con las aplicaciones.</p> <p>Java, mediante JDBC ( Java Database Connectivity, API que permite la ejecuci\u00f3n de operaciones sobre bases de datos desde el lenguaje de programaci\u00f3n Java, independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se accede), permite simplificar el acceso a base de datos , proporcionando un lenguaje mediante el cual las aplicaciones pueden comunicarse con motores de bases de datos. Sun desarroll\u00f3 este API para el acceso a bases de datos, con tres objetivos principales en mente:</p> <ul> <li>Ser un API con soporte de SQL: poder construir sentencias SQL e insertarlas dentro de llamadas al API de Java,</li> <li>Aprovechar la experiencia de los APIs de bases de datos existentes,</li> <li>Ser sencillo.</li> </ul>"},{"location":"ud09/ud0901/#conexion-a-las-bbdd-conectores","title":"Conexi\u00f3n a las BBDD: conectores","text":"<p>Dejemos de momento de lado el desfase Objeto-Relacional y centr\u00e9monos ahora en el acceso a Base de Datos Relacionales desde los lenguajes de programaci\u00f3n. Lo razonaremos en general y lo aplicaremos a Java.</p> <p>Desde la d\u00e9cada de los 80 que existen a pleno rendimiento las bases de datos relacionales. Casi todos los Sistemas Gestores de Bases de Datos (excepto los m\u00e1s peque\u00f1os como Access o Base de LibreOffice) utilizan la arquitectura cliente-servidor. Esto significa que hay un ordenador central donde est\u00e1 instalado el Sistema Gestor de Bases de Datos Relacional que act\u00faa como servidor, y habr\u00e1 muchos clientes que se conectar\u00e1n al servidor haciendo peticiones sobre la Base de Datos.</p> <p>Los Sistemas Gestores de Bases de Datos inicialmente dispon\u00edan de lenguajes de programaci\u00f3n propios para poder hacer los accesos desde los clientes. Era muy consistente, pero a base de ser muy poco operativo:</p> <ul> <li>La empresa desarrolladora del SGBD deb\u00edan mantener un lenguaje de programaci\u00f3n, que resultaba necesariamente muy costoso, si no quer\u00edan que quedara desfasado.</li> <li>Las empresas usuarias del SGBD, que se conectaban como clientes, se encontraban muy ligadas al servidor para tener que utilizar el lenguaje de programaci\u00f3n para acceder al servidor, lo que no siempre se ajustaba a sus necesidades. Adem\u00e1s, el plantearse cambiar de servidor, significaba que hab\u00eda que rehacer todos los programas, y por tanto una tarea de much\u00edsima envergadura.</li> </ul> <p>Para poder ser m\u00e1s operativos, hab\u00eda que desvincular los lenguajes de programaci\u00f3n de los Sistemas Gestores de Bases de Datos utilizando unos est\u00e1ndares de conexi\u00f3n.</p>"},{"location":"ud09/ud0902/","title":"9.2 JDBC","text":"<p>Java puede conectarse con distintos SGBD y en diferentes sistemas operativos. Independientemente del m\u00e9todo en que se almacenen los datos debe existir siempre un mediador entre la aplicaci\u00f3n y el sistema de base de datos y en Java esa funci\u00f3n la realiza JDBC. </p> <p>El API JDBC</p> <p>Para la conexi\u00f3n a las bases de datos utilizaremos el API est\u00e1ndar de JAVA denominada JDBC (Java Data Base Connectivity).</p> <p>JDBC es un API incluido dentro del lenguaje Java para el acceso a bases de datos. Consiste en un conjunto de clases e interfaces escritas en Java que ofrecen un completo API para la programaci\u00f3n con bases de datos, por lo tanto es la \u00fanica soluci\u00f3n 100% Java que permite el acceso a bases de datos.</p> <p>JDBC es una especificaci\u00f3n formada por una colecci\u00f3n de interfaces y clases abstractas, que todos los fabricantes de drivers deben implementar si quieren realizar una implementaci\u00f3n de su driver 100% Java y compatible con JDBC (JDBC-compliant driver). Debido a que JDBC est\u00e1 escrito completamente en Java tambi\u00e9n posee la ventaja de ser independiente de la plataforma. </p> <p>A tener en cuenta</p> <p>No ser\u00e1 necesario escribir un programa para cada tipo de base de datos, una misma aplicaci\u00f3n escrita utilizando JDBC podr\u00e1 manejar bases de datos Oracle, Sybase, SQL Server, etc.</p> <p>Adem\u00e1s podr\u00e1 ejecutarse en cualquier sistema operativo que posea una M\u00e1quina Virtual de Java, es decir, ser\u00e1n aplicaciones completamente independientes de la plataforma. Otras APIS que se suelen utilizar bastante para el acceso a bases de datos son DAO (Data Access Objects) y RDO (Remote Data Objects), y ADO (ActiveX Data Objects), pero el problema que ofrecen estas soluciones es que s\u00f3lo son para plataformas Windows.</p> <p>JDBC tiene sus clases en el paquete java.sql y otras extensiones en el paquete javax.sql.</p>"},{"location":"ud09/ud0902/#funciones-del-jdbc","title":"Funciones del JDBC","text":"<p>B\u00e1sicamente el API JDBC hace posible la realizaci\u00f3n de las siguientes tareas:</p> <ul> <li>Establecer una conexi\u00f3n con una base de datos.</li> <li>Enviar sentencias SQL.</li> <li>Manipular datos.</li> <li>Procesar los resultados de la ejecuci\u00f3n de las sentencias.</li> </ul>"},{"location":"ud09/ud0902/#drivers-jdbc","title":"Drivers JDBC","text":"<p>Los drivers nos permiten conectarnos con una base de datos determinada. Existen cuatro tipos de drivers JDBC, cada tipo presenta una filosof\u00eda de trabajo diferente. A continuaci\u00f3n se pasa a comentar cada uno de los drivers:</p> <ul> <li>JDBC-ODBC bridge plus ODBC driver (tipo 1): permite al programador acceder a fuentes de  datos ODBC existentes mediante JDBC. El JDBC-ODBC Bridge (puente JDBC-ODBC) implementa operaciones JDBC traduci\u00e9ndolas a operaciones ODBC, se encuentra dentro del paquete sun.jdbc.odbc y contiene librer\u00edas nativas para acceder a ODBC.</li> </ul> <p>Al ser usuario de ODBC depende de las dll de ODBC y eso limita la cantidad de plataformas en donde se puede ejecutar la aplicaci\u00f3n.</p> <ul> <li>Native-API partly-Java driver (tipo 2): son similares a los drivers de tipo1, en tanto en cuanto  tambi\u00e9n necesitan una configuraci\u00f3n en la m\u00e1quina cliente. Este tipo de driver convierte llamadas JDBC a llamadas de Oracle, Sybase, Informix, DB2 u otros SGBD. Tampoco se pueden utilizar dentro de applets al poseer c\u00f3digo nativo.</li> <li>JDBC-Net pure Java driver (tipo 3): Estos controladores est\u00e1n escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicaci\u00f3n servidora utilizan las funciones nativas del sistema de gesti\u00f3n de base de datos mediante el uso de una biblioteca JDBC en el servidor. La ventaja de esta opci\u00f3n es la portabilidad.</li> <li>JDBC de Java cliente (tipo 4): Estos controladores est\u00e1n escritos en Java y se encargan de convertir las llamadas JDBC a un protocolo independiente de la base de datos y en la aplicaci\u00f3n servidora utilizan las funciones nativas del sistema de gesti\u00f3n de base de datos sin necesidad de bibliotecas. La ventaja de esta opci\u00f3n es la portabilidad. Son como los drivers de tipo 3 pero sin la figura del intermediario y tampoco requieren ninguna configuraci\u00f3n en la m\u00e1quina cliente. Los drivers de tipo 4 se pueden utilizar para servidores Web de tama\u00f1o peque\u00f1o y medio, as\u00ed como para intranets.</li> </ul>"},{"location":"ud09/ud0902/#instalacion-controlador-mysql","title":"Instalaci\u00f3n controlador MySql","text":"<p>1) El primer paso es descargar desde https://www.mysql.com/products/connector/ el conector apropiado.</p> <p>2) Elegir Sistema Operativo y versi\u00f3n:</p> <p>3) Haz clic en Donwload y selecciona la opci\u00f3n: No thanks, just start download</p> <p>4) Ejecuta el fichero deb (en el caso de Ubuntu) descargado:</p> <p>5) Ahora deberemos a\u00f1adir la librer\u00eda JDBC a nuestro proyecto. Para ello copia el archivo <code>mysql-connector-java-x.x.x.jar</code> (en Ubuntu se encuentra en la ruta  <code>/usr/share/java</code>) en JAVA PROJECTS -&gt; Referenced Libraries de VS Code:</p>"},{"location":"ud09/ud0902/#carga-del-controlador-jdbc-y-conexion-con-la-bd","title":"Carga del controlador JDBC y conexi\u00f3n con la BD","text":"<p>El primer paso para conectarnos a una base de datos mediante JDBC es cargar el controlador apropiado. Estos controladores se distribuyen en un archivo <code>.jar</code> que provee el fabricante del SGBD y deben estar accesibles por la aplicaci\u00f3n.</p> <p>Para cargar el controlador se usan las siguientes sentencias:</p> Java<pre><code>import java.sql.*;\n\npublic class ConnectToMySql {\n    // JDBC URL, usuario y contrase\u00f1a de la base de datos  \n    private static final String JDBC_URL = \"jdbc:mysql://localhost:3306/prueba\";\n    private static final String USUARIO = \"prueba\";\n    private static final String CONTRASE\u00d1A = \"1234\";\n\n    public static void main(String[] args) {\n        try {\n        // Dependiendo de a qu\u00e9 tipo de SGBD queramos conectar cargaremos un controlador u otro\n\n            // Paso 1: Cargar el controlador JDBC de MySQL\n            Class&lt;?&gt; c = Class.forName(\"com.mysql.jdbc.Driver\");\n            System.out.println(\"Cargado: \" + c.getName());\n\n            //Definir la url de conexi\u00f3n y los par\u00e1metros de usuario y contrase\u00f1a\n            // Paso 2: Establecer la conexi\u00f3n con la base de datos\n            Connection conexion = DriverManager.getConnection(JDBC_URL, USUARIO, CONTRASE\u00d1A);   \n            System.out.println(\"Conexi\u00f3n completada\");\n\n            // Paso 3: Aqu\u00ed puedes realizar operaciones en la base de datos\n            // ...\n\n            // Paso 4: Cerrar la conexi\u00f3n\n            conexion.close();\n            System.out.println(\"Conexi\u00f3n cerrada correctamente.\");\n\n        } catch (ClassNotFoundException cnfe) {\n            System.out.println(\"ERROR al no encontrarse la clase controlador JDBC: \" + cnfe.getMessage());\n        } catch (SQLException ex) {\n            System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n        }\n    }\n}\n</code></pre> <p>Observamos las siguientes cuestiones:</p> <ul> <li>Como ya hemos comentado alguna vez, la sentencia <code>Class.forName()</code> no ser\u00eda necesaria en muchas aplicaciones. Pero nos asegura que hemos cargado el driver, y por tanto el <code>DriverManager</code> la sabr\u00e1 manejar.</li> <li>El <code>DriverManager</code> es capaz de encontrar el driver adecuado a trav\u00e9s de la url proporcionada (sobre todo si el driver est\u00e1 cargado en memoria), y es quien nos proporciona el objeto <code>Connection</code> por medio del m\u00e9todo <code>getConnection()</code>. Existe otra forma de obtener el <code>Connection</code> por medio del objeto <code>Driver</code>, como veremos m\u00e1s adelante, pero tambi\u00e9n ser\u00e1 pasando indirectamente por <code>DriverManager</code>.</li> <li>Si no se encuentra la clase del driver (por no tenerlo en las librer\u00edas del proyecto, o haber escrito mal su nombre) se producir\u00e1 la excepci\u00f3n <code>ClassNotFoundException</code>. Es conveniente tratarla con <code>try ... catch</code>.</li> <li>Si no se puede establecer la conexi\u00f3n por alguna raz\u00f3n se producir\u00e1 la excepci\u00f3n <code>SQLException</code>. Al igual que en el caso anterior, es conveniente tratarla con <code>try ... catch</code>.</li> <li>El objeto <code>Connection</code> mantendr\u00e1 una conexi\u00f3n con la Base de Datos desde el momento de la creaci\u00f3n hasta el momento de cerrarla con <code>close()</code>. Es muy importante cerrar la conexi\u00f3n, no s\u00f3lo para liberar la memoria de nuestro ordenador (que al cerrar la aplicaci\u00f3n liberar\u00eda), sino sobre todo para cerrar la sesi\u00f3n abierta en el Servidor de Bases de Datos.</li> </ul>"},{"location":"ud09/ud0902/#conexion-alternativa-mediante-driver","title":"Conexi\u00f3n alternativa mediante <code>Driver</code>","text":"<p>Una manera de conectar alternativa a las anteriores es utilizando el objeto <code>Driver</code>. La clase <code>java.sql.Driver</code> pertenece a la API JDBC, pero no es instanciable, y tan s\u00f3lo es una interfaz, para que las clases <code>Driver</code> de los contenedores hereden de ella e implementen la manera exacta de acceder al SGBD correspondiente. Como no es instanciable (no podemos hacer <code>new Driver()</code>) la manera de crearlo es a trav\u00e9s del m\u00e9todo <code>getDriver()</code> del <code>DriverManager</code>, que seleccionar\u00e1 el driver adecuado a partir de la url. Ya s\u00f3lo quedar\u00e1n definir algunas propiedades, como el usuario y la contrase\u00f1a, y obtener el <code>Connection</code> por medio del m\u00e9todo <code>connect()</code></p> <p>La manera de conectar a trav\u00e9s de un objeto <code>Driver</code> es m\u00e1s larga, pero m\u00e1s completa ya que se podr\u00edan especificar m\u00e1s cosas. Y quiz\u00e1s ayude a entender el montaje de los controladores de los diferentes SGBD en Java.</p> Java<pre><code>import java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\npublic class ConnectToMySqlDriver {\n    // JDBC URL, usuario y contrase\u00f1a de la base de datos  \n    private static final String JDBC_URL = \"jdbc:mysql://localhost:3306/prueba\";\n    private static final String USUARIO = \"prueba\";\n    private static final String CONTRASE\u00d1A = \"1234\";\n\n    public static void main(String[] args)  {\n        try{\n            Driver driver = DriverManager.getDriver(JDBC_URL);\n\n            Properties properties = new Properties();\n            properties.setProperty(\"user\", USUARIO);\n            properties.setProperty(\"password\", CONTRASE\u00d1A);\n\n            Connection conexion = driver.connect(JDBC_URL, properties);\n            System.out.println(\"Conexi\u00f3n completada a trav\u00e9s de Driver\");\n\n            // Cerrar la conexi\u00f3n\n            conexion.close();\n            System.out.println(\"Conexi\u00f3n cerrada correctamente.\");\n        } catch (SQLException ex) {\n            System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0902/#carga-del-controlador-y-de-la-conexion-mediante-el-patron-singleton","title":"Carga del controlador y de la conexi\u00f3n mediante el patr\u00f3n Singleton","text":"<p>Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase.</p> <p>El sino de <code>Singleton</code></p> <p>Su intenci\u00f3n consiste en garantizar que una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella.  El patr\u00f3n <code>Singleton</code> se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna. </p> <p>Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado. Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, \u2026) o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n (en java no hay variables globales) El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:</p> <ul> <li>La propia clase es responsable de crear la \u00fanica instancia.</li> <li>Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.</li> <li>Declara el constructor de clase como privado para que no sea instanciable directamente.</li> </ul> Java<pre><code>/**\n @see https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con\n Patron Singleton\n */\npublic class DatabaseConnection {\n    // JDBC URL, usuario y contrase\u00f1a de la base de datos  \n    private static final String JDBC_URL = \"jdbc:mysql://localhost:3306/prueba\";\n    private static final String USUARIO = \"prueba\";\n    private static final String CONTRASE\u00d1A = \"1234\";\n\n    private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase\n    private static java.sql.Connection conexion;\n\n    private DatabaseConnection() {\n        // El Constructor es privado!!\n    }\n\n    public static DatabaseConnection getInstance(){\n        //Si no hay ninguna instancia...\n        if(dbInstance == null){\n            dbInstance = new DatabaseConnection();\n        }\n        return dbInstance;\n    }\n\n    public static java.sql.Connection getConnection(){\n        if(conexion == null){\n            try {\n                conexion = java.sql.DriverManager.getConnection(JDBC_URL, USUARIO, CONTRASE\u00d1A);\n                System.out.println(\"Conexi\u00f3n realizada\");\n\n            } catch (java.sql.SQLException ex) {\n                System.out.println(\"ERROR al conectar: \" + ex.getMessage());\n            }\n        }\n        return conexion;\n    }\n}\n</code></pre> <p>En el caso de BlueJ, se a\u00f1aden las librer\u00edas desde Herramientas -&gt; Preferencias -&gt; Librer\u00edas</p> <p>Creamos una nueva clase <code>DatabaseConnection</code> en BlueJ:</p> <p>Vamos a crear una nueva clase <code>Test</code> para probar la conexi\u00f3n:</p> Java<pre><code>import java.sql.*;\npublic class Test {\n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection();\n    public Test(){\n        //De momento no hace nada\n    }\n}\n</code></pre>"},{"location":"ud09/ud0903/","title":"9.3 Acceso a BBDD","text":""},{"location":"ud09/ud0903/#cargar-el-driver","title":"Cargar el Driver","text":"<p>En un proyecto Java que realice conexiones a bases de datos es necesario, antes que nada, utilizar <code>Class.forname(\u2026).newInstance()</code> para cargar din\u00e1micamente el Driver que vamos a utilizar. Esto solo es necesario hacerlo una vez en nuestro programa. Puede lanzar excepciones por lo que es necesario utilizar un bloque try-catch.</p> Java<pre><code>try {\n    Class.forName(\"com.mysql.cj.jdbc.Driver\").newInstance();    \n\n} catch (Exception e) {\n    // manejamos el error\n}\n</code></pre> <p>Hay que tener en cuenta que las clases y m\u00e9todos utilizados para conectarse a una base de datos (explicados m\u00e1s adelante) funcionan con todos los drivers disponibles para Java (JDBC es solo uno, hay muchos m\u00e1s). Esto es posible ya que el est\u00e1ndar de Java solo los define como interfaces (interface) y cada librer\u00eda driver los implementa (define las clases y su c\u00f3digo). Por ello es necesario utilizar <code>Class.forName(\u2026)</code> para indicarle a Java qu\u00e9 driver vamos a utilizar.</p> <p>Este nivel de asbtracci\u00f3n facilita el desarrollo de proyectos ya que si necesit\u00e1ramos utilizar otro sistema de base de datos (que no fuera MySQL) solo necesitar\u00edamos cambiar la l\u00ednea de c\u00f3digo que carga el driver y poco m\u00e1s. Si cada sistema de base de datos necesitara que utiliz\u00e1ramos distintas clases y m\u00e9todos todo ser\u00eda mucho m\u00e1s complicado.</p> <p>Las cuatro clases fundamentales que toda aplicaci\u00f3n Java necesita para conectarse a una base de datos y ejecutar sentencias son: <code>DriverManager</code>, <code>Connection</code>, <code>Statement</code> y <code>ResultSet</code>. </p>"},{"location":"ud09/ud0903/#clase-drivermanager","title":"Clase <code>DriverManager</code>","text":"<p>Paso 1: Establecer conexi\u00f3n con la BBDD</p> <p>Ejemplo de conexi\u00f3n seg\u00fan SGBD</p> Java<pre><code>/* Para MySQL:\n    jdbc  --&gt; driver\n    mysql --&gt; protocolo driver\n    localhost:3306/gestionPedidos --&gt; detalles de la conexi\u00f3n\n*/\njdbc:mysql://localhost:3306/gestionPedidos\n\njdbc:odbc:DSN_gestionPedidos                  // para SQL Server\n\njdbc:oracle:juan@servidor:3306:gestionPedidos // para Oracle\n</code></pre> <p>Vamos a necesitar informaci\u00f3n adicional como son los datos de usuario y contrase\u00f1a.</p> <p>La clase java.sql.DriverManager es la capa gestora del driver JDBC. Se encarga de manejar el Driver apropiado y permite crear conexiones con una base de datos mediante el m\u00e9todo est\u00e1tico <code>getConnection()</code> que tiene dos variantes:</p> Java<pre><code>DriveManager.getConnection(String url)\n// y\nDriveManager.getConnection(String url, String user, String password)\n</code></pre> <p>Este m\u00e9todo intentar\u00e1 establecer una conexi\u00f3n con la base de datos seg\u00fan la URL indicada. Opcionalmente se le puede pasar el usuario y contrase\u00f1a como argumento (tambi\u00e9n se puede indicar en la propia URL). Si la conexi\u00f3n es satisfactoria devolver\u00e1 un objeto Connection.</p> Ejemplo de conexi\u00f3n a la base de datos prueba en localhost Java<pre><code>String url = \"jdbc:mysql://localhost:3306/prueba\";\nConnection conexion = DriverManager.getConnection(url,\"root\",\"\");\n</code></pre> <p>Este m\u00e9todo puede lanzar dos tipos de excepciones (que habr\u00e1 que manejar con un try-catch):</p> <ul> <li>SQLException: la conexi\u00f3n no ha podido producirse. Puede ser por multitud de motivos como una URL mal formada, un error en la red, host o puerto incorrecto, base de datos no existente, usuario y contrase\u00f1a no v\u00e1lidos, etc.</li> <li>SQLTimeoutException: se ha superado el LoginTimeout sin recibir respuesta del servidor.</li> </ul>"},{"location":"ud09/ud0903/#clase-connection","title":"Clase <code>Connection</code>","text":"<p>Paso 2. Crear un objeto Statement</p> <p>Un objeto java.sql.Connection representa una sesi\u00f3n de conexi\u00f3n con una base de datos. Una aplicaci\u00f3n puede tener tantas conexiones como necesite, ya sea con una o varias bases de datos.</p> <p>El m\u00e9todo m\u00e1s relevante es <code>createStatement()</code> que devuelve un objeto Statement asociado a dicha conexi\u00f3n que permite ejecutar sentencias SQL.</p> <p>El m\u00e9todo createStatement() tambi\u00e9n puede lanzar excepciones de tipo SQLException.</p> Java<pre><code>Statement st = conexion.createStatement();\n</code></pre> <p>Cuando ya no la necesitemos es aconsejable cerrar la conexi\u00f3n con <code>close()</code> para liberar recursos:</p> Java<pre><code>conexion.close();\n</code></pre>"},{"location":"ud09/ud0903/#clase-statement","title":"Clase <code>Statement</code>","text":"<p>Paso 3. Ejecutar sentencia SQL</p> <p>Un objeto java.sql.Statement permite ejecutar sentencias SQL en la base de datos a trav\u00e9s de la conexi\u00f3n con la que se cre\u00f3 el Statement (ver Paso 2). Los tres m\u00e9todos m\u00e1s comunes de ejecuci\u00f3n de sentencias SQL son <code>executeQuery(\u2026)</code>, <code>executeUpdate(\u2026)</code> y <code>execute(\u2026)</code>.</p> <p>Estos tres m\u00e9todos pueden lanzar excepciones de tipo SQLException y SQLTimeoutException.</p> <ul> <li><code>ResultSet executeQuery(String sql)</code>: ejecuta la sentencia sql indicada (de tipo SELECT). Devuelve un objeto ResultSet con los datos proporcionados por el servidor.  </li> </ul> Java<pre><code>ResultSet rs = st.executeQuery(\"SELECT * FROM vendedores\");\n</code></pre> <ul> <li><code>int executeUpdate(String sql)</code>: ejecuta la sentencia sql indicada (de tipo DML como por ejemplo INSERT, UPDATE o DELETE).  Devuelve un n\u00famero de registros que han sido insertados, modificados o eliminados.</li> </ul> Java<pre><code>int nr = st.executeUpdate (\"INSERT INTO vendedores VALUES (1,'Pedro Gil', '2017-04-11', 15000);\")\n</code></pre> <p>Cuando ya no lo necesitemos es aconsejable cerrar el statement con <code>close()</code> para liberar recursos:</p> Java<pre><code> st.close();\n</code></pre> <p>Nota</p> <p>Podr\u00edamos decir que este resultset es una especie de tabla virtual que se almacena en memoria con la informaci\u00f3n en su interior.</p>"},{"location":"ud09/ud0903/#clase-resultset","title":"Clase <code>ResultSet</code>","text":"<p>Paso 4. Leer el resultset</p> <p>Un objeto java.sql.ResultSet contiene un conjunto de resultados (datos) obtenidos tras ejecutar una sentencia SQL, normalmente de tipo SELECT. Es una estructura de datos en forma de tabla con registros (filas) que podemos recorrer para acceder a la informaci\u00f3n de sus campos (columnas).</p> <p>ResultSet utiliza internamente un cursor que apunta al registro actual sobre el que podemos operar. Inicialmente dicho cursor est\u00e1 situado antes de la primera fila y disponemos de varios m\u00e9todos para desplazar el cursor. El m\u00e1s com\u00fan es <code>next()</code>:</p> <ul> <li><code>boolean next()</code>: mueve el cursor al siguiente registro. Devuelve true si fue posible y false en caso contrario (si ya llegamos al final de la tabla).</li> </ul> <p>Algunos de los m\u00e9todos para obtener los datos del registro actual son:</p> <ul> <li><code>String getString(String columnLabel)</code>: devuelve un dato String de la columna indicada por su nombre. </li> </ul> Por ejemplo Java<pre><code>rs.getString(\"nombre\");\n</code></pre> <ul> <li><code>String getString(int columnIndex)</code>: devuelve un dato String de la columna indicada por su nombre (la primera columna es la 1, no la cero). </li> </ul> Por ejemplo Java<pre><code>rs.getString(2);\n</code></pre> <p>Existen m\u00e9todos an\u00e1logos a los anteriores para obtener valores de tipo int, long, float, double, boolean, Date, Time, Array, etc. Pueden consultarse todos en la documentaci\u00f3n oficial de Java.</p> <ul> <li><code>int getInt(String columnLabel)</code></li> <li><code>int getInt(int columnIndex)</code></li> <li><code>double getDouble(String columnLabel)</code></li> <li><code>double getDouble(int columnIndex)</code></li> <li><code>boolean getBoolean(String columnLabel)</code></li> <li><code>boolean getBoolean(int columnIndex)</code></li> <li><code>Date getDate(String columnLabel)</code></li> <li><code>Date getDate(int columnIndex)</code></li> <li>etc.</li> </ul> <p>M\u00e1s adelante veremos c\u00f3mo se realiza la modificaci\u00f3n e inserci\u00f3n de datos.</p> <p>Todos estos m\u00e9todos pueden lanzar una SQLException.</p> Ejemplo para recorrer un ResultSet llamado rs y mostrarlo por pantalla Java<pre><code>while(rs.next()) {\n    int id = rs.getInt(\"id\");\n    String nombre = rs.getString(\"nombre\");\n    Date fecha = rs.getDate(\"fecha_ingreso\");\n    float salario = rs.getFloat(\"salario\");\n\n    System.out.println(id + \" \" + nombre + \" \" + fecha + \" \" + salario);\n}\n</code></pre>"},{"location":"ud09/ud0904/","title":"9.4 Navegabilidad y concurrencia","text":"<p>Cuando invocamos a <code>createStatement()</code> sin argumentos, como hemos visto anteriormente, al ejecutar sentencias SQL obtendremos un ResultSet por defecto en el que el cursor solo puede moverse hacia adelante y los datos son de solo lectura. A veces esto no es suficiente y necesitamos mayor funcionalidad.</p> <p>Por ello el m\u00e9todo createStatement() est\u00e1 sobrecargado (existen varias versiones de dicho m\u00e9todo) lo cual nos permite invocarlo con argumentos en los que podemos especificar el funcionamiento.</p> <ul> <li><code>Statement createStatement (int resultSetType, int resultSetConcurrency)</code>: devuelve un objeto Statement cuyos objetos ResultSet ser\u00e1n del tipo y concurrencia especificados. Los valores v\u00e1lidos son constantes definidas en ResultSet.</li> </ul> <p>El argumento resultSetType indica el tipo de ResultSet:</p> <ul> <li><code>ResultSet.TYPE_FORWARD_ONLY</code>: ResultSet por defecto, forward-only y no-actualizable.<ul> <li>Solo permite movimiento hacia delante con next().</li> <li>Sus datos NO se actualizan. Es decir, no reflejar\u00e1 cambios producidos en la base de datos. Contiene una instant\u00e1nea del momento en el que se realiz\u00f3 la consulta.</li> </ul> </li> <li><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>: ResultSet desplazable y no-actualizable.<ul> <li>Permite libertad de movimiento del cursor con otros m\u00e9todos como first(), previous(), last(), etc. adem\u00e1s de next().</li> <li>Sus datos NO se actualizan, como en el caso anterior.</li> </ul> </li> <li><code>ResultSet.TYPE_SCROLL_SENSITIVE</code>: ResultSet desplazable y actualizable.<ul> <li>Permite libertad de movimientos del cursor, como en el caso anterior.</li> <li>Sus datos S\u00cd se actualizan. Es decir, mientras el ResultSet est\u00e9 abierto se actualizar\u00e1 autom\u00e1ticamente con los cambios producidos en la base de datos. Esto puede suceder incluso mientras se est\u00e1 recorriendo el ResultSet, lo cual puede ser conveniente o contraproducente seg\u00fan el caso.</li> </ul> </li> </ul> <p>El argumento resultSet.Concurrency indica la concurrencia del ResultSet:</p> <ul> <li><code>ResultSet.CONCUR_READ_ONLY</code>: solo lectura. Es el valor por defecto.</li> <li><code>ResultSet.CONCUR_UPDATABLE</code>: permite modificar los datos almacenados en el ResultSet para luego aplicar los cambios sobre la base de datos (m\u00e1s adelante se ver\u00e1 c\u00f3mo).</li> </ul> <p>A tener en cuenta</p> <p>El ResultSet por defecto que se obtiene con createStatement() sin argumentos es el mismo que con createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY).</p>"},{"location":"ud09/ud0905/","title":"9.5 Consultas (Query)","text":""},{"location":"ud09/ud0905/#navegacion-de-un-resultset","title":"Navegaci\u00f3n de un <code>ResultSet</code>","text":"<p>Como ya se ha visto, en un objeto ResultSet se encuentran los resultados de la ejecuci\u00f3n de una sentencia SQL. Por lo tanto, un objeto ResultSet contiene las filas que satisfacen las condiciones de una sentencia SQL, y ofrece m\u00e9todos de navegaci\u00f3n por los registros como <code>next()</code> que desplaza el cursos al siguiente registro del ResultSet.</p> <p>Adem\u00e1s de este m\u00e9todo de desplazamiento b\u00e1sico, existen otros de desplazamiento libre que podremos utilizar siempre y cuando el ResultSet sea de tipo <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code> o <code>ResultSet.TYPE_SCROLL_SENSITIVE</code> como se ha dicho antes.</p> <p>Algunos de estos m\u00e9todos son:</p> <ul> <li> <p><code>void beforeFirst()</code>: mueve el cursor antes de la primera fila.</p> </li> <li> <p><code>boolean first()</code>: mueve el cursor a la primera fila.</p> </li> <li> <p><code>boolean next()</code>: mueve el cursor a la siguiente fila. Permitido en todos los tipos de ResultSet.</p> </li> <li> <p><code>boolean previous()</code>: mueve el cursor a la fila anterior.</p> </li> <li> <p><code>boolean last()</code>: mueve el cursor a la \u00faltima fila.</p> </li> <li> <p><code>void afterLast()</code>: mover el cursor despu\u00e9s de la \u00faltima fila.</p> </li> <li> <p><code>boolean absolute(int row)</code>: posiciona el cursor en el n\u00famero de registro indicado. Hay que tener en cuenta que el primer registro es el 1, no el cero. </p> </li> </ul> Ejemplo <code>absolute(n)</code> <p><code>absolute(7)</code> desplazar\u00e1 el cursor al s\u00e9ptimo registro. Si  valor es negativo se posiciona en el n\u00famero de registro indicado pero empezando a contar desde el final (el \u00faltimo es el -1). Por ejemplo si tiene 10 registros y llamamos absolute(-2) se desplazar\u00e1 al registro n.\u00ba 9.</p> <ul> <li><code>boolean relative(int registros)</code>: desplaza el cursor un n\u00famero relativo de registros, que puede ser positivo o negativo. </li> </ul> Ejemplo <code>relative(n)</code> <p>Si el cursor esr\u00e1 en el registro 5 y llamamos a <code>relative(10)</code> se desplazar\u00e1 al registro 15. Si luego llamamos a <code>relative(-4)</code> se desplazar\u00e1 al registro 11.</p> <p>Los m\u00e9todos que devuelven un tipo boolean devolver\u00e1n true si ha sido posible mover el cursor a un registro v\u00e1lido, y false en caso contrario, por ejemplo si no tiene ning\u00fan registro o hemos saltado a un n\u00famero de registro que no existe.</p> <p>Todos estos m\u00e9todos pueden producir una excepci\u00f3n de tipo SQLException.</p> <p>Tambi\u00e9n existen otros m\u00e9todos relacionados con la posici\u00f3n del cursor.</p> <ul> <li><code>int getRow()</code>: devuelve el n\u00famero de registro actual. Cero si no hay registro actual.</li> <li><code>boolean isBeforeFirst()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 antes del primer registro.</li> <li><code>boolean isFirst()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 en el primer registro.</li> <li><code>boolean isLast()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 en el \u00faltimo registro.</li> <li><code>boolean isAfterLast()</code>: devuelve \u2018true\u2019 si el cursor est\u00e1 despu\u00e9s del \u00faltimo registro.</li> </ul>"},{"location":"ud09/ud0905/#obteniendo-datos-del-resultset","title":"Obteniendo datos del <code>ResultSet</code>","text":"<p>Los m\u00e9todos getXXX() ofrecen los medios para recuperar los valores de las columnas (campos) de la fila (registro) actual del ResultSet. No es necesario que las columnas sean obtenidas utilizando un orden determinado.</p> <p>Para designar una columna podemos utilizar su nombre o bien su n\u00famero (empezando por 1).</p> <p>Por ejemplo si la segunda columna de un objeto ResultSet se llama t\u00edtulo y almacena datos de tipo String, se podr\u00e1 recuperar su valor de las dos formas siguientes:</p> Java<pre><code>// rs es un objeto ResultSet\nString valor = rs.getString(2);\nString valor = rs.getString(\"titulo\");\n</code></pre> <p>Es importante tener en cuenta que las columnas se numeran de izquierda a derecha y que la primera es la n\u00famero 1, no la cero. Tambi\u00e9n que las columnas no son case sensitive, es decir, no distinguen entre may\u00fasculas y min\u00fasculas.</p> <p>A tener en cuenta</p> <p>La informaci\u00f3n referente a las columnas de un ResultSet se puede obtener llamando al m\u00e9todo getMetaData() que devolver\u00e1 un objeto ResultSetMetaData que contendr\u00e1 el n\u00famero, tipo y propiedades de las columnas del ResultSet.</p> <p>Si conocemos el nombre de una columna, pero no su \u00edndice, el m\u00e9todo findColumn() puede ser utilizado para obtener el n\u00famero de columna, pas\u00e1ndole como argumento un objeto String que sea el nombre de la columna correspondiente, este m\u00e9todo nos devolver\u00e1 un entero que ser\u00e1 el \u00edndice correspondiente a la columna.</p>"},{"location":"ud09/ud0905/#tipos-de-datos-y-conversiones","title":"Tipos de datos y conversiones","text":"<p>Cuando se lanza un m\u00e9todo getXXX() determinado sobre un objeto ResultSet para obtener el valor de un campo del registro actual, el driver JDBC convierte el dato que se quiere recuperar al tipo Java especificado y entonces devuelve un valor Java adecuado. Por ejemplo si utilizamos el m\u00e9todo getString() y el tipo del dato en la base de datos es VARCHAR, el driver JDBC convertir\u00e1 el dato VARCHAR de tipo SQL a un objeto String de Java.</p> <p>Algo parecido sucede con otros tipos de datos SQL como por ejemplo DATE. Podremos acceder a \u00e9l tanto con getDate() como con getString(). La diferencia es que el primero devolver\u00e1 un objeto Java de tipo Date y el segundo devolver\u00e1 un String.</p> <p>Siempre que sea posible el driver JDBC convertir\u00e1 el tipo de dato almacenado en la base de datos al tipo solicitado por el m\u00e9todo getXXX(), pero hay conversiones que no se pueden realizar y lanzar\u00e1n una excepci\u00f3n, como por ejemplo si intentamos hacer un getInt() sobre un campo que no contiene un valor num\u00e9rico.</p>"},{"location":"ud09/ud0905/#sentencias-que-no-devuelven-datos","title":"Sentencias que no devuelven datos","text":"<p>Las ejecutamos con el m\u00e9todo <code>executeUpdate</code>. Ser\u00e1n todas las sentencias SQL excepto el SELECT, que es la de consulta. Es decir, nos servir\u00e1 para las siguientes sentencias:</p> <ul> <li>Sentencias que cambian las estructuras internas de la BD donde se guardan los datos (instrucciones conocidas con las siglas DDL, del ingl\u00e9s Data Definition Language), como por ejemplo <code>CREATE TABLE</code>, <code>CREATE VIEW</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, \u2026,</li> <li>Sentencias para otorgar permisos a los usuarios existentes o crear otros nuevos (subgrupo de instrucciones conocidas como DCL o Data Control Language), como por ejemplo <code>GRANT</code>.</li> <li>Y tambi\u00e9n las sentencias para modificar los datos guardados utilizando las instrucciones <code>INSERT</code>, <code>UPDATE</code> y <code>DELETE</code>.</li> </ul> <p>Aunque se trata de sentencias muy dispares, desde el punto de vista de la comunicaci\u00f3n con el SGBD se comportan de manera muy similar, siguiendo el siguiente patr\u00f3n:</p> <ol> <li>Instanciaci\u00f3n del <code>Statement</code> a partir de una conexi\u00f3n activa.</li> <li>Ejecuci\u00f3n de una sentencia SQL pasada por par\u00e1metro al m\u00e9todo <code>executeUpdate</code>.</li> <li>Cierre del objeto <code>Statement</code> instanciado.</li> </ol> <p>Miremos este ejemplo, en el que vamos a crear una tabla muy sencilla en la Base de Datos MySql/network.</p> Aqu\u00ed ten\u00e9is la clase DatabaseConnection Java<pre><code>/**\n &lt;br /&gt;* Write a description of class DatabaseConnection here.\n &lt;br /&gt;*\n &lt;br /&gt;* @author (Victor Ponz)\n &lt;br /&gt;* @see &lt;a href=\"https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con\"&gt;Stackoverflow Singleton&lt;/a&gt;\n &lt;br /&gt;* Patron Singleton\n &lt;br /&gt;* ================\n &lt;br /&gt;* Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase. Su intenci\u00f3n consiste en garantizar que\n &lt;br /&gt;* una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella.\n &lt;br /&gt;* El patr\u00f3n Singleton se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna.\n &lt;br /&gt;* Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado.\n &lt;br /&gt;* Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes\n &lt;br /&gt;* para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, ...)\n &lt;br /&gt;* o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n.\n &lt;br /&gt;* El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:\n &lt;br /&gt;* - La propia clase es responsable de crear la \u00fanica instancia.\n &lt;br /&gt;* - Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.\n &lt;br /&gt;* - Declara el constructor de clase como privado para que no sea instanciable directamente.\n &lt;br /&gt;*/\npublic class DatabaseConnection {\n    private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase\n    private static java.sql.Connection con;\n\n    private DatabaseConnection() {\n        // El Constructor es privado!!\n    }\n\n    public static DatabaseConnection getInstance(){\n        //Si no hay ninguna instancia...\n        if(dbInstance==null){\n            dbInstance= new DatabaseConnection();\n        }\n        return dbInstance;\n    }\n\n    public static java.sql.Connection getConnection(){\n        if(con == null){\n            try {\n                String host = \"jdbc:mysql://localhost:3306/nombre-de-la-base-de-datos\";\n                String username = \"root\";\n                String password = \"sa\";\n                con = java.sql.DriverManager.getConnection( host, username, password );\n                System.out.println(\"Conexi\u00f3n realizada\");\n            } catch (java.sql.SQLException ex) {\n                System.out.println(\"Se ha producido un error al conectar: \" + ex.getMessage());\n            }\n        }\n        return con;\n    }\n}\n</code></pre> Java<pre><code>import java.sql.Connection; \nimport java.sql.DriverManager; \nimport java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class Test {\n  static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n  public Test(){ \n      //De momento no hace nada \n  }\n\n  public void createTable() throws SQLException{ \n      Statement st = con.createStatement(); \n      st.executeUpdate(\"CREATE TABLE T1 (c1 varchar(50))\"); \n      st.close(); \n  }\n}\n</code></pre>"},{"location":"ud09/ud0905/#sentencias-que-devuelven-datos","title":"Sentencias que devuelven datos","text":"<p>Las ejecutamos con el m\u00e9todo <code>executeQuery</code>. Servir\u00e1 para la sentencia SELECT, que es la de consulta. Los datos que nos devuelva esta sentencia las tendremos que guardar en un objeto de la clase <code>java.sql.ResultSet</code>, es decir conjunto de resultado. Por lo tanto, la ejecuci\u00f3n de las consultas tendr\u00e1 un forma similar a la siguiente:</p> Java<pre><code>ResultSet rs = st.executeQuery(sentenciaSQL);\n</code></pre> <p>El objeto <code>ResultSet</code> contiene el resultado de la consulta organizado por filas, por lo que en cada momento se puede consultar una fila. Para ir visitando todas las filas de una a una, iremos llamando el m\u00e9todo <code>next()</code> del objeto <code>ResultSet</code>, ya que cada vez que se ejecute <code>next</code> avanzar\u00e1 a la siguiente fila. Inmediatamente despu\u00e9s de una ejecuci\u00f3n, el <code>ResultSet</code> se encuentra posicionado justo antes de la primera fila, por lo tanto para acceder a la primera fila ser\u00e1 necesario ejecutar <code>next</code> una vez. Cuando las filas se acaban, el m\u00e9todo <code>next</code> devolver\u00e1 falso.</p> <p>Desde cada fila se podr\u00e1 acceder al valor de sus columnas con ayuda de varios m\u00e9todos <code>get</code> disponibles seg\u00fan el tipo de datos a devolver y pasando por par\u00e1metro el n\u00famero de columna que deseamos obtener. El nombre de los m\u00e9todos comienza por <code>get</code> seguido del nombre del tipo de datos. As\u00ed, si queremos recuperar la segunda columna, sabiendo que es un dato de tipo <code>String</code> habr\u00e1 que ejecutar:</p> Java<pre><code>rs.getInt(1);\n</code></pre> <p>Las columnas se empiezan a contar a partir del valor 1 (no cero). La mayor parte de los SGDB soportan la posibilidad de pasar por par\u00e1metro el nombre de la columna, pero no todos, as\u00ed que normalmente se opta por el par\u00e1metro num\u00e9rico.</p> <p>Por ejemplo MySql s\u00ed que deja acceder por nombre, por tanto, suponiendo que el campo 1 se llama id, tambi\u00e9n se puede hacer:</p> Java<pre><code>rs.getInt(\"id\");\n</code></pre> <p>En este ejemplo accedemos a la tabla usuarios y mostramos todos sus registros</p> Java<pre><code>public void getAllUsers() throws SQLException{ \n    Statement st = con.createStaemnt(); \n    ResultSet rs = st.executeQuery(\"SELECT FROM usuarios\"); \n    while (rs.next()){ \n        System.out.print(rs.getInt(1) + \"\\t\"); \n        system.out.print(rs.getString(2) + \"\\t\"); \n        system.out.println(rs.getString(3)); \n    }\n    //Siempre se debe cerrar lodo lo Muerto \n    st.close(); \n    rs.close(); \n}\n</code></pre>"},{"location":"ud09/ud0905/#asegurar-la-liberacion-de-recursos","title":"Asegurar la liberaci\u00f3n de recursos","text":"<p>Las instancias de <code>Connection</code> y las de <code>Statement</code> guardan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras contin\u00faan activas mantienen en el SGBD una sesi\u00f3n abierta, que supondr\u00e1 un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. Es importante cerrar estos objetos para liberar recursos tanto del cliente como del servidor.</p> <p>Si en un mismo m\u00e9todo debemos cerrar un objeto <code>Statement</code> y el <code>Connection</code> a partir del cual la hemos creado, se deber\u00e1 cerrar primero el <code>Statement</code> y despu\u00e9s el <code>Connection</code>. Si lo hacemos al rev\u00e9s, cuando intentamos cerrar el <code>Statement</code> nos saltar\u00e1 una excepci\u00f3n de tipo <code>SQLException</code>, ya que el cierre de la conexi\u00f3n le habr\u00eda dejado inaccesible.</p> <p>Adem\u00e1s de respetar el orden, asegurar la liberaci\u00f3n de los recursos situando las operaciones de cierre dentro de un bloque <code>finally</code>. De este modo, aunque se produzcan errores, no se dejar\u00e1n de ejecutar las instrucciones de cierre.</p> <p>Hay que tener en cuenta todav\u00eda un detalle m\u00e1s cuando sea necesario realizar el cierre de varios objetos a la vez. En este caso, aunque las situamos una tras otra, todas las instrucciones de cierre dentro del bloque <code>finally</code>, no ser\u00eda suficiente garant\u00eda para asegurar la ejecuci\u00f3n de todos los cierres, ya que, si mientras se produce el cierre de un los objetos se lanza una excepci\u00f3n, los objetos invocados en una posici\u00f3n posterior a la del que se ha producido el error no se cerrar\u00e1n.</p> <p>La soluci\u00f3n de este problema pasa por evitar el lanzamiento de cualquier excepci\u00f3n durante el proceso de cierre. Una posible forma es encapsular cada cierre entre sentencias <code>try-catch</code> dentro del <code>finally</code>.</p> Aqu\u00ed ten\u00e9is un ejemplo Java<pre><code>private void getAllUsers() {\n    Statement st = null;\n    ResultSet rs = null; \n\n    try { \n        st = con.createStatement(); \n        rs = st.executeQuery(\"SELECT * FROM usuarios\"); \n\n        while (rs.next()){ \n            System.out.print(rs.getInt(1) + \"\\t\"); \n            system.out.print(rs.getString(2) + \"\\t\"); \n            System.out.println(rs.getString(3)); \n        }\n    } catch(SQLException e){ \n        System.out.println \"Se ha producido un error al leer los usuarios. Mensaje: \" + e.getMessage());\n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierto\n            if (st != null) {\n                st.close();\n            }\n        } catch (java.sql.SQLException ex){ \n            System.out.printIn(\"Se ha producido un error: \" + ex.getMessage()); \n        }\n        try{ \n            //Siempre se debe cerrar todo lo abierto \n            if (rs != null) {\n                rs.close();\n            }\n        } catch (java.sql.SQLException ex){ \n            System.out.printIn(\"Se ha producido un error: \" + ex.getMessage()); \n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0906/","title":"9.6 Modificaci\u00f3n (update)","text":"<p>Para poder modificar los datos que contiene un ResultSet necesitamos un ResultSet de tipo modificable. Para ello debemos utilizar la constante <code>ResultSet.CONCUR_UPDATABLE</code> al llamar al m\u00e9todo <code>createStatement()</code> como se ha visto antes.</p> <p>Para modificar los valores de un registro existente se utilizan una serie de m\u00e9todos <code>updateXXX()</code> de ResultSet. Las XXX indican el tipo del dato y hay tantos distintos como sucede con los m\u00e9todos getXXX() de este mismo interfaz: updateString(), updateInt(), updateDouble(), updateDate(), etc.</p> <p>La diferencia es que los m\u00e9todos <code>updateXXX()</code> necesitan dos argumentos:</p> <ul> <li>La columna que deseamos actualizar (por su nombre o por su n\u00famero de columna).</li> <li>El valor que queremos almacenar en dicha columna (del tipo que sea).</li> </ul> <p>Por ejemplo para modificar el campo \u2018edad\u2019 almacenando el entero 28 habr\u00eda que llamar al siguiente m\u00e9todo, suponiendo que rs es un objeto ResultSet:</p> Java<pre><code>rs.updateInt(\"edad\", 28);\n</code></pre> <p>Tambi\u00e9n podr\u00eda hacerse de la siguiente manera, suponiendo que la columna edad es la segunda:</p> Java<pre><code>rs.updateInt(2, 28);\n</code></pre> <p>Los m\u00e9todos updateXXX() no devuelven ning\u00fan valor (son de tipo void). Si se produce alg\u00fan error se lanzar\u00e1 una SQLException.</p> <p>Posteriormente hay que llamar a updateRow() para que los cambios realizados se apliquen sobre la base de datos. El Driver JDBC se encargar\u00e1 de ejecutar las sentencias SQL necesarias. Esta es una caracter\u00edstica muy potente ya que nos facilita enormemente la tarea de modificar los datos de una base de datos. Este m\u00e9todo devuelve void.</p> <p>En resumen, el proceso para realizar la modificaci\u00f3n de una fila de un ResultSet es el siguiente:</p> <ol> <li>Desplazamos el cursor al registro que queremos modificar.</li> <li>Llamamos a todos los m\u00e9todos updateXXX(...) que necesitemos.</li> <li>Llamamos a <code>updateRow()</code> para que los cambios se apliquen a la base de datos.</li> </ol> <p>Es importante entender que hay que llamar a updateRow() antes de desplazar el cursor. Si desplazamos el cursor antes de llamar a updateRow(), se perder\u00e1n los cambios.</p> <p>Si queremos cancelar las modificaciones de un registro del ResultSet podemos llamar a <code>cancelRowUpdates()</code>, que cancela todas las modificaciones realizadas sobre el registro actual.</p> <p>Si ya hemos llamado a updateRow() el m\u00e9todo cancelRowUpdates() no tendr\u00e1 ning\u00fan efecto.</p> <p>El siguiente c\u00f3digo de ejemplo muestra c\u00f3mo modificar el campo \u2018direcci\u00f3n\u2019 del \u00faltimo registro de un ResultSet que contiene el resultado de una SELECT sobre la tabla de clientes. Supondremos que conn es un objeto Connection previamente creado:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = st.executeQuery(sql);\n// Vamos al \u00faltimo registro, lo modificamos y actualizamos la base de datos\nrs.last();\nrs.updateString(\"direccion\", \"C/ Pepe Ciges, 3\");\nrs.updateRow();\n</code></pre>"},{"location":"ud09/ud0907/","title":"9.7 Inserci\u00f3n (insert)","text":"<p>Para insertar nuevos registros necesitaremos utilizar, al menos, estos dos m\u00e9todos:</p> <ul> <li><code>void moveToInsertRow()</code>: desplaza el cursor al registro de inserci\u00f3n. Es un registro especial utilizado para insertar nuevos registros en el ResultSet. Posteriormente tendremos que llamar a los m\u00e9todos updateXXX() ya conocidos para establecer los valores del registro de inserci\u00f3n. Para finalizar hay que llamar a insertRow().</li> <li><code>void insertRow()</code>: inserta el registro de inserci\u00f3n en el ResultSet, pasando a ser un registro normal m\u00e1s, y tambi\u00e9n lo inserta en la base de datos.</li> </ul> <p>El siguiente c\u00f3digo inserta un nuevo registro en la tabla clientes. Supondremos que conn es un objeto Connection previamente creado:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = st.executeQuery(sql);\n// Creamos un nuevo registro y lo insertamos\nrs.moveToInsertRow();\nrs.updateString(2,\"Killy Lopez\");\nrs.updateString(3,\"Wall Street 3674\");\nrs.insertRow();\n</code></pre> <p>Los campos cuyo valor no se haya establecido con updateXXX() tendr\u00e1n un valor NULL. Si en la base de datos dicho campo no est\u00e1 configurado para admitir nulos se producir\u00e1 una SQLException.</p> <p>Tras insertar nuestro nuevo registro en el objeto ResultSet podremos volver a la anterior posici\u00f3n en la que se encontraba el cursor (antes de invocar moveToInsertRow() ) llamando al m\u00e9todo <code>moveToCurrentRow()</code>. Este m\u00e9todo s\u00f3lo se puede utilizar en combinaci\u00f3n con moveToInsertRow().</p> Ejemplo 1 Java<pre><code>public void insertUser(){ \n    Statement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES ('Carlos', 'S\u00e1nchez')\";\n    try { \n        st = con.createStatement(); \n        st.executeUpdate(sql); \n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierta \n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> Ejemplo 2: m\u00e9todo pas\u00e1ndole nombre y apellidos Java<pre><code>public void insertUser(String nombre, String apellidos){ \n    Statement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES ('\" + nombre + \"', '\" + apellidos + \"')\";\n    try { \n        st = con.createStatement(); \n        st.executeUpdate(sql); \n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierta \n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0908/","title":"9.8 Borrado (delete)","text":"<p>Para eliminar un registro solo hay que desplazar el cursor al registro deseado y llamar al m\u00e9todo:</p> <ul> <li><code>void deleteRow()</code>: elimina el registro actual del ResultSet y tambi\u00e9n de la base de datos.</li> </ul> <p>El siguiente c\u00f3digo borra el tercer registro de la tabla <code>clientes</code>:</p> Java<pre><code>// Creamos un Statement scrollable y modificable\nStatement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n// Ejecutamos un SELECT y obtenemos la tabla clientes en un ResultSet\nString sql = \"SELECT * FROM clientes\";\nResultSet rs = stmt.executeQuery(sql);\n// Desplazamos el cursor al tercer registro\nrs.absolute(3)\nrs.deleteRow();\n</code></pre>"},{"location":"ud09/ud0909/","title":"9.9 Sentencias predefinidas","text":"<p>Para solucionar el problema de crear sentencias sql complejas, se utiliza <code>PreparedStatement</code>.</p> <p>JDBC dispone de un objeto derivado del <code>Statement</code> que se llama <code>PreparedStatement</code>, al que se le pasa la sentencia SQL en el momento de crearlo, no en el momento de ejecutar la sentencia (como pasaba con <code>Statement</code>). Y adem\u00e1s esta sentencia puede admitir par\u00e1metros, lo que nos puede ir muy bien en determinadas ocasiones.</p> <p>De cualquier modo, <code>PreparedStatement</code> presenta ventajas sobre su antecesor <code>Statement</code> cuando nos toque trabajar con sentencias que se hayan de ejecutar varias veces. La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda al SGBD ser\u00e1 compilada antes de ser ejecutada.</p> <ul> <li>Utilizando un objeto <code>Statement</code>, cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda <code>executeUpdate</code> o bien v\u00eda <code>executeQuery</code>, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres.</li> <li>En cambio, al <code>PreparedStament</code> la sentencia nunca var\u00eda y por lo tanto se puede compilar y guardar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarse. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n.</li> </ul> <p>En algunos sistemas gestores, adem\u00e1s, usar <code>PreparedStatements</code> puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema guarde las respuestas en la memoria cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida.</p> <p>La principal diferencia de los objetos <code>PreparedStatement</code> en relaci\u00f3n a los <code>Statement</code>, es que en los primeros se les pasa la sentencia SQL predefinida en el momento de crearlo. Como la sentencia queda predefinida, ni los m\u00e9todos <code>executeUpdate</code> ni <code>executeQuery</code> requerir\u00e1n ning\u00fan par\u00e1metro. Es decir, justo al rev\u00e9s que en el <code>Statement</code>.</p> <p>Los par\u00e1metros de la sentencia se marcar\u00e1n con el s\u00edmbolo de interrogaci\u00f3n (?) Y se identificar\u00e1n por la posici\u00f3n que ocupan en la sentencia, empezando a contar desde la izquierda a partir del n\u00famero 1. El valor de los par\u00e1metros se asignar\u00e1 utilizando el m\u00e9todo espec\u00edfico, de acuerdo con el tipo de datos a asignar. El nombre empezar\u00e1 por <code>set</code> y continuar\u00e1 con el nombre del tipo de datos (ejemplos: <code>setString</code>, <code>setInt</code>, <code>setLong</code>, <code>setBoolean</code> \u2026). Todos estos m\u00e9todos siguen la misma sintaxis:</p> Java<pre><code>setXXXX(&lt;posici\u00f3nEnLaSentenciaSQL&gt;, &lt;valor&gt;);\n</code></pre> <p>Este es el mismo m\u00e9todo para insertar un usuario pero usando <code>PreparedStatement</code>:</p> Java<pre><code>public void insertUserPrepared(String nombre, String apellidos){ \n    PreparedStatement st = null; \n    String sql = \"INSERT INTO usuarios (nombre, apellidos) VALUES (?, ?)\";\n\n    try { \n        st = con.preparedStatement(sql); \n        st.setString(1, nombre);\n        st.setString(2, apellidos);\n        st.executeUpdate(sql); \n\n    } catch (SQLException e)) {\n        System.out.println(\"Se ha producido un error al insertar el usuario. Mensaje: \" + e.getMessage()); \n\n    } finally { \n        try{ \n            //Siempre se debe cerrar todo lo abierto\n            if (st != null) {\n                st.close(); \n            }\n        } catch(java.sql.SQLException ex){ \n            System.out.println(\"Se ha producido un error. Mensaje: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Fijaos que ahora, adem\u00e1s, la sentencia sql es mucho m\u00e1s f\u00e1cil de escribir.</p>"},{"location":"ud09/ud0910/","title":"9.10 Trabajar con Sqlite","text":"<p>Para poder trabajar en casa, vamos a utilizar Sqlite que es un una base de datos sencilla que se guarda en un \u00fanico archivo en disco.</p> <p>Lo primero es instalar SQLite, en Ubuntu:</p> Bash<pre><code>sudo apt install sqlite3\n</code></pre> <p>Si quer\u00e9is hacerlo en Windows, pod\u00e9is seguir las instrucciones en http://www.sqlitetutorial.net/download-install-sqlite/.</p> <p>Para poder trabajar en Java, hemos de descargar el conector, desde http://www.sqlitetutorial.net/sqlite-java/sqlite-jdbc-driver/.</p> <p>Lo primero que hemos de hacer es crear una base de datos, desde la l\u00ednea de comandos. Para ello nos situamos en el directorio del proyecto y la creamos en el directorio <code>bd</code> mediante el siguiente comando:</p> Bash<pre><code>cd directorio-del-proyecto\n# directorio-del-proyecto: src/sources\nmkdir bd\ncd bd\nsqlite network.bd\n</code></pre>"},{"location":"ud09/ud0910/#instalar-sqlitestudio","title":"Instalar SQLiteStudio","text":"<p>Desde estos enlaces:</p> <p>\u200b   https://sqlitestudio.pl/ (Ubuntu) y</p> <p>\u200b   https://github.com/pawelsalawa/sqlitestudio/releases (otras plataformas),</p> <p>podemos instalar una aplicaci\u00f3n gr\u00e1fica para trabajar (m\u00e1s f\u00e1cilmente) con SQLite.</p> <p>Mediante estos comandos creamos una base de datos en disco llamada prudb.bd.</p> <p>Ahora podemos crear las tablas mediante VSCode, a\u00f1adiendo una nueva <code>DataBaseConnection</code>, al igual que hicimos con MySql (previamente hemos de crear el <code>Driver Definition</code>).</p> SQL<pre><code>CREATE TABLE usuarios (\n id INTEGER PRIMARY KEY AUTOINCREMENT,\n  nombre VARCHAR(50) NOT NULL,\n  apellidos VARCHAR(255) NOT NULL\n);\n\n\nCREATE TABLE posts (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  texto VARCHAR(255) NOT NULL,\n  likes INTEGER NOT NULL,\n  fecha timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  id_usuario INTEGER NOT NULL,\n  FOREIGN KEY (id_usuario) REFERENCES usuarios(id)\n);\n\n\nCREATE TABLE comentarios (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  texto VARCHAR(255) NOT NULL,\n  fecha timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  id_usuario INTEGER  NOT NULL,\n  id_post INTEGER  NOT NULL,\n  FOREIGN KEY (id_usuario) REFERENCES usuarios(id),\n  FOREIGN KEY (id_post) REFERENCES posts(id)\n);\n</code></pre> <p>Y vamos a a\u00f1adir el .jar que hemos descargado al Build path.</p> <p>As\u00ed que elegimos el jar desde Build Path -&gt; Libraries -&gt; Add External JARs.</p> <p>Y ahora modificamos <code>DatabaseConnection</code>:</p> Java<pre><code> String host = \"jdbc:sqlite:src/main/resources/network\";\n con = java.sql.DriverManager.getConnection( host);\n</code></pre> <p>Y hacemos una prueba para ver si funciona:</p> Java<pre><code>import java.sql.SQLException; \n\npublic class Main { \n\n      public static void main(String[] args) { \n          // TODO Aute-generated mettod stub \n          Test t = new Test(); \n          t.insertUser(); \n\n          try {\n              t.getellUsers(); \n          } catch (SQLException sqle) { \n              System.out.println(sqle.getMessage()); \n          }\n          t.closeConnection(); \n      }\n}\n</code></pre> <p>Y este debe ser el resultado:</p> Bash<pre><code>Conexi\u00f3n realizada\n1   Janet   Espinosa\n</code></pre>"},{"location":"ud09/ud0910/#ejemplos","title":"Ejemplos","text":"<p>Vamos a crear una peque\u00f1a base de datos para Empleados en Sqlite:</p> Num Nombre Departamento Edad Sueldo 1 Andreu 10 32 1000.00 2 Bernat 20 28 1200.00 3 Claudia 10 26 1100.00 4 Dami\u00e0 10 40 1500.00 <p>Primero creamos un nuevo Proyecto en VSCode llamado <code>EmpleadosBD</code> y le a\u00f1adimos la librer\u00eda sqlite al build path.</p> <p>Creamos tambi\u00e9n la base de datos mediante la l\u00ednea de comandos:</p> Bash<pre><code>cd directorio-del-proyecto\nmkdir bd\ncd bd\nsqlite empleados.bd\n</code></pre> <p>Copiamos el archivo <code>DatabaseConnection.java</code> del anterior proyecto y modificamos la cadena de conexi\u00f3n:</p> Java<pre><code>String host = \"jdbc:sqlite:./bd/empleados.bd\";\ncon = java.sql.DriverManager.getConnection( host);\n</code></pre>"},{"location":"ud09/ud0910/#crear-tabla","title":"Crear tabla","text":"<p>Creamos una clase <code>CreateTable</code> para poder crear la tabla:</p> Java<pre><code>import java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class CreateTable {\n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n    public static vold main(String[] args) { \n        Statement st = null; \n        String sql = \"CREATE TABLE empleados ( \" + \n                     \" num INTEGER PRIMARY KEY, \" + \n                     \" nombre VARCHAR(255), \" +\n                     \" departamento INTEGER, \" + \n                     \" edad INTEGER, \" + \n                     \" sueldo REAL);\"; \n        try { \n            st = con.createStatement(); \n            st.executeUpdate(sql); \n        } catch (sQLException ex) { \n            system.out.println(\"Error \" + ex.getMessage()); \n        } finally {\n            try {\n                if (st != null &amp;&amp; !st.isClosed()) {\n                    st.close(); \n                }\n            } catch (SQLException ex) { \n                system.out.println (\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n            }\n            try {\n                if (con != null &amp;&amp; !con.isClosed()) {\n                    con.close(); \n                }\n            } catch (SQLException ex) { \n                system.out.println (\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0910/#insertar-datos","title":"Insertar datos","text":"<p>Y creamos otra para insertar datos. Esta vez lo haremos con <code>PreparedStatement</code>:</p> Java<pre><code>import java.sql.PreparedStatement; \nimport java.sql.SQLException; \n\npublic class InsertData { \n  static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      PreparedStatement st = null;\n      String sql = \"INSERT INTO empleados (num, nombre, departamento, edad, sueldo) VALUES (?, ?, ?, ?, ?)\"; \n      try { \n          st = con.prepareStatement(sql); \n          st.setlnt(1, 1); \n          st.setString(2, \"Andreu\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 32); \n          st.setDouble(5, 1000.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 2); \n          st.setString(2, \"Bernat\"); \n          st.setlnt(3, 20); \n          st.setlnt(4, 28); \n          st.setDouble(5, 1200.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 3); \n          st.setString(2, \"Claudia\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 26);\n          st.setDouble(5, 1400.0); \n          st.executeUpdate(); \n\n          st.setlnt(1, 4); \n          st.setString(2, \"Dami\u00e1n\"); \n          st.setlnt(3, 10); \n          st.setlnt(4, 40); \n          st.setDouble(5, 1300.0); \n          st.executeUpdate(); \n\n      } catch (SQLException ex) { \n          System.out.println(\"Error \" + ex.getMessage()); \n\n      } finally { \n          try { \n              if (st != null &amp;&amp; !st.isClosed()) { \n                  st.close(); \n              } \n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\"); \n          } \n\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) { \n                  con.close(); \n              } \n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar Connection por alguna raz\u00f3n\"); \n          } \n      }\n  }\n}\n</code></pre> <p>Esta es la versi\u00f3n con <code>Statement</code>:</p> Java<pre><code>import java.sql.Statement; \nimport java.sql.SQLException; \n\npublic class InsertDataStatement { \n  static java.sql.Connection con = Databaseconnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      Statement st = null; \n      String sql = \"\"; \n\n      try { \n          st = con.createStatement();\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALUES (5, 'Arturo', 10, 32, 1088.8)\"; \n          st.executeUpdate(sql); \n\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALSES (6, 'Juan', 28, 28, 1280.8)\";\n          st.executeUpdate(sql); \n\n          sql = \"INSERT INTO EMPLEADOS (num, nombre, departamento, edad, sueldo) VALUES (2, 'Mart\u00edn', 10, 26, 1488.8)\"; \n          st.executeUpdate(sql); \n\n      } catch (SQLEXCeptiOn ex) {\n          System.ont.println(\"Error: \"+ ex.getMesSege());\n\n      } finally {\n          try { \n              if (st != null &amp;&amp; !st.isClosed()) {\n                  st.close(); \n              }\n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) {\n                  con.close(); \n              }\n          } catch (SQLException ex) { \n              System.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n      }\n  }\n}\n</code></pre>"},{"location":"ud09/ud0910/#consultar-datos","title":"Consultar datos","text":"<p>Creamos una clase <code>getAllEmpleados</code> que nos devuelva todos los empleados:</p> Java<pre><code>import java.sql.Resultset; \nimport java.sql.SQLException; \nimport java.sql.Statement; \n\npublic class getAllEmpleados { \n    static java.sql.Connection con = DatabaseConnection.getInstance().getConnection(); \n\n    public static void main(String[] args) { \n        Statement st = null; \n        Resultset rs = null; \n\n        try {\n            st = con.createStatement(); \n            rs = st.executeQuery(\"SELECT * FROM empleados\"); \n            System.out.println(\"N\u00fam. \\tNombre \\tDep \\tEdad \\tSueldo\"); \n            System.out.println(\"------------------------------------------\");\n            while (rs.next()){ \n                System.out.print(rs.getInt(1) + \"\\t\"); \n                system.out.print(rs.getString(2) + \"\\t\"); \n                system.out.print(rs.getInt(3) + \"\\t\"); \n                system.out.print(rs.getInt(4) + \"\\t\"); \n                System.out.println(rs.getDouble(5)); \n\n        } catch(SQLException e) { \n                System.out.println(\"Se ha producido un error al leer los usuarios \" + e.getMessage());           \n\n        } finally { \n            try { \n                //Siempre se debe cerrar todo lo abierto \n                if (st != null) {\n                    st.close(); \n                }\n            } catch (java.sql.SQLException ex){\n                System.out.println(\"Se ha producido un error: \" + ex.getMessage()); \n            }\n            try { \n                //Siempre se debe cerrar todo lo abierto \n                if (rs != null) {\n                    rs.close(); \n                }\n            } catch (java.sql.SQLException ex){\n                System.out.println(\"Se ha producido un error: \" + ex.getMessage()); \n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud09/ud0910/#modificar-datos","title":"Modificar datos","text":"<p>Ahora modificamos los datos. Simplemente aumentamos el sueldo un 5% y modificamos el departamento del empleado 3, poni\u00e9ndole el departamento 3.</p> Java<pre><code>import java.sql.Statement; \nimport java.sql.SQLException; \n\npublic class ModifyData { \n  static java.sql.Connection con = Databaseconnection.getInstance().getConnection(); \n\n  public static void main(String[] args) { \n      Statement st = null; \n      String sql = \"\";\n      try {\n          st = con.createStatement(); \n          sql = \"UPDATE EMPLEADOS SET sueldo = sueldo * 1.05\";\n          st.executeUpdate(sql);\n\n          sql = \"UPDATE EMPLEADOS SET departamento = 20 WHERE num = 3\";\n          st.executeUpdate(sql); \n\n      } catch (SQLException ex) { \n          system.out.printlnr(\"Error \"+ ex.getMessage());\n\n      } finally { \n          try { \n              if (st != null &amp;&amp; !st.isClosed()) { \n                  st.close(); \n              } \n          } catch (SQLException ex) { \n              system.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n          try { \n              if (con != null &amp;&amp; !con.isClosed()) { \n                  con.close(); \n              } \n          } catch (SQLException ex) { \n              system.out.println(\"No se ha podido cerrar el Statement por alguna raz\u00f3n\");\n          }\n      }\n  }\n}\n</code></pre>"},{"location":"ud09/ud0911/","title":"9.11 Repository pattern","text":"<p>Descarga</p> <p>Descarga la base de datos desde aqu\u00ed.</p> <p>En este apartado vamos a aprender a a\u00f1adir a un proyecto orientado a objetos la persistencia en base de datos, sin usar ninguna tecnolog\u00eda como Hibernate.</p> <p>Partimos de una aplicaci\u00f3n en la que los usuarios pueden escribir Posts y comentar Posts hechos por otros usuarios. Por lo que existen tres entidades: Users, Posts y Comments. En la siguiente imagen se muestran estas entidades representadas en una base de datos:</p> <p>En programaci\u00f3n existen una serie de est\u00e1ndares denominados Patrones de Dise\u00f1o que debes conocer para poder programar seg\u00fan estos patrones y no reinventar la rueda.</p> <p>Nota</p> <p>Nosotros vamos a implementar \u201cRepository Pattern\u201d porque tambi\u00e9n os va a servir para cualquier aplicaci\u00f3n tanto web, m\u00f3vil o de escritorio.</p> <p>Seg\u00fan la documentaci\u00f3n de Android.</p> <p>The repository pattern is a design pattern that isolates the data layer from the rest of the app. The data layer refers to the part of your app, separate from the UI, that handles the app\u2019s data and business logic, exposing consistent APIs for the rest of your app to access this data.</p>"},{"location":"ud09/ud0911/#database-connection","title":"Database Connection","text":"<p>Esta es la misma clase del apartado anterior:</p> Java<pre><code>/*\n * @see &lt;a href=\"https://stackoverflow.com/questions/6567839/if-i-use-a-singleton-class-for-a-database-connection-can-one-user-close-the-con\"&gt;Stackoverflow Singleton&lt;/a&gt;\n * Patron Singleton\n * ================\n * Este patr\u00f3n de dise\u00f1o est\u00e1 dise\u00f1ado para restringir la creaci\u00f3n de objetos pertenecientes a una clase. Su intenci\u00f3n consiste en garantizar que\n * una clase s\u00f3lo tenga una instancia y proporcionar un punto de acceso global a ella.\n * El patr\u00f3n Singleton se implementa creando en nuestra clase un m\u00e9todo que crea una instancia del objeto s\u00f3lo si todav\u00eda no existe alguna.\n * Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor haci\u00e9ndolo privado.\n * Las situaciones m\u00e1s habituales de aplicaci\u00f3n de este patr\u00f3n son aquellas en las que dicha clase ofrece un conjunto de utilidades comunes\n * para todas las capas (como puede ser el sistema de log, conexi\u00f3n a la base de datos, ...)\n * o cuando cierto tipo de datos debe estar disponible para todos los dem\u00e1s objetos de la aplicaci\u00f3n.\n * El patr\u00f3n Singleton provee una \u00fanica instancia global gracias a que:\n * - La propia clase es responsable de crear la \u00fanica instancia.\n * - Permite el acceso global a dicha instancia mediante un m\u00e9todo de clase.\n * - Declara el constructor de clase como privado para que no sea instanciable directamente.\n */\npublic class DatabaseConnection\n{\n    private static DatabaseConnection dbInstance; //Variable para almacenar la unica instancia de la clase\n    private static java.sql.Connection con;\n\n    private DatabaseConnection() {\n        // El Constructor es privado!!\n    }\n\n    public static DatabaseConnection getInstance(){\n        //Si no hay ninguna instancia...\n        if(dbInstance==null){\n            dbInstance= new DatabaseConnection();\n        }\n        return dbInstance;\n    }\n\n    public  static java.sql.Connection getConnection(){\n\n        if(con==null){\n            try {\n                String host = \"jdbc:sqlite:src/main/resources/network\";\n                con = java.sql.DriverManager.getConnection( host );\n                System.out.println(\"Conexi\u00f3n realizada\");\n            } catch (java.sql.SQLException ex) {\n                System.out.println(\"Se ha producido un error al conectar: \" + ex.getMessage());\n            }\n        }\n\n        return con;\n    }\n}\n</code></pre>"},{"location":"ud09/ud0911/#interfaz-irepository","title":"Interfaz IRepository","text":"<p>Vamos a empezar creando la interfaz <code>IRepository</code> que han de implementar todas las clases que accedan a datos.</p> Java<pre><code>import java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\npublic interface IRepository&lt;T&gt; {\n    List&lt;T&gt; findAll() throws SQLException;\n    T findById(int id) throws SQLException;\n    void save(T entity)  throws SQLException;\n    void delete(T entity) throws SQLException ;\n    T bdToEntity(ResultSet rs) throws SQLException ;\n}\n</code></pre> <p>Fijaos en la notaci\u00f3n <code>&lt;T&gt;</code>. Esto indica que vamos a usar tipos gen\u00e9ricos. Puede ser cualquier clase de java.</p> <ul> <li><code>findAll()</code> va a recuperar datos de la base de datos y va a crear una lista de objetos <code>T</code>, donde <code>T</code>ser\u00e1 usuario, post o comentario.</li> <li><code>findById(int id)</code> va a recuperar el objeto <code>T</code> con dicho <code>id</code></li> <li><code>save(T entity)</code> va a guardar el objeto <code>T</code> en la base de datos</li> <li><code>deleteById(User user)</code> va a borrar el objeto <code>user</code> en la base de datos</li> <li><code>bdToEntity(Resulset s)</code> va a encargarse de convertir un registro de la base de datos en una clase de tipo <code>T</code>, por ejemplo un usuario, un post o un comentario.</li> </ul>"},{"location":"ud09/ud0911/#socialnetworkservice","title":"SocialNetworkService","text":"<p>Un servicio es un tipo de clase que gestiona recursos que se usan en cualquier parte de la aplicaci\u00f3n. Es este caso estamos definiendo el recurso <code>java.sql.Connection</code>:</p> Java<pre><code>public class SocialNetworkService {\n\n    static  final java.sql.Connection connection = DatabaseConnection.getInstance().getConnection();\n    public static java.sql.Connection getConnection(){\n        return connection;\n    }\n}\n</code></pre> <p>M\u00e1s adelante lo usaremos en le m\u00e9todo <code>main</code></p>"},{"location":"ud09/ud0911/#user","title":"User","text":"<p>Esta es la clase que va a almacenar los datos de la base de datos. Es una clase <code>POJO (Plain Old Java Object)</code></p> Java<pre><code>import java.util.ArrayList;\n\npublic class User\n{\n    private int id;\n    private String name;\n    private String lastName;\n\n    public User()\n    {\n        this.name = \"\";\n        this.lastName = \"\";\n        this.id = -1;\n    }\n    public User(int id, String name, String lastName){\n        this.id = id;\n        this.name = name;\n        this.lastName = lastName;\n    }\n    public User(String name, String lastName)\n    {\n        this(-1, name, lastName);\n    }\n    public int getId(){\n        return id;\n    }\n    public void setId(int id){\n        this.id = id;\n    }\n    public String getName(){\n        return name;\n    }\n    public void setName(String name){\n        this.name = name;\n    }\n    public String getLastName(){\n        return lastName;\n    }\n    public void setLastName(String lastName){\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString(){\n        return \"ID: \" + id + \" Name: \" + name + \" Lastname: \" + lastName;\n    }\n\n}\n</code></pre>"},{"location":"ud09/ud0911/#userrepositoryimpl","title":"UserRepositoryImpl","text":"<p>Esta clase va a ser la que realice el mapeo entre la base de datos y los objetos del modelo de datos de tal forma que va a corregir el llamado desfase objeto-relacional. B\u00e1sicamente consiste en convertir los registros de la base de datos en objetos y almacenar en la base de datos los objetos de mi modelo.</p> Java<pre><code>import java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UserRepositoryImpl implements IRepository&lt;User&gt; {\n    private java.sql.Connection con;\n    public UserRepositoryImpl(){\n        this.con = SocialNetworkService.getConnection();\n    }\n\n    /**\n     * Se encarga de mapear um registro de la base de datos para converirlo en un objeto User\n     * @param rs\n     * @return Un objeto User\n     * @throws SQLException\n     */\n    public User bdToEntity(ResultSet rs) throws SQLException {\n        return new User(rs.getInt(\"id\"), rs.getString(\"name\"), rs.getString(\"lastName\"));\n    }\n\n    /**\n     * Consulta todos los registros de la tabla users\n     * @return Una lista de objetos User\n     * @throws SQLException\n     */\n    public List&lt;User&gt; findAll() throws SQLException {\n\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n\n        Statement st = this.con.createStatement();\n        //Ejecutar la consulta, guardando los datos devueltos en un Resulset\n        ResultSet rs = st.executeQuery(\"SELECT * FROM users ORDER BY lastName, name\");\n\n        while(rs.next()){\n            //Mapeamos el registro de la BD en un User\n            User u =  bdToEntity(rs);\n            //A\u00f1adir el User al conjunto de users\n            users.add(u);\n        }\n        return users;\n    }\n    //De momento estos tres m\u00e9todos no hacen nada pero hacen falta para poder probar findAll\n    public User findById(int id) throws SQLException {\n        return new User();\n    }\n   public void save(User user) throws SQLException{\n\n    }\n\n    public void delete(User user) throws SQLException {\n\n    }\n}\n</code></pre> <p>Para que pueda compilar esta clase es necesario que est\u00e9n implementados (aunque no hagan nada) todos los m\u00e9todos de la interfaz <code>IRepository</code> por eso el cuerpo del m\u00e9todo no hace nada.</p>"},{"location":"ud09/ud0911/#socialnetwork","title":"SocialNetwork","text":"<p>Esta clase va a contener el m\u00e9todo <code>main</code>. De momento vamos a probar que podemos listar los usuarios de la aplicaci\u00f3n.</p> Java<pre><code>import java.sql.SQLException;\nimport java.util.List;\n\npublic class SocialNetwork {\n\n    public static void main(String[] args) throws SQLException {\n\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        List&lt;User&gt; userList = userRepository.findAll();\n        for (User u : userList){\n            System.out.println(u);\n        }\n    }\n}\n</code></pre> <p>Y la salida:</p> Bash<pre><code>ID: 4 Name: Janet Lastname: Espinosa\nID: 6 Name: Maria Lastname: Gallardo\nID: 3 Name: Andr\u00e9s Lastname: Garc\u00eda\nID: 8 Name: Alberto Lastname: Gracia\nID: 14 Name: Juan Lastname: Imedio\nID: 13 Name: Juan Lastname: Marqu\u00e9s\nID: 18 Name: Pedro Lastname: Mart\u00ednez\nID: 12 Name: Juan Lastname: Mar\u00eda\nID: 23 Name: Juan Pedro Lastname: Pascal\nID: 5 Name: Pepe Lastname: Ponz\n</code></pre>"},{"location":"ud09/ud0911/#userrepositoryimpl-ii","title":"UserRepositoryImpl II","text":"<p>Ya podemos finalizar <code>UserRepositoryImpl</code> con los m\u00e9todos que faltan.</p> Java<pre><code>/**\n * Busca un usuario por id en la tabla users\n * @param id\n * @return El objeto User o null si no existe\n * @throws SQLException\n */\n\npublic User findById(int id) throws SQLException {\n    PreparedStatement st = con.prepareStatement(\"SELECT * FROM users WHERE id = ? \");\n    st.setInt(1, id);\n\n    ResultSet rs = st.executeQuery();\n    User u = null;\n    //Si la consulta devuelve alg\u00fan resultado ...\n    if (rs.next()){\n        // ... lo mapeamos a un objeto Usuario\n        u = bdToEntity(rs);\n    }\n    //Devolvemos el Usuario ya mapeado\n    return u;\n}\n</code></pre> <p>Devolvemos el <code>User</code> si existe en la tabla users</p> Java<pre><code>/**\n     * Guarda el usuario User en la base de datos, insertando si id es distinto de -1 o actualizando aqu\u00e9l\n     * registro con dicho id\n     * @param user\n     * @throws SQLException\n     */\npublic void save(User user) throws SQLException{\n    if (user.getId() == -1){\n        ResultSet rs;\n        PreparedStatement st = null;\n        String query = \"INSERT INTO users (name, lastName) VALUES (?, ?)\";\n        //Fij\u00e1os en Statement.RETURN_GENERATED_KEYS. Permite recuperar el campo ID autogenerado por MySql\n        st = con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);\n\n        st.setString(1, user.getName());\n        st.setString(2, user.getLastName());\n\n        st.executeUpdate();\n\n        //Recuperar el id autogenerado\n        rs = st.getGeneratedKeys();\n        //Este ResultSet solo puede contener un registro: el ID autogenerado\n\n        if (rs.next()){\n            //Ahora ya sabemos cu\u00e1l es el nuevo id del Usuario\n            user.setId(rs.getInt(1));\n            System.out.println(\"Autogenerated ID:  \" + user.getId());\n        }\n    }else{\n        PreparedStatement st = con.prepareStatement(\"UPDATE users SET name = ?, lastName = ? WHERE id = ?\");\n        st.setString(1, user.getName());\n        st.setString(2, user.getLastName());\n        st.setInt(3, user.getId());\n\n        st.executeUpdate();\n    }\n\n}\n</code></pre> <p>En esta caso estamos convirtiendo objetos <code>User</code> en registros de la base de datos users.</p> Java<pre><code>/**\n * Elimina de la base de datos el usuario user\n * @param user\n * @throws SQLException\n */\npublic void delete(User user) throws SQLException {\n    PreparedStatement st = con.prepareStatement(\"DELETE FROM users WHERE id = ?\");\n    st.setInt(1, user.getId());\n    st.executeUpdate();\n    st.close();\n}\n</code></pre> <p>Y por \u00faltimo, borramos un objeto de su correspondiente usuario en la base de datos.</p> <p>Nota:</p> <p>Estos ser\u00edan los componentes necesarios para implementar el patr\u00f3n repositorio.</p> <p>Resumiendo: - tenemos la interfaz <code>IRepository</code> - tenemos n clases <code>POJO</code> - por cada clase <code>POJO</code> creamos una clase <code>nombreDeClaseRepositoryImpl</code> que implemente la interfaz <code>IRepository</code> - Tambi\u00e9n creamos la clase <code>nombreDeClaseController</code> que se va a encargar de gestionar el interfaz de usuario</p>"},{"location":"ud09/ud0911/#usercontroller","title":"UserController","text":"<p>Por \u00faltimo vamos a implementar una clase llamada <code>UserController</code> que nos va a servir como User Interface UI para nuestra aplicaci\u00f3n. Esta clase ya no forma parte del patr\u00f3n repositorio y pasar\u00eda a forma parte m\u00e1s bien del patr\u00f3n Model View Controller (MVC) pues esta clase se encarga de la parte Controller (y en este caso, tambi\u00e9n View)</p> Java<pre><code>import java.sql.SQLException;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class UserController {\n\n    /**\n     * Imprime por pantalla todos los usuarios\n     * @throws SQLException\n     */\n    public static void prinAllUsers() throws SQLException {\n\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        List&lt;User&gt; users = userRepository.findAll();\n        for (User user : users){\n            System.out.println(user);\n        }\n\n    }\n    /**\n     * Muestra una interfaz  de usuario para a\u00f1adir un usuario\n     * @throws SQLException\n     */\n    public static void addUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Name: \");\n        String name = sc.nextLine();\n        System.out.print(\"Lastname: \");\n        String lastName = sc.nextLine();\n        User user = new User(name, lastName);\n        userRepository.save(user);\n    }\n\n    /**\n     * Muestra la UI para modificar un usuario\n     * @throws SQLException\n     */\n    public static void modifyUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        prinAllUsers();\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Enter User id to modify: \");\n        int userId = sc.nextInt();\n        sc.nextLine();\n        System.out.print(\"New name: \");\n        String name = sc.nextLine();\n        System.out.print(\"New lastname: \");\n        String lastName = sc.nextLine();\n        userRepository.save(new User(userId, name, lastName));\n    }\n\n    /**\n     * Muestra la UI para borrar un usuario.\n     * @throws SQLException\n     */\n    public static void deleteUser() throws SQLException{\n        UserRepositoryImpl userRepository = new UserRepositoryImpl();\n        prinAllUsers();\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter user id to delete: \");\n        User user = userRepository.findById(sc.nextInt());\n        userRepository.delete(user);\n    }\n}\n</code></pre> <p>En los m\u00e9todos <code>addUser</code>, <code>updateUser</code> y <code>deleteUser</code> se piden datos por pantalla y se llama al m\u00e9todo del repositorio correspondiente: <code>userRepository.save</code> o <code>userRepository.delete</code></p>"},{"location":"ud09/ud0911/#posts","title":"Posts","text":"<p>Crea las clases necesarias para poder trabajar con la entidad <code>Post</code>. Como ayuda, ten en cuenta que esta entidad tiene un objeto de la clase <code>User</code> que deber\u00e1s recuperar mediante <code>new UserRepositoryImpl().findById(rs.getInt(\"userId\"))</code></p> <p>Lo m\u00e1s complicado ser\u00e1 la parte <code>1</code> en <code>User</code> ya que debe tener un m\u00e9todo que fije los <code>Post</code> de dicho usuario.</p> <p>En principio ser\u00eda tan f\u00e1cil como hacer en el m\u00e9todo <code>bdToEntity</code> de <code>UserRepositoryImpl</code></p> <p><code>java PostRepositoryImpl repository = new PostRepositoryImpl(); user.setPosts(repository.findByUser(user));</code> </p> <p>Pero esto provoca un error en tiempo de ejecuci\u00f3n <code>StackOverflow</code> debido a que entra en un bucle infinito ya que el m\u00e9todo <code>bdToEntity</code> llama a <code>findByUser</code> que a su vez llama a <code>bdToEntity</code> y as\u00ed hasta el infinito.</p> <p>La soluci\u00f3n es guardar los elementos en cach\u00e9: cada vez que convierto una entidad a objeto la guardo en esta cach\u00e9. Cuando debo mapear alg\u00fan registro primero miro en cach\u00e9 y devuelvo la entidad o mapeo si no existe la entidad.</p> <p>Creamos una variable de instancia en cada Repositorio. Por ejemplo para UserRepositoryImpl</p> Java<pre><code>private Set&lt;User&gt; usersCached = new HashSet&lt;&gt;();\n</code></pre> <p>Creamos un m\u00e9todo para comprobar si est\u00e1 en cach\u00e9:</p> Java<pre><code>private User getUserCached(int i){\n    for(User user : usersCached){\n        if (user.getId() == i) \n            return user;\n    }\n    return null;\n}\n</code></pre> <p>Que usamos en <code>bdToEntity</code></p> Java<pre><code>public User bdToEntity(ResultSet rs) throws SQLException {\n    User user = getUserCached(rs.getInt(\"id\"));\n    if (user == null) {\n        user = new User(rs.getInt(\"id\"), rs.getString(\"name\"), rs.getString(\"lastName\"));\n        usersCached.add(user);\n        PostRepositoryImpl repository = new PostRepositoryImpl();\n        user.setPosts(repository.findByUser(user));\n    }\n    return user;\n}\n</code></pre> <p>Nota:</p> <p>No cre\u00e1is que en la pr\u00e1ctica es tan complicado. Para eso est\u00e1n los frameworks ORM (Object Relational Mapping) que nos facilitan mucho la vida y ellos mismos ya tratan todo el tema de cach\u00e9s, repositorios, CRUD, etc. Este apartado es simplemente para que cre\u00e9is desde cero un mini framework.</p> <p>Seguramente en la empresa utilizar\u00e9is Hibernate, Spring Boot, Doctrine, \u2026</p> <p>Comments</p> <p>Ahora ya puedes implementar la gesti\u00f3n del los comentarios.</p>"},{"location":"ud09/ud09ac/","title":"Actividades","text":"<p>A tener en cuenta</p> <p>Para la realizaci\u00f3n de los siguientes ejercicios utilizaremos:   - la base de datos <code>ejercicios</code>,    - usuario <code>dwes</code> y    - contrase\u00f1a <code>1234</code></p>"},{"location":"ud09/ud09ac/#ejercicio-1-paquete-gestionempleados","title":"Ejercicio 1: paquete <code>gestionEmpleados</code>","text":"<p>Tenemos una base de datos <code>ejercicios</code> que almacena informaci\u00f3n sobre empleados. La tabla <code>empleados</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del empleado (entero).</li> <li><code>nombre</code>: Nombre del empleado (cadena de texto).</li> <li><code>salario</code>: Salario del empleado (decimal).</li> </ul> <p>Es escribir un programa Java <code>gestionEmpleados</code> que realice las siguientes operaciones utilizando diferentes tipos de resultado y opciones de concurrencia:</p> <ol> <li><code>listarEmpleados (Connection conn)</code>: Mostrar en la consola todos los empleados y sus salarios.</li> <li><code>actualizarSalarios (Connection conn)</code>: Incrementar el salario de todos los empleados en un 10%.</li> <li><code>eliminarEmpleados (Connection conn)</code>: Eliminar todos los empleados cuyo salario sea menor que $2000.</li> </ol> <p>Para probar ...</p> <p>Puedes implementar cada operaci\u00f3n utilizando un tipo de resultado y opci\u00f3n de concurrencia diferente para familiarizarte con su uso. No olvides manejar las excepciones <code>SQLException</code> adecuadamente. Por ejemplo, podr\u00edas probarlas siguientes operaciones:  1. Lista todos los empleados junto con sus salarios utilizando un <code>ResultSet</code> de tipo <code>TYPE_SCROLL_SENSITIVE</code> y opci\u00f3n de concurrencia <code>CONCUR_READ_ONLY</code>. 2. Actualiza los salarios de todos los empleados increment\u00e1ndolos en un 10% utilizando un <code>ResultSet</code> de tipo <code>TYPE_FORWARD_ONLY</code> y opci\u00f3n de concurrencia <code>CONCUR_UPDATABLE</code>. 3. Elimina todos los empleados cuyo salario sea menor a $2000 utilizando un <code>Statement</code> est\u00e1ndar sin necesidad de un <code>ResultSet</code>.</p> <p>No olvides ...</p> <p>... manejar las excepciones <code>SQLException</code> adecuadamente.</p> <p>Recuerda ...</p> <p>... ajustar la cadena de conexi\u00f3n a tu base de datos y reemplazar \"usuario\" y \"contrase\u00f1a\" con las credenciales adecuadas. Adem\u00e1s, aseg\u00farate de manejar adecuadamente las excepciones.</p>"},{"location":"ud09/ud09ac/#ejercicio-2-paquete-gestionproductos","title":"Ejercicio 2: paquete <code>gestionProductos</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre productos. La tabla <code>productos</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del producto (entero).</li> <li><code>nombre</code>: Nombre del producto (cadena de texto).</li> <li><code>precio</code>: Precio del producto (decimal).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li><code>mostrarProductosPorPagina()</code>: Mostrar una p\u00e1gina de productos cada vez que el usuario lo solicite. Cada p\u00e1gina debe contener 5 productos. Implementa las funciones para mover el cursor a la primera p\u00e1gina, p\u00e1gina siguiente, p\u00e1gina anterior, \u00faltima p\u00e1gina y una p\u00e1gina espec\u00edfica utilizando el m\u00e9todo <code>absolute(int row)</code>.</li> <li><code>buscarProductoPorNombre(String nombre)</code>: Permitir al usuario buscar un producto por su nombre. Utiliza el m\u00e9todo <code>relative(int registros)</code> para desplazar el cursor hacia adelante o hacia atr\u00e1s seg\u00fan la coincidencia del nombre.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-3-paquete-gestionalumnos","title":"Ejercicio 3: paquete <code>gestionAlumnos</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre alumnos. La tabla <code>alumnos</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del alumno (entero).</li> <li><code>nombre</code>: Nombre del alumno (cadena de texto).</li> <li><code>edad</code>: Edad del alumno (entero).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Mostrar la informaci\u00f3n del alumno m\u00e1s joven y m\u00e1s viejo: Utiliza los m\u00e9todos <code>first()</code> y <code>last()</code> para mover el cursor a la primera y \u00faltima fila respectivamente y obtener la informaci\u00f3n del alumno m\u00e1s joven y m\u00e1s viejo.</li> <li>Desplazarse por los alumnos en orden inverso de edad: Muestra la informaci\u00f3n de los alumnos en orden inverso de edad. Utiliza el m\u00e9todo <code>previous()</code> para desplazarte hacia atr\u00e1s a trav\u00e9s de los registros.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-4-paquete-gestionlibros","title":"Ejercicio 4: paquete <code>gestionLibros</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre libros. La tabla <code>libros</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del libro (entero).</li> <li><code>titulo</code>: T\u00edtulo del libro (cadena de texto).</li> <li><code>autor</code>: Nombre del autor del libro (cadena de texto).</li> <li><code>anio_publicacion</code>: A\u00f1o de publicaci\u00f3n del libro (entero).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Mostrar libros por d\u00e9cada: Permite al usuario ingresar una d\u00e9cada y mostrar todos los libros publicados en esa d\u00e9cada. Utiliza el m\u00e9todo <code>afterLast()</code> y <code>previous()</code> para mover el cursor al final y luego retroceder, as\u00ed puedes comenzar desde la \u00faltima fila.</li> <li>Buscar un libro por autor: Permite al usuario ingresar el nombre de un autor y muestra todos los libros escritos por ese autor. Utiliza el m\u00e9todo <code>relative(int registros)</code> para desplazarte a trav\u00e9s de los registros seg\u00fan las coincidencias del autor.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-5-paquete-gestionventas","title":"Ejercicio 5: paquete <code>gestionVentas</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre ventas. La tabla <code>ventas</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico de la venta (entero).</li> <li><code>producto</code>: Nombre del producto vendido (cadena de texto).</li> <li><code>cantidad</code>: Cantidad de productos vendidos (entero).</li> <li><code>total</code>: Total de la venta (decimal).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Calcular el total de ventas: Utiliza el m\u00e9todo <code>next()</code> para recorrer todas las ventas y sumar los totales para obtener el total general de ventas.</li> <li>Buscar ventas por producto: Permite al usuario ingresar el nombre de un producto y muestra todas las ventas asociadas a ese producto. Utiliza el m\u00e9todo <code>relative(int registros)</code> para desplazarte a trav\u00e9s de los registros seg\u00fan las coincidencias del producto.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-6-paquete-gestionpedidos","title":"Ejercicio 6: paquete <code>gestionPedidos</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre pedidos. La tabla <code>pedidos</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del pedido (entero).</li> <li><code>cliente</code>: Nombre del cliente que realiz\u00f3 el pedido (cadena de texto).</li> <li><code>producto</code>: Nombre del producto pedido (cadena de texto).</li> <li><code>cantidad</code>: Cantidad del producto solicitada en el pedido (entero).</li> <li><code>fecha</code>: Fecha en que se realiz\u00f3 el pedido (fecha).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Listar pedidos por cliente: Permite al usuario ingresar el nombre de un cliente y mostrar todos los pedidos realizados por ese cliente. Utiliza el m\u00e9todo <code>relative(int registros)</code> para desplazarte a trav\u00e9s de los registros seg\u00fan las coincidencias del cliente.</li> <li>Buscar pedidos por fecha: Permite al usuario ingresar una fecha y mostrar todos los pedidos realizados en esa fecha. Utiliza el m\u00e9todo <code>afterLast()</code> y <code>previous()</code> para mover el cursor al final y luego retroceder, as\u00ed puedes comenzar desde la \u00faltima fila.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-7-paquete-gestionempleados-continuacion","title":"Ejercicio 7: paquete <code>gestionEmpleados</code> (continuaci\u00f3n)","text":"<p>Continuando con el ejercicio de gesti\u00f3n de empleados del primer conjunto, vamos a agregar algunas funcionalidades adicionales:</p> <ol> <li>Mostrar informaci\u00f3n del empleado por ID: Permite al usuario ingresar el ID de un empleado y muestra toda la informaci\u00f3n relacionada con ese empleado. Utiliza el m\u00e9todo <code>absolute(int row)</code> para posicionarte en el registro del empleado especificado.</li> <li>Buscar empleados por salario: Permite al usuario ingresar un rango de salarios y mostrar todos los empleados cuyo salario est\u00e9 dentro de ese rango. Utiliza el m\u00e9todo <code>next()</code> para recorrer todas las filas y filtrar los empleados seg\u00fan el criterio de salario.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-8-paquete-gestionestudiantes","title":"Ejercicio 8: paquete <code>gestionEstudiantes</code>","text":"<p>Supongamos que tienes una base de datos que almacena informaci\u00f3n sobre estudiantes. La tabla <code>estudiantes</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del estudiante (entero).</li> <li><code>nombre</code>: Nombre del estudiante (cadena de texto).</li> <li><code>edad</code>: Edad del estudiante (entero).</li> <li><code>promedio</code>: Promedio de calificaciones del estudiante (decimal).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Mostrar la posici\u00f3n actual del estudiante: Muestra la posici\u00f3n del estudiante actual en el conjunto de resultados. Utiliza el m\u00e9todo <code>getRow()</code> para obtener el n\u00famero de registro actual.</li> <li>Validar la posici\u00f3n del cursor: Verifica si el cursor est\u00e1 antes del primer registro, en el primer registro, en el \u00faltimo registro o despu\u00e9s del \u00faltimo registro. Utiliza los m\u00e9todos <code>isBeforeFirst()</code>, <code>isFirst()</code>, <code>isLast()</code> e <code>isAfterLast()</code> para realizar estas verificaciones.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-9-paquete-gestionproductos-continuacion","title":"Ejercicio 9: paquete <code>gestionProductos</code> (continuaci\u00f3n)","text":"<p>Continuando con el ejercicio de gesti\u00f3n de productos del segundo conjunto, agreguemos algunas funcionalidades adicionales:</p> <ol> <li>Mostrar el n\u00famero total de productos: Muestra el n\u00famero total de productos en la base de datos. Utiliza el m\u00e9todo <code>getRow()</code> para obtener el n\u00famero de registro actual y <code>last()</code> para mover el cursor a la \u00faltima fila.</li> <li>Verificar si hay productos disponibles: Verifica si hay alg\u00fan producto disponible en la base de datos. Utiliza los m\u00e9todos <code>isBeforeFirst()</code> e <code>isAfterLast()</code> para determinar si el cursor est\u00e1 antes del primer registro o despu\u00e9s del \u00faltimo registro, respectivamente.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-10-paquete-gestionempleados-continuacion","title":"Ejercicio 10: paquete <code>gestionEmpleados</code> (continuaci\u00f3n)","text":"<p>Continuando con el ejercicio de gesti\u00f3n de empleados del tercer conjunto, agreguemos m\u00e1s funcionalidades:</p> <ol> <li>Verificar si hay empleados en la base de datos: Verifica si hay alg\u00fan empleado registrado en la base de datos. Utiliza los m\u00e9todos <code>isBeforeFirst()</code> e <code>isAfterLast()</code> para determinar si el cursor est\u00e1 antes del primer registro o despu\u00e9s del \u00faltimo registro, respectivamente.</li> <li>Mostrar el primer empleado: Muestra la informaci\u00f3n del primer empleado en la base de datos. Utiliza el m\u00e9todo <code>first()</code> para mover el cursor al primer registro y luego muestra la informaci\u00f3n del empleado.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-11-paquete-gestionclientes","title":"Ejercicio 11: paquete <code>gestionClientes</code>","text":"<p>Imagina que tienes una base de datos que almacena informaci\u00f3n sobre clientes. La tabla <code>clientes</code> tiene las siguientes columnas:</p> <ul> <li><code>id</code>: Identificador \u00fanico del cliente (entero).</li> <li><code>nombre</code>: Nombre del cliente (cadena de texto).</li> <li><code>correo</code>: Correo electr\u00f3nico del cliente (cadena de texto).</li> <li><code>telefono</code>: N\u00famero de tel\u00e9fono del cliente (cadena de texto).</li> </ul> <p>Tu tarea es escribir un programa Java que realice las siguientes operaciones utilizando los m\u00e9todos proporcionados:</p> <ol> <li>Mostrar la posici\u00f3n actual del cliente: Muestra la posici\u00f3n actual del cliente en el conjunto de resultados. Utiliza el m\u00e9todo <code>getRow()</code> para obtener el n\u00famero de registro actual.</li> <li>Mostrar informaci\u00f3n del \u00faltimo cliente: Muestra la informaci\u00f3n del \u00faltimo cliente en la base de datos. Utiliza el m\u00e9todo <code>last()</code> para mover el cursor al \u00faltimo registro y luego muestra la informaci\u00f3n del cliente.</li> </ol>"},{"location":"ud09/ud09ac/#ejercicio-12-completo","title":"Ejercicio 12 : completo","text":"<p>Veamos un ejemplo completo de conexi\u00f3n y acceso a una base de datos utilizando todos los elementos mencionados en este apartado.</p> Java<pre><code>try {\n  // Cargamos la clase que implementa el Driver\n  Class.forName(\"com.mysql.cj.jdbc.Driver\").newInstance();\n\n  // Creamos una nueva conexi\u00f3n a la base de datos 'prueba'\n  String url = \"jdbc:mysql://localhost:3306/prueba?serverTimezone=UTC\";\n\n  Connection conn = DriverManager.getConnection(url,\"root\",\"\");\n\n  // Obtenemos un Statement de la conexi\u00f3n\n  Statement st = conn.createStatement();\n\n  // Ejecutamos una consulta SELECT para obtener la tabla vendedores\n  String sql = \"SELECT * FROM vendedores\";\n\n  ResultSet rs = st.executeQuery(sql);\n\n  // Recorremos todo el ResultSet y mostramos sus datos\n\n  while(rs.next()) {\n    int id        = rs.getInt(\"id\");\n    String nombre = rs.getString(\"nombre\");\n    Date fecha    = rs.getDate(\"fecha_ingreso\");\n    float salario = rs.getFloat(\"salario\");\n    System.out.println(id + \" \" + nombre + \" \" + fecha + \" \" + salario);\n  }\n  // Cerramos el statement y la conexi\u00f3n\n  st.close();\n  conn.close();\n\n} catch (SQLException e) {\n    e.printStackTrace();\n\n} catch (Exception e) {\n    e.printStackTrace();\n}\n</code></pre>"},{"location":"ud09/ud09ac/#ejercicio-13","title":"Ejercicio 13","text":"<p>Crea una aplicaci\u00f3n que nos permita gestionar la base de datos redes. </p> <p>Debe tener un men\u00fa desde el que se puedan gestionar (Create, Read, Update, Delete) usuarios, posts y comentarios.</p>"},{"location":"ud09/ud09pi/","title":"P\u00edldoras inform\u00e1ticas","text":"<ul> <li>https://www.youtube.com/playlist?list=PLNjWMbvTJAIjLRW2qyuc4DEgFVW5YFRSR</li> <li>https://www.youtube.com/playlist?list=PLaxZkGlLWHGUWZxuadN3J7KKaICRlhz5-</li> </ul>"},{"location":"ud09/ud09re/","title":"Fuentes de informaci\u00f3n","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>FXDocs</li> <li>https://openjfx.io/openjfx-docs/</li> </ul>"},{"location":"ud10/ud1001/","title":"Ud1001","text":"<p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos.</p> <p>Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.</p> <p>Las bases de datos relacionales permiten organizar los datos en tablas y esas tablas y datos se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>Base de datos relacional</p> <p>Una base de datos relacional se puede definir de una manera simple como aquella que presenta la informaci\u00f3n en tablas con filas y columnas.</p> <p>Una tabla es una serie de filas y columnas , en la que cada fila es un registro y cada columna es un campo. Un campo representa un dato de los elementos almacenados en la tabla (NSS, nombre, etc.). Cada registro representa un elemento de la tabla (la persona Jose, la persona Carmen, etc.)</p> <p>No se permite que pueda aparecer dos o m\u00e1s veces el mismo registro, por lo que uno o m\u00e1s campos de la tabla forman lo que se conoce como clave primaria (atributo que se elige como identificador en una tabla, de manera que no haya dos registros iguales, sino que se diferencien al menos en esa clave). Por ejemplo, en el caso de una tabla que guarda datos de personas, el n\u00famero de la seguridad social, podr\u00eda elegirse como clave primaria, pues sabemos que aunque haya dos personas llamadas, por ejemplo, Juan P\u00e9rez P\u00e9rez, estamos seguros de que su n\u00famero de seguridad social ser\u00e1 distinto).</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS) , gestiona el modo en que los datos se almacenan, mantienen y recuperan.</p> <p>En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p> <p>Tradicionalmente, la programaci\u00f3n de bases de datos ha sido como una Torre de Babel: gran cantidad de productos de bases de datos en el mercado, y cada uno \u201chablando\u201d en su lenguaje privado con las aplicaciones.</p> <p>Java, mediante JDBC ( Java Database Connectivity, API que permite la ejecuci\u00f3n de operaciones sobre bases de datos desde el lenguaje de programaci\u00f3n Java, independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se accede), permite simplificar el acceso a base de datos , proporcionando un lenguaje mediante el cual las aplicaciones pueden comunicarse con motores de bases de datos. Sun desarroll\u00f3 este API para el acceso a bases de datos, con tres objetivos principales en mente:</p> <ul> <li>Ser un API con soporte de SQL: poder construir sentencias SQL e insertarlas dentro de llamadas al API de Java,</li> <li>Aprovechar la experiencia de los APIs de bases de datos existentes,</li> <li>Ser sencillo.</li> </ul>"},{"location":"ud10/ud1001/#conexion-a-las-bbdd-conectores","title":"Conexi\u00f3n a las BBDD: conectores","text":"<p>Dejemos de momento de lado el desfase Objeto-Relacional y centr\u00e9monos ahora en el acceso a Base de Datos Relacionales desde los lenguajes de programaci\u00f3n. Lo razonaremos en general y lo aplicaremos a Java.</p> <p>Desde la d\u00e9cada de los 80 que existen a pleno rendimiento las bases de datos relacionales. Casi todos los Sistemas Gestores de Bases de Datos (excepto los m\u00e1s peque\u00f1os como Access o Base de LibreOffice) utilizan la arquitectura cliente-servidor. Esto significa que hay un ordenador central donde est\u00e1 instalado el Sistema Gestor de Bases de Datos Relacional que act\u00faa como servidor, y habr\u00e1 muchos clientes que se conectar\u00e1n al servidor haciendo peticiones sobre la Base de Datos.</p> <p>Los Sistemas Gestores de Bases de Datos inicialmente dispon\u00edan de lenguajes de programaci\u00f3n propios para poder hacer los accesos desde los clientes. Era muy consistente, pero a base de ser muy poco operativo:</p> <ul> <li>La empresa desarrolladora del SGBD deb\u00edan mantener un lenguaje de programaci\u00f3n, que resultaba necesariamente muy costoso, si no quer\u00edan que quedara desfasado.</li> <li>Las empresas usuarias del SGBD, que se conectaban como clientes, se encontraban muy ligadas al servidor para tener que utilizar el lenguaje de programaci\u00f3n para acceder al servidor, lo que no siempre se ajustaba a sus necesidades. Adem\u00e1s, el plantearse cambiar de servidor, significaba que hab\u00eda que rehacer todos los programas, y por tanto una tarea de much\u00edsima envergadura.</li> </ul> <p>Para poder ser m\u00e1s operativos, hab\u00eda que desvincular los lenguajes de programaci\u00f3n de los Sistemas Gestores de Bases de Datos utilizando unos est\u00e1ndares de conexi\u00f3n.</p>"},{"location":"ud10/ud10ac/","title":"Ud10ac","text":""},{"location":"ud10/ud10ac/#ejercicio-1","title":"Ejercicio 1","text":"<p>...</p>"},{"location":"ud10/ud10ac/#ejercicio-2","title":"Ejercicio 2","text":"<p>Veamos</p>"},{"location":"ud10/ud10pi/","title":"Ud10pi","text":"<ul> <li>https://www.youtube.com/playlist?list=PLNjWMbvTJAIjLRW2qyuc4DEgFVW5YFRSR</li> <li>https://www.youtube.com/playlist?list=PLaxZkGlLWHGUWZxuadN3J7KKaICRlhz5-</li> </ul>"},{"location":"ud10/ud10re/","title":"Ud10re","text":"<ul> <li>Wikipedia</li> <li>Programaci\u00f3n (Grado Superior) - Juan Carlos Moreno P\u00e9rez (Ed. Ra-ma)</li> <li>Apuntes IES Henri Matisse (Javi Garc\u00eda Jimenez?)</li> <li>Apuntes AulaCampus</li> <li>Apuntes Jos\u00e9 Luis Comesa\u00f1a</li> <li>Apuntes IOC Programaci\u00f3 b\u00e0sica (Joan Arnedo Moreno)</li> <li>Apuntes IOC Programaci\u00f3 Orientada a Objectes (Joan Arnedo Moreno)</li> <li>FXDocs</li> <li>https://openjfx.io/openjfx-docs/</li> </ul>"}]}